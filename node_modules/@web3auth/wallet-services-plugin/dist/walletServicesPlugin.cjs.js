/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  WalletServicesPlugin: () => (/* reexport */ WalletServicesPlugin)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/openlogin-jrpc"
const openlogin_jrpc_namespaceObject = require("@toruslabs/openlogin-jrpc");
;// CONCATENATED MODULE: external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// CONCATENATED MODULE: external "@web3auth/ws-embed"
const ws_embed_namespaceObject = require("@web3auth/ws-embed");
var ws_embed_default = /*#__PURE__*/__webpack_require__.n(ws_embed_namespaceObject);
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// CONCATENATED MODULE: ./src/plugin.ts






class WalletServicesPlugin extends openlogin_jrpc_namespaceObject.SafeEventEmitter {
  constructor(options = {}) {
    super();
    defineProperty_default()(this, "name", base_namespaceObject.EVM_PLUGINS.WALLET_SERVICES);
    defineProperty_default()(this, "status", base_namespaceObject.PLUGIN_STATUS.DISCONNECTED);
    defineProperty_default()(this, "SUPPORTED_ADAPTERS", [base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN, base_namespaceObject.WALLET_ADAPTERS.SFA]);
    defineProperty_default()(this, "pluginNamespace", base_namespaceObject.PLUGIN_NAMESPACES.EIP155);
    defineProperty_default()(this, "wsEmbedInstance", void 0);
    defineProperty_default()(this, "provider", null);
    defineProperty_default()(this, "web3auth", null);
    defineProperty_default()(this, "isInitialized", false);
    defineProperty_default()(this, "walletInitOptions", null);
    const {
      wsEmbedOpts,
      walletInitOptions
    } = options;
    // we fake these checks here and get them from web3auth instance
    this.wsEmbedInstance = new (ws_embed_default())(wsEmbedOpts || {});
    this.walletInitOptions = walletInitOptions || {};
  }
  get proxyProvider() {
    return this.wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    var _this$web3auth$coreOp;
    if (this.isInitialized) return;
    if (!web3auth) throw base_namespaceObject.WalletServicesPluginError.web3authRequired();
    if (web3auth.provider && !this.SUPPORTED_ADAPTERS.includes(web3auth.connectedAdapterName)) throw base_namespaceObject.WalletServicesPluginError.notInitialized();
    if (web3auth.coreOptions.chainConfig.chainNamespace !== this.pluginNamespace) throw base_namespaceObject.WalletServicesPluginError.unsupportedChainNamespace();
    // Not connected yet to openlogin
    if (web3auth.provider) {
      this.provider = web3auth.provider;
    }
    this.web3auth = web3auth;
    const mergedWhitelabelSettings = objectSpread2_default()(objectSpread2_default()({}, whiteLabel), this.walletInitOptions.whiteLabel || {});
    const {
      logoDark,
      logoLight
    } = mergedWhitelabelSettings || {};
    if (!logoDark || !logoLight) throw base_namespaceObject.WalletServicesPluginError.invalidParams("logoDark and logoLight are required in whiteLabel config");
    this.wsEmbedInstance.web3AuthClientId = this.web3auth.coreOptions.clientId;
    this.wsEmbedInstance.web3AuthNetwork = this.web3auth.coreOptions.web3AuthNetwork;
    this.subscribeToWeb3AuthEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    if (!connectedChainConfig.blockExplorerUrl) throw base_namespaceObject.WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!connectedChainConfig.displayName) throw base_namespaceObject.WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!connectedChainConfig.logo) throw base_namespaceObject.WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!connectedChainConfig.ticker) throw base_namespaceObject.WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!connectedChainConfig.tickerName) throw base_namespaceObject.WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    const finalInitOptions = objectSpread2_default()(objectSpread2_default()({}, this.walletInitOptions), {}, {
      chainConfig: connectedChainConfig,
      enableLogging: (_this$web3auth$coreOp = this.web3auth.coreOptions) === null || _this$web3auth$coreOp === void 0 ? void 0 : _this$web3auth$coreOp.enableLogging,
      whiteLabel: mergedWhitelabelSettings
    });
    await this.wsEmbedInstance.init(finalInitOptions);
    this.isInitialized = true;
    this.status = base_namespaceObject.PLUGIN_STATUS.READY;
    this.emit(base_namespaceObject.PLUGIN_EVENTS.READY);
  }
  initWithProvider() {
    throw new Error("Method not implemented.");
  }
  async connect({
    sessionId,
    sessionNamespace
  }) {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (!this.isInitialized) throw base_namespaceObject.WalletServicesPluginError.notInitialized();
    this.emit(base_namespaceObject.PLUGIN_EVENTS.CONNECTING);
    this.status = base_namespaceObject.PLUGIN_STATUS.CONNECTING;
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
      }
    }
    if (this.web3auth.status !== base_namespaceObject.ADAPTER_STATUS.CONNECTED) {
      throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
    } else if (!this.web3auth.provider) {
      throw base_namespaceObject.WalletServicesPluginError.providerRequired();
    }
    if (!sessionId) {
      throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
    }
    try {
      var _this$walletInitOptio;
      await this.wsEmbedInstance.loginWithSessionId({
        sessionId,
        sessionNamespace
      });
      if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && (_this$walletInitOptio = _this$walletInitOptio.whiteLabel) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.showWidgetButton) this.wsEmbedInstance.showTorusButton();
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
      this.emit(base_namespaceObject.PLUGIN_EVENTS.CONNECTED);
      this.status = base_namespaceObject.PLUGIN_STATUS.CONNECTED;
    } catch (error) {
      external_loglevel_default().error(error);
      this.status = base_namespaceObject.PLUGIN_STATUS.ERRORED;
      this.emit(base_namespaceObject.PLUGIN_EVENTS.ERRORED, {
        error: error.message || "Something went wrong"
      });
    }
  }
  async showWalletConnectScanner() {
    if (!this.wsEmbedInstance.isLoggedIn) throw base_namespaceObject.WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletConnectScanner();
  }
  async showCheckout() {
    if (!this.wsEmbedInstance.isLoggedIn) throw base_namespaceObject.WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showCheckout();
  }
  async showWalletUi() {
    if (!this.wsEmbedInstance.isLoggedIn) throw base_namespaceObject.WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletUi();
  }
  async disconnect() {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (this.wsEmbedInstance.isLoggedIn) {
      await this.wsEmbedInstance.logout();
      this.emit(base_namespaceObject.PLUGIN_EVENTS.DISCONNECTED);
      this.status = base_namespaceObject.PLUGIN_STATUS.DISCONNECTED;
    } else {
      throw base_namespaceObject.WalletServicesPluginError.invalidSession("Wallet Services plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$wsEmbedInstance;
    (_this$wsEmbedInstance = this.wsEmbedInstance) === null || _this$wsEmbedInstance === void 0 || _this$wsEmbedInstance.provider.on("accountsChanged", (accounts = []) => {
      if (accounts.length === 0) {
        var _this$web3auth2, _this$web3auth3;
        this.wsEmbedInstance.hideTorusButton();
        if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.status) === base_namespaceObject.ADAPTER_STATUS.CONNECTED) (_this$web3auth3 = this.web3auth) === null || _this$web3auth3 === void 0 || _this$web3auth3.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    provider.on("accountsChanged", (data = {
      accounts: []
    }) => {
      this.setSelectedAddress(data.accounts[0]);
    });
    provider.on("chainChanged", chainId => {
      this.setChainID(parseInt(chainId, 16));
    });
    provider.on("disconnect", () => {
      this.wsEmbedInstance.hideTorusButton();
    });
    provider.on("connect", () => {
      var _this$walletInitOptio2;
      if ((_this$walletInitOptio2 = this.walletInitOptions) !== null && _this$walletInitOptio2 !== void 0 && (_this$walletInitOptio2 = _this$walletInitOptio2.whiteLabel) !== null && _this$walletInitOptio2 !== void 0 && _this$walletInitOptio2.showWidgetButton) this.wsEmbedInstance.showTorusButton();
    });
  }
  subscribeToWeb3AuthEvents(web3Auth) {
    web3Auth.on(base_namespaceObject.ADAPTER_EVENTS.CONNECTED, data => {
      this.provider = data.provider || web3Auth.provider;
      if (!this.provider) throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(base_namespaceObject.ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      if (this.wsEmbedInstance.isLoggedIn) {
        await this.wsEmbedInstance.logout();
      }
      this.wsEmbedInstance.hideTorusButton();
    });
  }
  async sessionConfig() {
    if (!this.provider) throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts,
      chainConfig: chainConfig
    };
  }
  async walletServicesSessionConfig() {
    if (!this.wsEmbedInstance.provider) throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId] = await Promise.all([this.wsEmbedInstance.provider.request({
      method: "eth_accounts"
    }), this.wsEmbedInstance.provider.request({
      method: "eth_chainId"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts
    };
  }
  async setSelectedAddress(address) {
    var _walletServicesSessio;
    if (this.web3auth.status !== base_namespaceObject.ADAPTER_STATUS.CONNECTED) throw base_namespaceObject.WalletServicesPluginError.web3AuthNotConnected();
    const walletServicesSessionConfig = await this.walletServicesSessionConfig();
    if (address !== ((_walletServicesSessio = walletServicesSessionConfig.accounts) === null || _walletServicesSessio === void 0 ? void 0 : _walletServicesSessio[0])) {
      throw base_namespaceObject.WalletServicesPluginError.invalidSession();
    }
  }
  async setChainID(chainId) {
    const [sessionConfig, walletServicesSessionConfig] = await Promise.all([this.sessionConfig(), this.walletServicesSessionConfig()]);
    const {
      chainConfig
    } = sessionConfig || {};
    if (!chainConfig.blockExplorerUrl) throw base_namespaceObject.WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!chainConfig.displayName) throw base_namespaceObject.WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!chainConfig.logo) throw base_namespaceObject.WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!chainConfig.ticker) throw base_namespaceObject.WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!chainConfig.tickerName) throw base_namespaceObject.WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    if (chainId !== walletServicesSessionConfig.chainId && chainConfig) {
      try {
        var _this$wsEmbedInstance2, _this$wsEmbedInstance3;
        await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: chainConfig.chainId,
            chainName: chainConfig.displayName,
            rpcUrls: [chainConfig.rpcTarget],
            blockExplorerUrls: [chainConfig.blockExplorerUrl],
            nativeCurrency: {
              name: chainConfig.tickerName,
              symbol: chainConfig.ticker,
              decimals: chainConfig.decimals || 18
            },
            iconUrls: [chainConfig.logo]
          }]
        }).catch(() => {
          // TODO: throw more specific error from the controller
          external_loglevel_default().error("WalletServicesPlugin: Error adding chain");
        }));
        await ((_this$wsEmbedInstance3 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance3 === void 0 ? void 0 : _this$wsEmbedInstance3.request({
          method: "wallet_switchEthereumChain",
          params: [{
            chainId: chainConfig.chainId
          }]
        }));
      } catch (error) {
        // TODO: throw more specific error from the controller
        external_loglevel_default().error("WalletServicesPlugin: Error switching chain");
      }
    }
  }
}
;// CONCATENATED MODULE: ./src/index.ts

module.exports = __webpack_exports__;
/******/ })()
;