import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';
import { EVM_PLUGINS, PLUGIN_STATUS, WALLET_ADAPTERS, PLUGIN_NAMESPACES, WalletServicesPluginError, PLUGIN_EVENTS, ADAPTER_STATUS, ADAPTER_EVENTS } from '@web3auth/base';
import WsEmbed from '@web3auth/ws-embed';
import log from 'loglevel';

class WalletServicesPlugin extends SafeEventEmitter {
  constructor(options = {}) {
    super();
    _defineProperty(this, "name", EVM_PLUGINS.WALLET_SERVICES);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_ADAPTERS", [WALLET_ADAPTERS.OPENLOGIN, WALLET_ADAPTERS.SFA]);
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "wsEmbedInstance", void 0);
    _defineProperty(this, "provider", null);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "walletInitOptions", null);
    const {
      wsEmbedOpts,
      walletInitOptions
    } = options;
    // we fake these checks here and get them from web3auth instance
    this.wsEmbedInstance = new WsEmbed(wsEmbedOpts || {});
    this.walletInitOptions = walletInitOptions || {};
  }
  get proxyProvider() {
    return this.wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    var _this$web3auth$coreOp;
    if (this.isInitialized) return;
    if (!web3auth) throw WalletServicesPluginError.web3authRequired();
    if (web3auth.provider && !this.SUPPORTED_ADAPTERS.includes(web3auth.connectedAdapterName)) throw WalletServicesPluginError.notInitialized();
    if (web3auth.coreOptions.chainConfig.chainNamespace !== this.pluginNamespace) throw WalletServicesPluginError.unsupportedChainNamespace();
    // Not connected yet to openlogin
    if (web3auth.provider) {
      this.provider = web3auth.provider;
    }
    this.web3auth = web3auth;
    const mergedWhitelabelSettings = _objectSpread(_objectSpread({}, whiteLabel), this.walletInitOptions.whiteLabel || {});
    const {
      logoDark,
      logoLight
    } = mergedWhitelabelSettings || {};
    if (!logoDark || !logoLight) throw WalletServicesPluginError.invalidParams("logoDark and logoLight are required in whiteLabel config");
    this.wsEmbedInstance.web3AuthClientId = this.web3auth.coreOptions.clientId;
    this.wsEmbedInstance.web3AuthNetwork = this.web3auth.coreOptions.web3AuthNetwork;
    this.subscribeToWeb3AuthEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    if (!connectedChainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!connectedChainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!connectedChainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!connectedChainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!connectedChainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    const finalInitOptions = _objectSpread(_objectSpread({}, this.walletInitOptions), {}, {
      chainConfig: connectedChainConfig,
      enableLogging: (_this$web3auth$coreOp = this.web3auth.coreOptions) === null || _this$web3auth$coreOp === void 0 ? void 0 : _this$web3auth$coreOp.enableLogging,
      whiteLabel: mergedWhitelabelSettings
    });
    await this.wsEmbedInstance.init(finalInitOptions);
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  initWithProvider() {
    throw new Error("Method not implemented.");
  }
  async connect({
    sessionId,
    sessionNamespace
  }) {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (!this.isInitialized) throw WalletServicesPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
      }
    }
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    } else if (!this.web3auth.provider) {
      throw WalletServicesPluginError.providerRequired();
    }
    if (!sessionId) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    }
    try {
      var _this$walletInitOptio;
      await this.wsEmbedInstance.loginWithSessionId({
        sessionId,
        sessionNamespace
      });
      if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && (_this$walletInitOptio = _this$walletInitOptio.whiteLabel) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.showWidgetButton) this.wsEmbedInstance.showTorusButton();
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
      this.emit(PLUGIN_EVENTS.CONNECTED);
      this.status = PLUGIN_STATUS.CONNECTED;
    } catch (error) {
      log.error(error);
      this.status = PLUGIN_STATUS.ERRORED;
      this.emit(PLUGIN_EVENTS.ERRORED, {
        error: error.message || "Something went wrong"
      });
    }
  }
  async showWalletConnectScanner() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletConnectScanner();
  }
  async showCheckout() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showCheckout();
  }
  async showWalletUi() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletUi();
  }
  async disconnect() {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (this.wsEmbedInstance.isLoggedIn) {
      await this.wsEmbedInstance.logout();
      this.emit(PLUGIN_EVENTS.DISCONNECTED);
      this.status = PLUGIN_STATUS.DISCONNECTED;
    } else {
      throw WalletServicesPluginError.invalidSession("Wallet Services plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$wsEmbedInstance;
    (_this$wsEmbedInstance = this.wsEmbedInstance) === null || _this$wsEmbedInstance === void 0 || _this$wsEmbedInstance.provider.on("accountsChanged", (accounts = []) => {
      if (accounts.length === 0) {
        var _this$web3auth2, _this$web3auth3;
        this.wsEmbedInstance.hideTorusButton();
        if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.status) === ADAPTER_STATUS.CONNECTED) (_this$web3auth3 = this.web3auth) === null || _this$web3auth3 === void 0 || _this$web3auth3.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    provider.on("accountsChanged", (data = {
      accounts: []
    }) => {
      this.setSelectedAddress(data.accounts[0]);
    });
    provider.on("chainChanged", chainId => {
      this.setChainID(parseInt(chainId, 16));
    });
    provider.on("disconnect", () => {
      this.wsEmbedInstance.hideTorusButton();
    });
    provider.on("connect", () => {
      var _this$walletInitOptio2;
      if ((_this$walletInitOptio2 = this.walletInitOptions) !== null && _this$walletInitOptio2 !== void 0 && (_this$walletInitOptio2 = _this$walletInitOptio2.whiteLabel) !== null && _this$walletInitOptio2 !== void 0 && _this$walletInitOptio2.showWidgetButton) this.wsEmbedInstance.showTorusButton();
    });
  }
  subscribeToWeb3AuthEvents(web3Auth) {
    web3Auth.on(ADAPTER_EVENTS.CONNECTED, data => {
      this.provider = data.provider || web3Auth.provider;
      if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      if (this.wsEmbedInstance.isLoggedIn) {
        await this.wsEmbedInstance.logout();
      }
      this.wsEmbedInstance.hideTorusButton();
    });
  }
  async sessionConfig() {
    if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts,
      chainConfig: chainConfig
    };
  }
  async walletServicesSessionConfig() {
    if (!this.wsEmbedInstance.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId] = await Promise.all([this.wsEmbedInstance.provider.request({
      method: "eth_accounts"
    }), this.wsEmbedInstance.provider.request({
      method: "eth_chainId"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts
    };
  }
  async setSelectedAddress(address) {
    var _walletServicesSessio;
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) throw WalletServicesPluginError.web3AuthNotConnected();
    const walletServicesSessionConfig = await this.walletServicesSessionConfig();
    if (address !== ((_walletServicesSessio = walletServicesSessionConfig.accounts) === null || _walletServicesSessio === void 0 ? void 0 : _walletServicesSessio[0])) {
      throw WalletServicesPluginError.invalidSession();
    }
  }
  async setChainID(chainId) {
    const [sessionConfig, walletServicesSessionConfig] = await Promise.all([this.sessionConfig(), this.walletServicesSessionConfig()]);
    const {
      chainConfig
    } = sessionConfig || {};
    if (!chainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!chainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!chainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!chainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!chainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    if (chainId !== walletServicesSessionConfig.chainId && chainConfig) {
      try {
        var _this$wsEmbedInstance2, _this$wsEmbedInstance3;
        await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: chainConfig.chainId,
            chainName: chainConfig.displayName,
            rpcUrls: [chainConfig.rpcTarget],
            blockExplorerUrls: [chainConfig.blockExplorerUrl],
            nativeCurrency: {
              name: chainConfig.tickerName,
              symbol: chainConfig.ticker,
              decimals: chainConfig.decimals || 18
            },
            iconUrls: [chainConfig.logo]
          }]
        }).catch(() => {
          // TODO: throw more specific error from the controller
          log.error("WalletServicesPlugin: Error adding chain");
        }));
        await ((_this$wsEmbedInstance3 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance3 === void 0 ? void 0 : _this$wsEmbedInstance3.request({
          method: "wallet_switchEthereumChain",
          params: [{
            chainId: chainConfig.chainId
          }]
        }));
      } catch (error) {
        // TODO: throw more specific error from the controller
        log.error("WalletServicesPlugin: Error switching chain");
      }
    }
  }
}

export { WalletServicesPlugin };
