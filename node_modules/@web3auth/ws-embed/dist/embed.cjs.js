/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BUTTON_POSITION: () => (/* reexport */ BUTTON_POSITION),
  CONFIRMATION_STRATEGY: () => (/* reexport */ base_controllers_namespaceObject.CONFIRMATION_STRATEGY),
  TorusInPageProvider: () => (/* reexport */ src_inPageProvider),
  WS_EMBED_BUILD_ENV: () => (/* reexport */ WS_EMBED_BUILD_ENV),
  "default": () => (/* reexport */ src_embed)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// CONCATENATED MODULE: external "@toruslabs/ethereum-controllers"
const ethereum_controllers_namespaceObject = require("@toruslabs/ethereum-controllers");
;// CONCATENATED MODULE: external "@toruslabs/openlogin-jrpc"
const openlogin_jrpc_namespaceObject = require("@toruslabs/openlogin-jrpc");
;// CONCATENATED MODULE: external "@toruslabs/openlogin-utils"
const openlogin_utils_namespaceObject = require("@toruslabs/openlogin-utils");
;// CONCATENATED MODULE: external "pump"
const external_pump_namespaceObject = require("pump");
var external_pump_default = /*#__PURE__*/__webpack_require__.n(external_pump_namespaceObject);
;// CONCATENATED MODULE: ./src/isStream.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
  return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
  return isWritableStream(stream) && isReadableStream(stream);
}
;// CONCATENATED MODULE: ./src/messages.ts
/* harmony default export */ const messages = ({
  errors: {
    disconnected: () => "Web3Auth: Lost connection to Web3Auth.",
    permanentlyDisconnected: () => "Web3Auth: Disconnected from iframe. Page reload required.",
    unsupportedSync: method => `Web3Auth: The Web3Auth Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidOptions: maxEventListeners => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
    invalidLoggerMethod: method => `'args.logger' must include required method '${method}'.`
  },
  info: {
    connected: chainId => `Web3Auth: Connected to chain with ID "${chainId}".`
  },
  warnings: {}
});
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// CONCATENATED MODULE: ./src/loglevel.ts

/* harmony default export */ const loglevel = (external_loglevel_default().getLogger("ws-embed"));
;// CONCATENATED MODULE: ./src/utils.ts




// utility functions

/**
 * json-rpc-engine middleware that logs RPC errors and and validates req.method.
 *
 * @param log - The logging API to use.
 * @returns  json-rpc-engine middleware function
 */
function createErrorMiddleware() {
  return (req, res, next) => {
    // json-rpc-engine will terminate the request when it notices this error
    if (typeof req.method !== "string" || !req.method) {
      res.error = openlogin_jrpc_namespaceObject.rpcErrors.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: objectSpread2_default()(objectSpread2_default()({}, req || {}), {}, {
          cause: `The request 'method' must be a non-empty string.`
        })
      });
    }
    next(done => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      loglevel.error(`Ws-Embed - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}

/**
 * Logs a stream disconnection error. Emits an 'error' if given an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param log - The logging API to use.
 * @param remoteLabel - The label of the disconnected stream.
 * @param error - The associated error to log.
 * @param emitter - The logging API to use.
 */
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Web3Auth: Lost connection to "${remoteLabel}".`;
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += `\n${error.stack}`;
  }
  loglevel.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
const EMITTED_NOTIFICATIONS = ["eth_subscription" // per eth-json-rpc-filters/subscriptionManager
];
;// CONCATENATED MODULE: ./src/baseProvider.ts









/**
 * @param connectionStream - A Node.js duplex stream
 * @param opts - An options bag
 */
class BaseProvider extends openlogin_jrpc_namespaceObject.SafeEventEmitter {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super();
    defineProperty_default()(this, "rpcEngine", void 0);
    defineProperty_default()(this, "jsonRpcConnectionEvents", void 0);
    /**
     * Indicating that this provider is a Web3Auth provider.
     */
    defineProperty_default()(this, "isWeb3Auth", void 0);
    defineProperty_default()(this, "state", void 0);
    if (!isDuplexStream(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }
    this.isWeb3Auth = true;
    this.setMaxListeners(maxEventListeners);
    this.handleConnect = this.handleConnect.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
    this.handleStreamDisconnect = this.handleStreamDisconnect.bind(this);
    this.rpcRequest = this.rpcRequest.bind(this);
    this.initializeState = this.initializeState.bind(this);
    this.request = this.request.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.send = this.send.bind(this);
    // this.enable = this.enable.bind(this);

    // setup connectionStream multiplexing
    const mux = new openlogin_jrpc_namespaceObject.ObjectMultiplex();
    external_pump_default()(connectionStream, mux, connectionStream, this.handleStreamDisconnect.bind(this, "Web3Auth"));

    // ignore phishing warning message (handled elsewhere)
    mux.ignoreStream("phishing");

    // setup own event listeners
    // connect to async provider

    const jsonRpcConnection = (0,openlogin_jrpc_namespaceObject.createStreamMiddleware)();
    external_pump_default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this.handleStreamDisconnect.bind(this, "Web3Auth RpcProvider"));

    // handle RPC requests via dapp-side rpc engine
    const rpcEngine = new openlogin_jrpc_namespaceObject.JRPCEngine();
    rpcEngine.push((0,openlogin_jrpc_namespaceObject.createIdRemapMiddleware)());
    rpcEngine.push(createErrorMiddleware());
    rpcEngine.push((0,base_controllers_namespaceObject.createLoggerMiddleware)({
      origin: location.origin
    }));
    rpcEngine.push(jsonRpcConnection.middleware);
    this.rpcEngine = rpcEngine;
    this.jsonRpcConnectionEvents = jsonRpcConnection.events;
  }

  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   *
   * @param args - The RPC request arguments.
   * @returns A Promise that resolves with the result of the RPC method,
   * or rejects if an error is encountered.
   */
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw openlogin_jrpc_namespaceObject.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestArgs(),
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw openlogin_jrpc_namespaceObject.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestMethod(),
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw openlogin_jrpc_namespaceObject.rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestParams(),
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    return new Promise((resolve, reject) => {
      this.rpcRequest({
        method,
        params
      }, (0,openlogin_jrpc_namespaceObject.getRpcPromiseCallback)(resolve, reject));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  send(payload, callback) {
    this.rpcRequest(payload, callback);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  sendAsync(payload) {
    return new Promise((resolve, reject) => {
      this.rpcRequest(payload, (0,openlogin_jrpc_namespaceObject.getRpcPromiseCallback)(resolve, reject));
    });
  }

  /**
   * Called when connection is lost to critical streams.
   *
   * emits InpageProvider#disconnect
   */
  handleStreamDisconnect(streamName, error) {
    logStreamDisconnectWarning(streamName, error, this);
    this.handleDisconnect(false, error ? error.message : undefined);
  }

  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */

  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */

  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits InPageProvider#connect
   */

  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits InpageProvider#disconnect
   */
}
/* harmony default export */ const baseProvider = (BaseProvider);
;// CONCATENATED MODULE: ./src/interfaces.ts

const WS_EMBED_BUILD_ENV = {
  PRODUCTION: "production",
  STAGING: "staging",
  DEVELOPMENT: "development",
  TESTING: "testing"
};
const BUTTON_POSITION = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
};
;// CONCATENATED MODULE: ./src/PopupHandler.ts



class PopupHandler extends openlogin_jrpc_namespaceObject.SafeEventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 30000
  }) {
    super();
    defineProperty_default()(this, "url", void 0);
    defineProperty_default()(this, "target", void 0);
    defineProperty_default()(this, "features", void 0);
    defineProperty_default()(this, "window", void 0);
    defineProperty_default()(this, "windowTimer", void 0);
    defineProperty_default()(this, "iClosedWindow", void 0);
    defineProperty_default()(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || (0,base_controllers_namespaceObject.getPopupFeatures)(base_controllers_namespaceObject.FEATURES_DEFAULT_POPUP_WINDOW);
    this.window = undefined;
    this.windowTimer = undefined;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = undefined;
        }, this.timeout);
      }
      if (this.window === undefined) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url.href, this.target, this.features);
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
}
/* harmony default export */ const src_PopupHandler = (PopupHandler);
;// CONCATENATED MODULE: ./src/communicationProvider.ts










/**
 * @param connectionStream - A Node.js duplex stream
 * @param  opts - An options bag
 */
class CommunicationProvider extends baseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }, state) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });

    // private state
    defineProperty_default()(this, "tryWindowHandle", void 0);
    defineProperty_default()(this, "windowRefs", void 0);
    defineProperty_default()(this, "iframeUrl", void 0);
    defineProperty_default()(this, "iframeId", void 0);
    this.state = objectSpread2_default()(objectSpread2_default()({}, CommunicationProvider.defaultState), state);

    // public state
    this.iframeUrl = "";
    this.iframeId = "";
    this.windowRefs = new Map();

    // setup own event listeners

    // EIP-1193 connect
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const notificationHandler = payload => {
      const {
        method,
        params
      } = payload;
      // create_window should never come here..
      // we either pre-open from embed.
      // if it's blocked, we communicate down that it's blocked and we show full screen iframe and open from iframe
      if (method === base_controllers_namespaceObject.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
        const {
          isFullScreen,
          rid
        } = params;
        this.displayIframe({
          isFull: isFullScreen,
          rid: rid
        });
      } else if (method === base_controllers_namespaceObject.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
        this.handleCloseWindow(params);
      } else if (method === base_controllers_namespaceObject.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
        const {
          currentLoginProvider
        } = params;
        this.state.isLoggedIn = true;
        this.state.currentLoginProvider = currentLoginProvider;
      } else if (method === base_controllers_namespaceObject.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
        this.state.isLoggedIn = false;
        this.state.currentLoginProvider = null;
        this.displayIframe();
      }
    };
    this.jsonRpcConnectionEvents.on("notification", notificationHandler);
  }
  get isLoggedIn() {
    return this.state.isLoggedIn;
  }
  get isIFrameFullScreen() {
    return this.state.isIFrameFullScreen;
  }

  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }
  async initializeState(params) {
    try {
      const {
        torusUrl,
        torusIframeId
      } = params;
      this.iframeUrl = torusUrl;
      this.iframeId = torusIframeId;
      const {
        currentLoginProvider,
        isLoggedIn
      } = await this.request({
        method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });

      // indicate that we've connected, for EIP-1193 compliance
      if (isLoggedIn) this.handleConnect(currentLoginProvider, isLoggedIn);
    } catch (error) {
      loglevel.error("Web3Auth: Failed to get initial state. Please report this bug.", error);
    } finally {
      loglevel.info("initialized communication state");
      this.state.initialized = true;
      this.emit("_initialized");
    }
  }
  hideTorusButton() {
    this.state.widgetVisibility = false;
    this.displayIframe();
  }
  showTorusButton() {
    this.state.widgetVisibility = true;
    this.displayIframe();
  }
  displayIframe({
    isFull = false,
    rid = ""
  } = {}) {
    const style = {};
    // set phase
    if (!isFull) {
      style.display = this.state.widgetVisibility ? "block" : "none";
      style.height = "70px";
      style.width = "70px";
      switch (this.state.buttonPosition) {
        case BUTTON_POSITION.TOP_LEFT:
          style.top = "0px";
          style.left = "0px";
          style.right = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.TOP_RIGHT:
          style.top = "0px";
          style.right = "0px";
          style.left = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_RIGHT:
          style.bottom = "0px";
          style.right = "0px";
          style.top = "auto";
          style.left = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_LEFT:
        default:
          style.bottom = "0px";
          style.left = "0px";
          style.top = "auto";
          style.right = "auto";
          break;
      }
    } else {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      style.top = "0px";
      style.right = "0px";
      style.left = "0px";
      style.bottom = "0px";
    }
    const iframe = document.getElementById(this.iframeId);
    Object.assign(iframe.style, style);
    this.state.isIFrameFullScreen = isFull;
    this.request({
      method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
      params: {
        isIFrameFullScreen: isFull,
        rid
      }
    });
  }

  /**
   * Scenarios:
   * - Login request or pre-open confirmation windows
   * We try to open here or send a rpc request to iframe that window is blocked.
   */
  async handleWindow(windowId, {
    url,
    target,
    features,
    timeout
  } = {}) {
    const finalUrl = new URL(url || `${this.iframeUrl}/redirect?windowId=${windowId}&sessionNamespace=${window.location.hostname}`);
    const handledWindow = new src_PopupHandler({
      url: finalUrl,
      target,
      features,
      timeout
    });
    handledWindow.open();
    if (!handledWindow.window) {
      this.displayIframe({
        isFull: true
      });
      this.request({
        method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED,
        params: {
          windowId,
          finalUrl: finalUrl.href
        }
      });
      return;
    }
    // Add to collection only if window is opened
    this.windowRefs.set(windowId, handledWindow);
    handledWindow.once("close", () => {
      // user closed the window
      this.windowRefs.delete(windowId);
      this.request({
        method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
        params: {
          windowId
        }
      });
    });
  }

  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback) {
    const cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
    }
    this.rpcEngine.handle(_payload, cb);
  }

  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  handleConnect(currentLoginProvider, isLoggedIn) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        currentLoginProvider,
        isLoggedIn
      });
      loglevel.debug(messages.info.connected(currentLoginProvider));
    }
  }

  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new openlogin_jrpc_namespaceObject.EthereumProviderError(1013,
        // Try again later
        errorMessage || messages.errors.disconnected());
        loglevel.debug(error);
      } else {
        error = new openlogin_jrpc_namespaceObject.EthereumProviderError(1011,
        // Internal error
        errorMessage || messages.errors.permanentlyDisconnected());
        loglevel.error(error);
        this.state.currentLoginProvider = null;
        this.state.isLoggedIn = false;
        this.state.widgetVisibility = false;
        this.state.isIFrameFullScreen = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  handleCloseWindow(params) {
    const {
      windowId
    } = params;
    if (this.windowRefs.has(windowId)) {
      this.windowRefs.get(windowId).close();
      this.windowRefs.delete(windowId);
    }
  }
}
defineProperty_default()(CommunicationProvider, "defaultState", {
  buttonPosition: "bottom-left",
  currentLoginProvider: null,
  isIFrameFullScreen: false,
  widgetVisibility: false,
  initialized: false,
  isLoggedIn: false,
  isPermanentlyDisconnected: false,
  isConnected: false,
  hasEmittedConnection: false
});
/* harmony default export */ const src_communicationProvider = (CommunicationProvider);
;// CONCATENATED MODULE: ./src/embedUtils.ts
const handleEvent = (handle, eventName, handler, ...handlerArgs) => {
  const handlerWrapper = () => {
    handler(...handlerArgs);
    handle.removeEventListener(eventName, handlerWrapper);
  };
  handle.addEventListener(eventName, handlerWrapper);
};
const htmlToElement = html => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result
  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
;// CONCATENATED MODULE: external "fast-deep-equal"
const external_fast_deep_equal_namespaceObject = require("fast-deep-equal");
var external_fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(external_fast_deep_equal_namespaceObject);
;// CONCATENATED MODULE: ./src/inPageProvider.ts










/**
 * @param connectionStream - A Node.js duplex stream
 * @param opts - An options bag
 */
class TorusInPageProvider extends baseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });

    // private state
    /**
     * The chain ID of the currently connected EVM chain.
     * See [chainId.network]{@link https://chainid.network} for more information.
     */
    defineProperty_default()(this, "chainId", void 0);
    /**
     * The user's currently selected EVM address.
     * If null, Torus is either locked or the user has not permitted any
     * addresses to be viewed.
     */
    defineProperty_default()(this, "selectedAddress", void 0);
    defineProperty_default()(this, "tryWindowHandle", void 0);
    this.state = objectSpread2_default()({}, TorusInPageProvider.defaultState);

    // public state
    this.selectedAddress = null;
    this.chainId = null;
    this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
    this.handleChainChanged = this.handleChainChanged.bind(this);
    this.handleUnlockStateChanged = this.handleUnlockStateChanged.bind(this);

    // setup own event listeners

    // EIP-1193 connect
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const jsonRpcNotificationHandler = payload => {
      const {
        method,
        params
      } = payload;
      if (method === base_controllers_namespaceObject.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {
        this.handleAccountsChanged(params);
      } else if (method === base_controllers_namespaceObject.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {
        this.handleUnlockStateChanged(params);
      } else if (method === base_controllers_namespaceObject.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {
        this.handleChainChanged(params);
      } else if (EMITTED_NOTIFICATIONS.includes(method)) {
        this.emit("data", payload);
        this.emit("notification", params.result);
        this.emit("message", {
          type: method,
          data: params
        });
      }
    };

    // json rpc notification listener
    this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
  }

  /**
   * Returns whether the inpage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }

  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  async initializeState() {
    try {
      const {
        accounts,
        chainId,
        isUnlocked
      } = await this.request({
        method: base_controllers_namespaceObject.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });

      // indicate that we've connected, for EIP-1193 compliance
      this.emit("connect", {
        chainId
      });
      this.handleChainChanged({
        chainId
      });
      this.handleUnlockStateChanged({
        accounts,
        isUnlocked
      });
      this.handleAccountsChanged(accounts);
    } catch (error) {
      loglevel.error("WsEmbed: Failed to get initial state. Please report this bug.", error);
    } finally {
      loglevel.info("initialized provider state");
      this.state.initialized = true;
      this.emit("_initialized");
    }
  }

  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback, isInternal = false) {
    let cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
      if (_payload.method === "eth_accounts" || _payload.method === "eth_requestAccounts") {
        // handle accounts changing
        cb = (err, res) => {
          this.handleAccountsChanged(res.result || [], _payload.method === "eth_accounts", isInternal);
          callback(err, res);
        };
      } else if (_payload.method === "wallet_getProviderState") {
        this.rpcEngine.handle(payload, cb);
        return;
      }
    }
    this.tryWindowHandle(_payload, cb);
  }

  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */
  handleConnect(chainId) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        chainId
      });
      loglevel.debug(messages.info.connected(chainId));
    }
  }

  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new openlogin_jrpc_namespaceObject.EthereumProviderError(1013,
        // Try again later
        errorMessage || messages.errors.disconnected());
        loglevel.debug(error);
      } else {
        error = new openlogin_jrpc_namespaceObject.EthereumProviderError(1011,
        // Internal error
        errorMessage || messages.errors.permanentlyDisconnected());
        loglevel.error(error);
        this.chainId = null;
        this.state.accounts = null;
        this.selectedAddress = null;
        this.state.isUnlocked = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }

  /**
   * Called when accounts may have changed.
   */
  handleAccountsChanged(accounts, isEthAccounts = false, isInternal = false) {
    // defensive programming
    let finalAccounts = accounts;
    if (!Array.isArray(finalAccounts)) {
      loglevel.error("WsEmbed: Received non-array accounts parameter. Please report this bug.", finalAccounts);
      finalAccounts = [];
    }
    for (const account of accounts) {
      if (typeof account !== "string") {
        loglevel.error("WsEmbed: Received non-string account. Please report this bug.", accounts);
        finalAccounts = [];
        break;
      }
    }

    // emit accountsChanged if anything about the accounts array has changed
    if (!external_fast_deep_equal_default()(this.state.accounts, finalAccounts)) {
      // we should always have the correct accounts even before eth_accounts
      // returns, except in cases where isInternal is true
      if (isEthAccounts && Array.isArray(this.state.accounts) && this.state.accounts.length > 0 && !isInternal) {
        loglevel.error('WsEmbed: "eth_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
      }
      this.state.accounts = finalAccounts;
      this.emit("accountsChanged", finalAccounts);
    }

    // handle selectedAddress
    if (this.selectedAddress !== finalAccounts[0]) {
      this.selectedAddress = finalAccounts[0] || null;
    }
  }

  /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */
  handleChainChanged({
    chainId
  } = {}) {
    if (!chainId) {
      loglevel.error("WsEmbed: Received invalid network parameters. Please report this bug.", {
        chainId
      });
      return;
    }
    if (chainId === "loading") {
      this.handleDisconnect(true);
    } else {
      this.handleConnect(chainId);
      if (chainId !== this.chainId) {
        this.chainId = chainId;
        if (this.state.initialized) {
          this.emit("chainChanged", this.chainId);
        }
      }
    }
  }

  /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */
  handleUnlockStateChanged({
    accounts,
    isUnlocked
  } = {}) {
    if (typeof isUnlocked !== "boolean") {
      loglevel.error("WsEmbed: Received invalid isUnlocked parameter. Please report this bug.", {
        isUnlocked
      });
      return;
    }
    if (isUnlocked !== this.state.isUnlocked) {
      this.state.isUnlocked = isUnlocked;
      this.handleAccountsChanged(accounts || []);
    }
  }
}
defineProperty_default()(TorusInPageProvider, "defaultState", {
  accounts: null,
  isConnected: false,
  isUnlocked: false,
  initialized: false,
  isPermanentlyDisconnected: false,
  hasEmittedConnection: false
});
/* harmony default export */ const src_inPageProvider = (TorusInPageProvider);
;// CONCATENATED MODULE: ./src/siteMetadata.ts
/**
 * Returns whether the given image URL exists
 * @param url - the url of the image
 * @returns whether the image exists
 */
function imgExists(url) {
  return new Promise((resolve, reject) => {
    try {
      const img = document.createElement("img");
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}

/**
 * Extracts a name for the site from the DOM
 */
const getSiteName = window => {
  const {
    document
  } = window;
  const siteName = document.querySelector('head > meta[property="og:site_name"]');
  if (siteName) {
    return siteName.content;
  }
  const metaTitle = document.querySelector('head > meta[name="title"]');
  if (metaTitle) {
    return metaTitle.content;
  }
  if (document.title && document.title.length > 0) {
    return document.title;
  }
  return window.location.hostname;
};

/**
 * Extracts an icon for the site from the DOM
 */
async function getSiteIcon(window) {
  try {
    const {
      document
    } = window;

    // Use the site's favicon if it exists
    let icon = document.querySelector('head > link[rel="shortcut icon"]');
    if (icon && (await imgExists(icon.href))) {
      return icon.href;
    }

    // Search through available icons in no particular order
    icon = Array.from(document.querySelectorAll('head > link[rel="icon"]')).find(_icon => Boolean(_icon.href));
    if (icon && (await imgExists(icon.href))) {
      return icon.href;
    }
    return "";
  } catch (error) {
    return "";
  }
}

/**
 * Gets site metadata and returns it
 *
 */
const getSiteMetadata = async () => ({
  name: getSiteName(window),
  icon: await getSiteIcon(window)
});
/* harmony default export */ const siteMetadata = (getSiteMetadata);
;// CONCATENATED MODULE: ./src/embed.ts













// don't use destructuring for process.env cause it messes up webpack env plugin
const version = "2.0.23";
const addedVersion = version ? `v${version.split(".")[0]}` : "";
const WALLET_URLS_DEFAULT = {
  [WS_EMBED_BUILD_ENV.TESTING]: {
    url: "https://develop-wallet.web3auth.io",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.DEVELOPMENT]: {
    url: "http://localhost:4050",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.STAGING]: {
    url: `https://staging-wallet.web3auth.io/${addedVersion}`,
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.PRODUCTION]: {
    url: `https://wallet.web3auth.io/${addedVersion}`,
    logLevel: "error"
  }
};

// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined") return;
    const torusIframeHtml = document.createElement("link");
    const {
      url: torusUrl
    } = WALLET_URLS_DEFAULT.production;
    torusIframeHtml.href = `${torusUrl}/frame`;
    torusIframeHtml.crossOrigin = "anonymous";
    torusIframeHtml.type = "text/html";
    torusIframeHtml.rel = "prefetch";
    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
      if (torusIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(torusIframeHtml);
      }
    }
  } catch (error) {
    loglevel.warn(error);
  }
})();
const COMMUNICATION_UNSAFE_METHODS = new Set([base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.SET_PROVIDER]);
const PROVIDER_UNSAFE_METHODS = new Set([ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_DECRYPT, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_SIGN, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_SIGN_TYPED_DATA, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, ethereum_controllers_namespaceObject.METHOD_TYPES.PERSONAL_SIGN, ethereum_controllers_namespaceObject.METHOD_TYPES.ETH_TRANSACTION, ethereum_controllers_namespaceObject.METHOD_TYPES.ADD_CHAIN, ethereum_controllers_namespaceObject.METHOD_TYPES.SWITCH_CHAIN]);
class WsEmbed {
  constructor({
    modalZIndex = 99999,
    web3AuthClientId,
    web3AuthNetwork
  }) {
    defineProperty_default()(this, "isInitialized", void 0);
    defineProperty_default()(this, "modalZIndex", void 0);
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "widgetVisibility", void 0);
    defineProperty_default()(this, "communicationProvider", void 0);
    defineProperty_default()(this, "buttonPosition", void 0);
    defineProperty_default()(this, "web3AuthClientId", void 0);
    defineProperty_default()(this, "web3AuthNetwork", void 0);
    defineProperty_default()(this, "isPluginMode", void 0);
    defineProperty_default()(this, "confirmationStrategy", void 0);
    defineProperty_default()(this, "buildEnv", void 0);
    defineProperty_default()(this, "embedNonce", (0,base_controllers_namespaceObject.randomId)());
    this.isInitialized = false; // init done
    this.modalZIndex = modalZIndex;
    this.web3AuthClientId = web3AuthClientId;
    this.web3AuthNetwork = web3AuthNetwork;
  }
  get isLoggedIn() {
    var _this$communicationPr;
    return ((_this$communicationPr = this.communicationProvider) === null || _this$communicationPr === void 0 ? void 0 : _this$communicationPr.isLoggedIn) || false;
  }
  get getBuildEnv() {
    return this.buildEnv;
  }
  async init({
    buildEnv = WS_EMBED_BUILD_ENV.PRODUCTION,
    enableLogging = false,
    chainConfig,
    walletUrls,
    whiteLabel,
    confirmationStrategy = base_controllers_namespaceObject.CONFIRMATION_STRATEGY.DEFAULT
  } = {}) {
    if (this.isInitialized) throw new Error("Already initialized");
    this.buildEnv = buildEnv;
    this.confirmationStrategy = confirmationStrategy;
    const {
      url: torusUrl,
      logLevel
    } = walletUrls && walletUrls[buildEnv] ? objectSpread2_default()(objectSpread2_default()({}, WALLET_URLS_DEFAULT[buildEnv]), walletUrls[buildEnv]) : WALLET_URLS_DEFAULT[buildEnv];
    loglevel.info(torusUrl, "url loaded");
    loglevel.setDefaultLevel(logLevel);
    if (enableLogging) loglevel.enableAll();else loglevel.disableAll();
    const torusIframeUrl = new URL(torusUrl);
    if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";else torusIframeUrl.pathname += "/frame";
    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);
    torusIframeUrl.hash = hashParams.toString();
    const colorScheme = this.getTheme((whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.mode) || openlogin_utils_namespaceObject.THEME_MODES.light);

    // sandbox="allow-popups allow-scripts allow-same-origin"
    // Iframe code
    const walletIframe = htmlToElement(`<iframe
        id="walletIframe-${this.embedNonce}"
        class="walletIframe-${this.embedNonce}"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()};
        color-scheme: ${colorScheme}"
        allow="clipboard-write"
      ></iframe>`);
    this.buttonPosition = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.buttonPosition) || BUTTON_POSITION.BOTTOM_LEFT;
    const dappMetadata = await siteMetadata();
    return new Promise((resolve, reject) => {
      try {
        window.document.body.appendChild(walletIframe);
        // Wait for iframe to send ready
        const handleMessage = async ev => {
          if (ev.origin !== torusIframeUrl.origin) return;
          if (ev.data === base_controllers_namespaceObject.SETUP_COMPLETE) {
            window.removeEventListener("message", handleMessage);
            // send init params here
            walletIframe.contentWindow.postMessage({
              chainConfig,
              dappMetadata,
              enableLogging,
              web3AuthClientId: this.web3AuthClientId,
              web3AuthNetwork: this.web3AuthNetwork,
              whiteLabel,
              confirmationStrategy
            }, torusIframeUrl.origin);
            await this.setupWeb3({
              torusUrl,
              walletIframe
            });
            // if (showTorusButton) this.showTorusButton();
            // else this.hideTorusButton();
            this.widgetVisibility = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.showWidgetButton) || false;
            this.isInitialized = true;
            resolve();
          }
        };
        window.addEventListener("message", handleMessage);
      } catch (error) {
        reject(error);
      }
    });
  }
  async login(params = {}) {
    if (!this.isInitialized) throw new Error("Call init() first");
    try {
      if (!params.loginProvider) {
        this.communicationProvider.displayIframe({
          isFull: true
        });
      }

      // If user is already logged in, we assume they have given access to the website
      const res = await new Promise((resolve, reject) => {
        // We use this method because we want to update inPage provider state with account info
        this.provider.rpcRequest({
          method: "eth_requestAccounts",
          params: [params.loginProvider, params.login_hint]
        }, (0,openlogin_jrpc_namespaceObject.getRpcPromiseCallback)(resolve, reject));
      });
      loglevel.info("check: res", res);
      if (Array.isArray(res) && res.length > 0) {
        if (this.widgetVisibility) this.showTorusButton();
        if (this.confirmationStrategy === base_controllers_namespaceObject.CONFIRMATION_STRATEGY.AUTO_APPROVE) loglevel.warn("Confirmation strategy auto approve is not allowed on Embed Mode, using Default instead.");
        return res;
      }
      // This would never happen, but just in case
      throw new Error("Login failed");
    } catch (error) {
      loglevel.error("login failed", error);
      throw error;
    } finally {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async loginWithSessionId(params) {
    if (!this.isInitialized) throw new Error("Call init() first");
    if (!params.sessionId) throw new Error("sessionId is required");
    try {
      const res = await this.communicationProvider.request({
        method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID,
        params: [params.sessionId, params.sessionNamespace || ""]
      });
      loglevel.info("check: res", res);
      if (res.success) {
        this.isPluginMode = true;
        if (this.widgetVisibility) this.showTorusButton();
        if (this.confirmationStrategy === base_controllers_namespaceObject.CONFIRMATION_STRATEGY.POPUP) loglevel.warn("Confirmation strategy popup is not allowed on Plugin Mode, using Default instead.");
        return res.success;
      }
      // This should never happen, but just in case
      throw new Error("Login failed");
    } catch (error) {
      loglevel.error("login with session id failed", error);
      throw error;
    }
  }
  async logout() {
    if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
    await this.communicationProvider.request({
      method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.LOGOUT,
      params: []
    });
    this.hideTorusButton();
  }
  async cleanUp() {
    var _this$communicationPr2;
    if ((_this$communicationPr2 = this.communicationProvider) !== null && _this$communicationPr2 !== void 0 && _this$communicationPr2.isLoggedIn) {
      await this.logout();
    }
    this.clearInit();
  }
  clearInit() {
    function isElement(element) {
      return element instanceof Element || element instanceof Document;
    }
    const walletIframe = window.document.getElementById(`walletIframe-${this.embedNonce}`);
    if (isElement(walletIframe)) {
      walletIframe.remove();
    }
    this.isInitialized = false;
  }
  hideTorusButton() {
    this.communicationProvider.hideTorusButton();
  }
  showTorusButton() {
    this.communicationProvider.showTorusButton();
  }
  async getUserInfo() {
    const userInfoResponse = await this.communicationProvider.request({
      method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.USER_INFO,
      params: []
    });
    return userInfoResponse;
  }
  async showWalletConnectScanner() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    await this.communicationProvider.request({
      method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT,
      params: []
    });
  }
  async showWalletUi() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    await this.communicationProvider.request({
      method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI,
      params: []
    });
  }
  async showCheckout() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    try {
      await this.communicationProvider.request({
        method: base_controllers_namespaceObject.COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT,
        params: []
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  getConfirmationStrategyFinal(payload) {
    let confirmationStrategyFinal = this.confirmationStrategy;
    if (!Array.isArray(payload) && PROVIDER_UNSAFE_METHODS.has(payload.method) && this.confirmationStrategy !== base_controllers_namespaceObject.CONFIRMATION_STRATEGY.MODAL && !this.isPluginMode) {
      confirmationStrategyFinal = base_controllers_namespaceObject.CONFIRMATION_STRATEGY.POPUP;
    }
    return confirmationStrategyFinal;
  }
  getTheme(theme) {
    if (theme === openlogin_utils_namespaceObject.THEME_MODES.light) return "light";
    if (theme === openlogin_utils_namespaceObject.THEME_MODES.dark) return "dark";
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  async setupWeb3(providerParams) {
    loglevel.info("setupWeb3 running");
    // setup background connection
    const providerStream = new openlogin_jrpc_namespaceObject.BasePostMessageStream({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });

    // We create another LocalMessageDuplexStream for communication between dapp <> iframe
    const communicationStream = new openlogin_jrpc_namespaceObject.BasePostMessageStream({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });

    // compose the inPage provider
    const inPageProvider = new src_inPageProvider(providerStream, {});
    const communicationProvider = new src_communicationProvider(communicationStream, {}, {
      buttonPosition: this.buttonPosition
    });
    inPageProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      if (confirmationStrategyFinal === base_controllers_namespaceObject.CONFIRMATION_STRATEGY.POPUP) {
        const windowId = (0,base_controllers_namespaceObject.randomId)();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: (0,base_controllers_namespaceObject.getPopupFeatures)(base_controllers_namespaceObject.FEATURES_CONFIRM_WINDOW),
          timeout: 500
        });
        // for inPageProvider methods sending windowId in request instead of params
        // as params might be positional.
        _payload.windowId = windowId;
      }
      inPageProvider.rpcEngine.handle(_payload, cb);
    };
    communicationProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      if (confirmationStrategyFinal === base_controllers_namespaceObject.CONFIRMATION_STRATEGY.POPUP) {
        const windowId = (0,base_controllers_namespaceObject.randomId)();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: (0,base_controllers_namespaceObject.getPopupFeatures)(base_controllers_namespaceObject.FEATURES_PROVIDER_CHANGE_WINDOW),
          // todo: are these features generic for all
          timeout: 500
        });
        // for communication methods sending window id in jrpc req params
        _payload.params.windowId = windowId;
      }
      communicationProvider.rpcEngine.handle(_payload, cb);
    };

    // detect eth_requestAccounts and pipe to enable for now
    const detectAccountRequestPrototypeModifier = m => {
      const originalMethod = inPageProvider[m];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const self = this;

      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      inPageProvider[m] = function providerFunc(request, cb) {
        const {
          method,
          params = []
        } = request;
        if (method === "eth_requestAccounts") {
          if (!cb) return self.login({
            loginProvider: params[0]
          });
          self.login({
            loginProvider: params[0]
          })
          // eslint-disable-next-line promise/no-callback-in-promise
          .then(res => cb(null, res))
          // eslint-disable-next-line promise/no-callback-in-promise
          .catch(err => cb(err));
        }
        return originalMethod.apply(this, [request, cb]);
      };
    };

    // Detects call to eth_requestAccounts in request & sendAsync and passes to login
    detectAccountRequestPrototypeModifier("request");
    detectAccountRequestPrototypeModifier("sendAsync");
    detectAccountRequestPrototypeModifier("send");
    const proxiedInPageProvider = new Proxy(inPageProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    const proxiedCommunicationProvider = new Proxy(communicationProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    this.provider = proxiedInPageProvider;
    this.communicationProvider = proxiedCommunicationProvider;
    loglevel.info("test setupWeb3 ");
    await Promise.all([inPageProvider.initializeState(), communicationProvider.initializeState(objectSpread2_default()(objectSpread2_default()({}, providerParams), {}, {
      torusIframeId: providerParams.walletIframe.id
    }))]);
    loglevel.debug("WsEmbed - injected provider");
  }
}
/* harmony default export */ const src_embed = (WsEmbed);
;// CONCATENATED MODULE: ./src/index.ts



module.exports = __webpack_exports__;
/******/ })()
;