import {
  bowser_default,
  decryptData,
  encryptData,
  keccak256,
  lookup
} from "./chunk-66NAV3HW.js";
import {
  generatePrivate,
  getPublic,
  sign
} from "./chunk-2I7FAV7Q.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  BaseAdapter,
  CHAIN_NAMESPACES,
  CustomError,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  Web3AuthError,
  get,
  loglevel,
  patch,
  post,
  put,
  require_color,
  require_lodash,
  require_loglevel,
  setLogLevel
} from "./chunk-K4C2RABW.js";
import {
  require_events
} from "./chunk-GJBZJ4UL.js";
import {
  SESSION_SERVER,
  TORUS_LEGACY_NETWORK,
  TORUS_SAPPHIRE_NETWORK,
  _defineProperty,
  _objectSpread2,
  require_base64url
} from "./chunk-MBKDGBSM.js";
import {
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/@web3auth/openlogin-adapter/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_base64url = __toESM(require_base64url());
var import_color = __toESM(require_color());
var base64url = import_base64url.default;
function safebtoa(str) {
  return base64url.encode(str);
}
function safeatob(str) {
  return base64url.decode(str);
}
function base64toJSON(b64str) {
  return JSON.parse(base64url.decode(b64str));
}
function jsonToBase64(json) {
  return base64url.encode(JSON.stringify(json));
}
function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (err) {
    const error = err;
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededError" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
var MemoryStore = class {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(key) {
    return this.store.get(key) || null;
  }
  setItem(key, value) {
    this.store.set(key, value);
  }
  removeItem(key) {
    this.store.delete(key);
  }
};
var BrowserStorage = class {
  constructor(storeKey2, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey2;
    try {
      if (!storage.getItem(storeKey2)) {
        this.resetStore();
      }
    } catch (error) {
    }
  }
  static getInstance(key) {
    let storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(key)) {
      let storage;
      if (storageKey === "local" && storageAvailable("localStorage")) {
        storage = window.localStorage;
      } else if (storageKey === "session" && storageAvailable("sessionStorage")) {
        storage = window.sessionStorage;
      } else {
        storage = new MemoryStore();
      }
      this.instanceMap.set(key, new this(key, storage));
    }
    return this.instanceMap.get(key);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const currStore = this.getStore();
    this.storage.removeItem(this._storeKey);
    return currStore;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(key) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  set(key, value) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
var storeKey = "openlogin_store";
var UX_MODE = {
  POPUP: "popup",
  REDIRECT: "redirect"
};
var OPENLOGIN_NETWORK = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);
var SUPPORTED_KEY_CURVES = {
  SECP256K1: "secp256k1",
  ED25519: "ed25519"
};
var LOGIN_PROVIDER = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  FARCASTER: "farcaster",
  EMAIL_PASSWORDLESS: "email_passwordless",
  SMS_PASSWORDLESS: "sms_passwordless",
  WEBAUTHN: "webauthn",
  JWT: "jwt"
};
var MFA_LEVELS = {
  DEFAULT: "default",
  OPTIONAL: "optional",
  MANDATORY: "mandatory",
  NONE: "none"
};
var OPENLOGIN_ACTIONS = {
  LOGIN: "login",
  ENABLE_MFA: "enable_mfa",
  MANAGE_MFA: "manage_mfa",
  MODIFY_SOCIAL_FACTOR: "modify_social_factor"
};
var BUILD_ENV = {
  PRODUCTION: "production",
  DEVELOPMENT: "development",
  STAGING: "staging",
  TESTING: "testing"
};
var LANGUAGES = {
  en: "en",
  ja: "ja",
  ko: "ko",
  de: "de",
  zh: "zh",
  es: "es",
  fr: "fr",
  pt: "pt",
  nl: "nl",
  tr: "tr"
};
var LANGUAGE_MAP = {
  en: "english",
  ja: "japanese",
  ko: "korean",
  de: "german",
  zh: "mandarin",
  es: "spanish",
  fr: "french",
  pt: "portuguese",
  nl: "dutch",
  tr: "turkish"
};
var THEME_MODES = {
  light: "light",
  dark: "dark",
  auto: "auto"
};
var MFA_FACTOR = {
  DEVICE: "deviceShareFactor",
  BACKUP_SHARE: "backUpShareFactor",
  SOCIAL_BACKUP: "socialBackupFactor",
  PASSWORD: "passwordFactor",
  PASSKEYS: "passkeysFactor",
  AUTHENTICATOR: "authenticatorFactor"
};
function getColorsList() {
  let colorsAmount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
  let colorsShiftAmount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;
  let mixColor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "black";
  let rotate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  let saturation = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 20;
  let mainColor = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#0346ff";
  const colorsList = [];
  let step;
  for (step = 0; step < colorsAmount; step += 1) {
    colorsList.push((0, import_color.default)(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix((0, import_color.default)(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());
  }
  return colorsList;
}
function generateWhiteLabelTheme(primary) {
  const darkSet = getColorsList(3, 50, "black", 0, 20, primary);
  const lightSet = getColorsList(6, 85, "white", 0, 20, primary);
  return [...darkSet.reverse(), primary, ...lightSet];
}
function applyWhiteLabelTheme(rootElement, theme) {
  if (theme.primary) {
    const themeSet = generateWhiteLabelTheme(theme.primary);
    rootElement.style.setProperty("--app-primary-900", themeSet[0]);
    rootElement.style.setProperty("--app-primary-800", themeSet[1]);
    rootElement.style.setProperty("--app-primary-700", themeSet[2]);
    rootElement.style.setProperty("--app-primary-600", themeSet[3]);
    rootElement.style.setProperty("--app-primary-500", themeSet[4]);
    rootElement.style.setProperty("--app-primary-400", themeSet[5]);
    rootElement.style.setProperty("--app-primary-300", themeSet[6]);
    rootElement.style.setProperty("--app-primary-200", themeSet[7]);
    rootElement.style.setProperty("--app-primary-100", themeSet[8]);
    rootElement.style.setProperty("--app-primary-50", themeSet[9]);
  }
  if (theme.onPrimary) {
    rootElement.style.setProperty("--app-on-primary", theme.onPrimary);
  }
}

// node_modules/@toruslabs/openlogin/dist/openlogin.esm.js
var import_loglevel2 = __toESM(require_loglevel());

// node_modules/@toruslabs/base-session-manager/dist/baseSessionManager.esm.js
var BaseSessionManager = class {
  constructor() {
    _defineProperty(this, "sessionId", void 0);
  }
  checkSessionParams() {
    if (!this.sessionId) throw new Error("Session id is required");
    this.sessionId = this.sessionId.padStart(64, "0");
  }
  /**
   * Common handler method for making an http request.
   *
   * Note: Embed all the query parameters in the path itself.
   */
  request(_ref) {
    let {
      method = "GET",
      url,
      data = {},
      headers = {}
    } = _ref;
    const options = {
      headers
    };
    switch (method) {
      case "GET":
        return get(url, options);
      case "POST":
        return post(url, data, options);
      case "PUT":
        return put(url, data, options);
      case "PATCH":
        return patch(url, data, options);
    }
    throw new Error("Invalid method type");
  }
};

// node_modules/@toruslabs/openlogin-session-manager/dist/openloginSessionManager.esm.js
var DEFAULT_SESSION_TIMEOUT = 86400;
var OpenloginSessionManager = class extends BaseSessionManager {
  constructor() {
    let {
      sessionServerBaseUrl,
      sessionNamespace,
      sessionTime,
      sessionId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    _defineProperty(this, "sessionServerBaseUrl", "https://session.web3auth.io");
    _defineProperty(this, "sessionNamespace", void 0);
    _defineProperty(this, "sessionTime", DEFAULT_SESSION_TIMEOUT);
    _defineProperty(this, "sessionId", "");
    if (sessionServerBaseUrl) {
      this.sessionServerBaseUrl = sessionServerBaseUrl;
    }
    if (sessionNamespace) this.sessionNamespace = sessionNamespace;
    if (sessionTime) this.sessionTime = sessionTime;
    if (sessionId) this.sessionId = sessionId.padStart(64, "0");
  }
  static generateRandomSessionKey() {
    return generatePrivate().toString("hex").padStart(64, "0");
  }
  async createSession(data) {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = getPublic(privKey).toString("hex");
    const encData = await encryptData(this.sessionId, data);
    const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const body = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace,
      timeout: this.sessionTime
    };
    await super.request({
      method: "POST",
      url: `${this.sessionServerBaseUrl}/store/set`,
      data: body
    });
    return this.sessionId;
  }
  async authorizeSession() {
    super.checkSessionParams();
    const pubkey = getPublic(Buffer.from(this.sessionId, "hex")).toString("hex");
    const url = new URL(`${this.sessionServerBaseUrl}/store/get`);
    url.searchParams.append("key", pubkey);
    if (this.sessionNamespace) url.searchParams.append("namespace", this.sessionNamespace);
    const result = await super.request({
      url: url.toString()
    });
    if (!result.message) {
      throw new Error("Session Expired or Invalid public key");
    }
    const response = await decryptData(this.sessionId, result.message);
    if (response.error) {
      throw new Error("There was an error decrypting data.");
    }
    return response;
  }
  async updateSession(data) {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = getPublic(privKey).toString("hex");
    const encData = await encryptData(this.sessionId, data);
    const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const body = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace
    };
    await super.request({
      method: "PUT",
      url: `${this.sessionServerBaseUrl}/store/update`,
      data: body
    });
  }
  async invalidateSession() {
    super.checkSessionParams();
    const privKey = Buffer.from(this.sessionId, "hex");
    const pubKey = getPublic(privKey).toString("hex");
    const encData = await encryptData(this.sessionId, {});
    const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
    const data = {
      key: pubKey,
      data: encData,
      signature,
      namespace: this.sessionNamespace,
      timeout: 1
    };
    await super.request({
      method: "POST",
      url: `${this.sessionServerBaseUrl}/store/set`,
      data
    });
    this.sessionId = "";
    return true;
  }
};

// node_modules/@toruslabs/openlogin/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_base64url2 = __toESM(require_base64url());
var import_color2 = __toESM(require_color());
var base64url2 = import_base64url2.default;
function safeatob2(str) {
  return base64url2.decode(str);
}
function jsonToBase642(json) {
  return base64url2.encode(JSON.stringify(json));
}
function storageAvailable2(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (err) {
    const error = err;
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededError" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
var MemoryStore2 = class {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(key) {
    return this.store.get(key) || null;
  }
  setItem(key, value) {
    this.store.set(key, value);
  }
  removeItem(key) {
    this.store.delete(key);
  }
};
var BrowserStorage2 = class {
  constructor(storeKey2, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey2;
    try {
      if (!storage.getItem(storeKey2)) {
        this.resetStore();
      }
    } catch (error) {
    }
  }
  static getInstance(key) {
    let storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(key)) {
      let storage;
      if (storageKey === "local" && storageAvailable2("localStorage")) {
        storage = window.localStorage;
      } else if (storageKey === "session" && storageAvailable2("sessionStorage")) {
        storage = window.sessionStorage;
      } else {
        storage = new MemoryStore2();
      }
      this.instanceMap.set(key, new this(key, storage));
    }
    return this.instanceMap.get(key);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const currStore = this.getStore();
    this.storage.removeItem(this._storeKey);
    return currStore;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(key) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  set(key, value) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};
_defineProperty(BrowserStorage2, "instanceMap", /* @__PURE__ */ new Map());
var UX_MODE2 = {
  POPUP: "popup",
  REDIRECT: "redirect"
};
var OPENLOGIN_NETWORK2 = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);
var LOGIN_PROVIDER2 = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  FARCASTER: "farcaster",
  EMAIL_PASSWORDLESS: "email_passwordless",
  SMS_PASSWORDLESS: "sms_passwordless",
  WEBAUTHN: "webauthn",
  JWT: "jwt"
};
var OPENLOGIN_ACTIONS2 = {
  LOGIN: "login",
  ENABLE_MFA: "enable_mfa",
  MANAGE_MFA: "manage_mfa",
  MODIFY_SOCIAL_FACTOR: "modify_social_factor"
};
var BUILD_ENV2 = {
  PRODUCTION: "production",
  DEVELOPMENT: "development",
  STAGING: "staging",
  TESTING: "testing"
};

// node_modules/@toruslabs/secure-pub-sub/dist/securePubSub.esm.js
var import_loglevel = __toESM(require_loglevel());
var log = import_loglevel.default.getLogger("SecurePubSub");
var SecurePubSub = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "SOCKET_CONN", null);
    this.options = options;
    this.options.timeout = options.timeout || 600;
    this.options.serverUrl = options.serverUrl || "https://session.web3auth.io";
    this.options.enableLogging = options.enableLogging || false;
    this.options.namespace = options.namespace || "";
    this.options.sameIpCheck = options.sameIpCheck || false;
    this.options.sameOriginCheck = options.sameOriginCheck || false;
    if (this.options.enableLogging) log.enableAll();
    else log.disableAll();
  }
  static setLogLevel(level) {
    log.setLevel(level);
    setLogLevel(level);
  }
  async publish(topic, message) {
    const topicPrivKey = keccak256(Buffer.from(topic, "utf8"));
    const encryptedData = await encryptData(topicPrivKey.toString("hex"), message);
    const signature = await sign(topicPrivKey, keccak256(Buffer.from(encryptedData, "utf8")));
    const fetchBody = {
      key: getPublic(topicPrivKey).toString("hex"),
      // already padded
      data: encryptedData,
      signature: signature.toString("hex"),
      timeout: this.options.timeout,
      namespace: this.options.namespace,
      sameIpCheck: this.options.sameIpCheck,
      sameOriginCheck: this.options.sameOriginCheck
    };
    return post(`${this.options.serverUrl}/channel/set`, fetchBody);
  }
  async subscribe(topic) {
    let isPromisePending = true;
    const topicPrivKey = keccak256(Buffer.from(topic, "utf8"));
    const topicPubKey = getPublic(topicPrivKey).toString("hex");
    const currentSocketConnection = this.getSocketConnection();
    if (currentSocketConnection.connected) {
      log.debug("already connected with socket");
      currentSocketConnection.emit("check_auth_status", topicPubKey, {
        namespace: this.options.namespace,
        sameIpCheck: this.options.sameIpCheck,
        sameOriginCheck: this.options.sameOriginCheck
      });
    } else {
      currentSocketConnection.once("connect", () => {
        log.debug("connected with socket");
        currentSocketConnection.emit("check_auth_status", topicPubKey, {
          namespace: this.options.namespace,
          sameIpCheck: this.options.sameIpCheck,
          sameOriginCheck: this.options.sameOriginCheck
        });
      });
    }
    const reconnect = () => {
      currentSocketConnection.once("connect", async () => {
        log.debug("connected with socket using reconnect");
        if (isPromisePending) currentSocketConnection.emit("check_auth_status", topicPubKey, {
          namespace: this.options.namespace,
          sameIpCheck: this.options.sameIpCheck,
          sameOriginCheck: this.options.sameOriginCheck
        });
      });
    };
    const visibilityListener = () => {
      if (!isPromisePending) document.removeEventListener("visibilitychange", visibilityListener);
      if (!currentSocketConnection.connected && document.visibilityState === "visible") {
        reconnect();
      }
    };
    const disconnectListener = () => {
      log.debug("socket disconnected", isPromisePending);
      if (isPromisePending) {
        log.error("socket disconnected unexpectedly, reconnecting socket");
        reconnect();
      } else {
        currentSocketConnection.removeListener("disconnect", disconnectListener);
      }
    };
    currentSocketConnection.on("disconnect", disconnectListener);
    const returnPromise = new Promise((resolve, reject) => {
      const listener = async (ev) => {
        try {
          const decData = await decryptData(topicPrivKey.toString("hex"), ev);
          log.info("got data", decData);
          resolve(decData);
        } catch (error) {
          log.error(error);
          reject(error);
        } finally {
          isPromisePending = false;
          document.removeEventListener("visibilitychange", visibilityListener);
        }
      };
      log.info("listening to", `${topicPubKey}_success`);
      currentSocketConnection.once(`${topicPubKey}_success`, listener);
    });
    if (typeof document !== "undefined") document.addEventListener("visibilitychange", visibilityListener);
    return returnPromise;
  }
  cleanup() {
    if (this.SOCKET_CONN) {
      this.SOCKET_CONN.disconnect();
      this.SOCKET_CONN = null;
    }
  }
  getSocketConnection() {
    if (this.SOCKET_CONN) return this.SOCKET_CONN;
    const localSocketConnection = lookup(this.options.serverUrl, {
      transports: ["websocket", "polling"],
      // use WebSocket first, if available
      withCredentials: true,
      reconnectionDelayMax: 1e4,
      reconnectionAttempts: 10
    });
    localSocketConnection.on("connect_error", (err) => {
      localSocketConnection.io.opts.transports = ["polling", "websocket"];
      log.error("connect error", err);
    });
    localSocketConnection.on("connect", async () => {
      const {
        engine
      } = localSocketConnection.io;
      log.debug("initially connected to", engine.transport.name);
      engine.once("upgrade", () => {
        log.debug("upgraded", engine.transport.name);
      });
      engine.once("close", (reason) => {
        log.debug("connection closed", reason);
      });
    });
    localSocketConnection.on("error", (err) => {
      log.error("socket errored", err);
      localSocketConnection.disconnect();
    });
    this.SOCKET_CONN = localSocketConnection;
    return this.SOCKET_CONN;
  }
};

// node_modules/@toruslabs/openlogin/dist/openlogin.esm.js
var import_events = __toESM(require_events());
var OpenloginError = class extends CustomError {
  constructor(code, message) {
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    Object.defineProperty(this, "name", {
      value: "OpenloginError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};
var InitializationError = class _InitializationError extends OpenloginError {
  constructor(code, message) {
    super(code, message);
    Object.defineProperty(this, "name", {
      value: "InitializationError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return new _InitializationError(code, `${_InitializationError.messages[code]}, ${extraMessage}`);
  }
  static invalidParams() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _InitializationError.fromCode(5001, extraMessage);
  }
  static notInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _InitializationError.fromCode(5002, extraMessage);
  }
};
_defineProperty(InitializationError, "messages", {
  5e3: "Custom",
  5001: "Invalid constructor params",
  5002: "SDK not initialized. please call init first"
});
var LoginError = class _LoginError extends OpenloginError {
  constructor(code, message) {
    super(code, message);
    Object.defineProperty(this, "name", {
      value: "LoginError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return new _LoginError(code, `${_LoginError.messages[code]}, ${extraMessage}`);
  }
  static invalidLoginParams() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5111, extraMessage);
  }
  static userNotLoggedIn() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5112, extraMessage);
  }
  static popupClosed() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5113, extraMessage);
  }
  static loginFailed() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5114, extraMessage);
  }
  static popupBlocked() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5115, extraMessage);
  }
  static mfaAlreadyEnabled() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5116, extraMessage);
  }
  static mfaNotEnabled() {
    let extraMessage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _LoginError.fromCode(5117, extraMessage);
  }
};
_defineProperty(LoginError, "messages", {
  5e3: "Custom",
  5111: "Invalid login params",
  5112: "User not logged in.",
  5113: "login popup has been closed by the user",
  5114: "Login failed",
  5115: "Popup was blocked. Please call this function as soon as user clicks button or use redirect mode",
  5116: "MFA already enabled",
  5117: "MFA not yet enabled. Please call `enableMFA` first"
});
var loglevel2 = (0, import_loglevel2.getLogger)("openlogin");
loglevel2.setLevel("error");
var version = "8.2.1";
function getHashQueryParams() {
  let replaceUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  const result = {};
  const queryUrlParams = new URLSearchParams(window.location.search.slice(1));
  queryUrlParams.forEach((value, key) => {
    if (key !== "b64Params") {
      result[key] = value;
    }
  });
  const queryResult = queryUrlParams.get("b64Params");
  if (queryResult) {
    try {
      const queryParams = JSON.parse(safeatob2(queryResult));
      Object.keys(queryParams).forEach((key) => {
        result[key] = queryParams[key];
      });
    } catch (error) {
      loglevel2.error(error);
    }
  }
  const hashUrlParams = new URLSearchParams(window.location.hash.substring(1));
  hashUrlParams.forEach((value, key) => {
    if (key !== "b64Params") {
      result[key] = value;
    }
  });
  const hashResult = hashUrlParams.get("b64Params");
  if (hashResult) {
    try {
      const hashParams = JSON.parse(safeatob2(hashResult));
      Object.keys(hashParams).forEach((key) => {
        result[key] = hashParams[key];
      });
    } catch (error) {
      loglevel2.error(error);
    }
  }
  if (replaceUrl) {
    const cleanUrl = new URL(window.location.origin + window.location.pathname);
    if (queryUrlParams.size > 0) {
      queryUrlParams.delete("error");
      queryUrlParams.delete("state");
      queryUrlParams.delete("b64Params");
      queryUrlParams.delete("sessionNamespace");
      cleanUrl.search = queryUrlParams.toString();
    }
    if (hashUrlParams.size > 0) {
      hashUrlParams.delete("error");
      hashUrlParams.delete("state");
      hashUrlParams.delete("b64Params");
      hashUrlParams.delete("sessionNamespace");
      cleanUrl.hash = hashUrlParams.toString();
    }
    window.history.replaceState(_objectSpread2(_objectSpread2({}, window.history.state), {}, {
      as: cleanUrl.href,
      url: cleanUrl.href
    }), "", cleanUrl.href);
  }
  return result;
}
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach((key) => {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }
  return url.toString();
}
function getPopupFeatures() {
  if (typeof window === "undefined") return "";
  const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1;
  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
function isMobileOrTablet() {
  if (typeof window === "undefined") return false;
  const browser = bowser_default.getParser(window.navigator.userAgent);
  const platform = browser.getPlatform();
  return platform.type === bowser_default.PLATFORMS_MAP.tablet || platform.type === bowser_default.PLATFORMS_MAP.mobile;
}
function getTimeout(loginProvider) {
  if ((loginProvider === LOGIN_PROVIDER2.FACEBOOK || loginProvider === LOGIN_PROVIDER2.LINE) && isMobileOrTablet()) {
    return 1e3 * 60 * 5;
  }
  return 1e3 * 10;
}
var PopupHandler = class extends import_events.EventEmitter {
  constructor(_ref) {
    let {
      url,
      target,
      features,
      timeout = 3e4
    } = _ref;
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures();
    this.window = void 0;
    this.windowTimer = void 0;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = void 0;
        }, this.timeout);
      }
      if (this.window === void 0) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url, this.target, this.features);
    if (!this.window) throw LoginError.popupBlocked();
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url);
    } else {
      window.location.href = this.url;
    }
  }
  async listenOnChannel(loginId) {
    const securePubSub = new SecurePubSub();
    const data = await securePubSub.subscribe(loginId);
    this.close();
    securePubSub.cleanup();
    const parsedData = JSON.parse(data);
    if (parsedData.error) {
      return {
        error: parsedData.error,
        state: parsedData.state
      };
    }
    return parsedData.data;
  }
};
var OpenLogin = class {
  constructor(options) {
    _defineProperty(this, "state", {});
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "sessionManager", void 0);
    _defineProperty(this, "currentStorage", void 0);
    _defineProperty(this, "_storageBaseKey", "openlogin_store");
    _defineProperty(this, "dappState", void 0);
    _defineProperty(this, "addVersionInUrls", true);
    if (!options.clientId) throw InitializationError.invalidParams("clientId is required");
    if (!options.network) options.network = OPENLOGIN_NETWORK2.SAPPHIRE_MAINNET;
    if (!options.buildEnv) options.buildEnv = BUILD_ENV2.PRODUCTION;
    if (options.buildEnv === BUILD_ENV2.DEVELOPMENT || options.buildEnv === BUILD_ENV2.TESTING || options.sdkUrl) this.addVersionInUrls = false;
    if (!options.sdkUrl && !options.useMpc) {
      if (options.buildEnv === BUILD_ENV2.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
        options.dashboardUrl = "http://localhost:5173/wallet/account";
      } else if (options.buildEnv === BUILD_ENV2.STAGING) {
        options.sdkUrl = "https://staging-auth.web3auth.io";
        options.dashboardUrl = "https://staging-account.web3auth.io/wallet/account";
      } else if (options.buildEnv === BUILD_ENV2.TESTING) {
        options.sdkUrl = "https://develop-auth.web3auth.io";
        options.dashboardUrl = "https://develop-account.web3auth.io/wallet/account";
      } else {
        options.sdkUrl = "https://auth.web3auth.io";
        options.dashboardUrl = "https://account.web3auth.io/wallet/account";
      }
    }
    if (options.useMpc && !options.sdkUrl) {
      if (Object.values(TORUS_LEGACY_NETWORK).includes(options.network)) throw InitializationError.invalidParams("MPC is not supported on legacy networks, please use sapphire_devnet or sapphire_mainnet.");
      if (options.buildEnv === BUILD_ENV2.DEVELOPMENT) {
        options.sdkUrl = "http://localhost:3000";
      } else if (options.buildEnv === BUILD_ENV2.STAGING) {
        options.sdkUrl = "https://staging-mpc-auth.web3auth.io";
      } else if (options.buildEnv === BUILD_ENV2.TESTING) {
        options.sdkUrl = "https://develop-mpc-auth.web3auth.io";
      } else {
        options.sdkUrl = "https://mpc-auth.web3auth.io";
      }
    }
    if (!options.redirectUrl && typeof window !== "undefined") {
      options.redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
    }
    if (!options.uxMode) options.uxMode = UX_MODE2.REDIRECT;
    if (typeof options.replaceUrlOnRedirect !== "boolean") options.replaceUrlOnRedirect = true;
    if (!options.originData) options.originData = {};
    if (!options.whiteLabel) options.whiteLabel = {};
    if (!options.loginConfig) options.loginConfig = {};
    if (!options.mfaSettings) options.mfaSettings = {};
    if (!options.storageServerUrl) options.storageServerUrl = SESSION_SERVER;
    if (!options.storageKey) options.storageKey = "local";
    if (!options.webauthnTransports) options.webauthnTransports = ["internal"];
    if (!options.sessionTime) options.sessionTime = 86400;
    this.options = options;
  }
  get privKey() {
    if (this.options.useMpc) return this.state.factorKey || "";
    return this.state.privKey ? this.state.privKey.padStart(64, "0") : "";
  }
  get coreKitKey() {
    return this.state.coreKitKey ? this.state.coreKitKey.padStart(64, "0") : "";
  }
  get ed25519PrivKey() {
    return this.state.ed25519PrivKey ? this.state.ed25519PrivKey.padStart(128, "0") : "";
  }
  get coreKitEd25519Key() {
    return this.state.coreKitEd25519PrivKey ? this.state.coreKitEd25519PrivKey.padStart(128, "0") : "";
  }
  get sessionId() {
    return this.state.sessionId || "";
  }
  get sessionNamespace() {
    return this.options.sessionNamespace || "";
  }
  get appState() {
    return this.state.userInfo.appState || this.dappState || "";
  }
  get baseUrl() {
    if (!this.addVersionInUrls) return `${this.options.sdkUrl}`;
    return `${this.options.sdkUrl}/v${version.split(".")[0]}`;
  }
  async init() {
    const params = getHashQueryParams(this.options.replaceUrlOnRedirect);
    if (params.sessionNamespace) this.options.sessionNamespace = params.sessionNamespace;
    const storageKey = this.options.sessionNamespace ? `${this._storageBaseKey}_${this.options.sessionNamespace}` : this._storageBaseKey;
    this.currentStorage = BrowserStorage2.getInstance(storageKey, this.options.storageKey);
    const sessionId = this.currentStorage.get("sessionId");
    this.sessionManager = new OpenloginSessionManager({
      sessionServerBaseUrl: this.options.storageServerUrl,
      sessionNamespace: this.options.sessionNamespace,
      sessionTime: this.options.sessionTime,
      sessionId
    });
    if (this.options.network === OPENLOGIN_NETWORK2.TESTNET || this.options.network === OPENLOGIN_NETWORK2.SAPPHIRE_DEVNET) {
      console.log(`%c WARNING! You are on ${this.options.network}. Please set network: 'mainnet' or 'sapphire_mainnet' in production`, "color: #FF0000");
    }
    if (this.options.buildEnv !== BUILD_ENV2.PRODUCTION) {
      console.log(`%c WARNING! You are using build env ${this.options.buildEnv}. Please set buildEnv: 'production' in production`, "color: #FF0000");
    }
    if (params.error) {
      this.dappState = params.state;
      throw LoginError.loginFailed(params.error);
    }
    if (params.sessionId) {
      this.currentStorage.set("sessionId", params.sessionId);
      this.sessionManager.sessionId = params.sessionId;
    }
    if (this.sessionManager.sessionId) {
      const data = await this._authorizeSession();
      this.updateState(data);
      if (Object.keys(data).length === 0) {
        this.currentStorage.set("sessionId", "");
      }
    }
  }
  async login(params) {
    if (!params.loginProvider) throw LoginError.invalidLoginParams(`loginProvider is required`);
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const loginParams = _objectSpread2(_objectSpread2({
      loginProvider: params.loginProvider
    }, defaultParams), params);
    const dataObject = {
      actionType: OPENLOGIN_ACTIONS2.LOGIN,
      options: this.options,
      params: loginParams
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(params.loginProvider));
    if (this.options.uxMode === UX_MODE2.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return {
      privKey: this.privKey
    };
  }
  async logout() {
    if (!this.sessionManager.sessionId) throw LoginError.userNotLoggedIn();
    await this.sessionManager.invalidateSession();
    this.updateState({
      privKey: "",
      coreKitKey: "",
      coreKitEd25519PrivKey: "",
      ed25519PrivKey: "",
      walletKey: "",
      oAuthPrivateKey: "",
      tKey: "",
      metadataNonce: "",
      keyMode: void 0,
      userInfo: {
        name: "",
        profileImage: "",
        dappShare: "",
        idToken: "",
        oAuthIdToken: "",
        oAuthAccessToken: "",
        appState: "",
        email: "",
        verifier: "",
        verifierId: "",
        aggregateVerifier: "",
        typeOfLogin: "",
        isMfaEnabled: false
      },
      authToken: "",
      sessionId: "",
      factorKey: "",
      signatures: [],
      tssShareIndex: -1,
      tssPubKey: "",
      tssShare: "",
      tssNonce: -1
    });
    this.currentStorage.set("sessionId", "");
  }
  async enableMFA(params) {
    var _this$state$userInfo;
    if (!this.sessionId) throw LoginError.userNotLoggedIn();
    if (this.state.userInfo.isMfaEnabled) throw LoginError.mfaAlreadyEnabled();
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: OPENLOGIN_ACTIONS2.ENABLE_MFA,
      options: this.options,
      params: _objectSpread2(_objectSpread2(_objectSpread2({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        mfaLevel: "mandatory"
      }),
      sessionId: this.sessionId
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(dataObject.params.loginProvider));
    if (this.options.uxMode === UX_MODE2.REDIRECT) return null;
    if (result.error) {
      this.dappState = result.state;
      throw LoginError.loginFailed(result.error);
    }
    this.sessionManager.sessionId = result.sessionId;
    this.options.sessionNamespace = result.sessionNamespace;
    this.currentStorage.set("sessionId", result.sessionId);
    await this.rehydrateSession();
    return Boolean((_this$state$userInfo = this.state.userInfo) === null || _this$state$userInfo === void 0 ? void 0 : _this$state$userInfo.isMfaEnabled);
  }
  async manageMFA(params) {
    if (!this.sessionId) throw LoginError.userNotLoggedIn();
    if (!this.state.userInfo.isMfaEnabled) throw LoginError.mfaNotEnabled();
    const defaultParams = {
      redirectUrl: this.options.dashboardUrl,
      dappUrl: `${window.location.origin}${window.location.pathname}`
    };
    const loginId = OpenloginSessionManager.generateRandomSessionKey();
    const dataObject = {
      actionType: OPENLOGIN_ACTIONS2.MANAGE_MFA,
      options: this.options,
      params: _objectSpread2(_objectSpread2(_objectSpread2({}, defaultParams), params), {}, {
        loginProvider: this.state.userInfo.typeOfLogin,
        extraLoginOptions: {
          login_hint: this.state.userInfo.verifierId
        },
        appState: jsonToBase642({
          loginId
        })
      }),
      sessionId: this.sessionId
    };
    this.createLoginSession(loginId, dataObject, dataObject.options.sessionTime, true);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    const loginUrl = constructURL({
      baseURL: `${this.baseUrl}/start`,
      hash: {
        b64Params: jsonToBase642(configParams)
      }
    });
    window.open(loginUrl, "_blank");
  }
  async changeSocialFactor(params) {
    if (!this.sessionId) throw LoginError.userNotLoggedIn();
    const defaultParams = {
      redirectUrl: this.options.redirectUrl
    };
    const dataObject = {
      actionType: OPENLOGIN_ACTIONS2.MODIFY_SOCIAL_FACTOR,
      options: this.options,
      params: _objectSpread2(_objectSpread2({}, defaultParams), params),
      sessionId: this.sessionId
    };
    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject);
    if (this.options.uxMode === UX_MODE2.REDIRECT) return void 0;
    if (result.error) return false;
    return true;
  }
  getUserInfo() {
    if (!this.sessionManager.sessionId) {
      throw LoginError.userNotLoggedIn();
    }
    return this.state.userInfo;
  }
  async createLoginSession(loginId, data) {
    let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600;
    let skipAwait = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (!this.sessionManager) throw InitializationError.notInitialized();
    const loginSessionMgr = new OpenloginSessionManager({
      sessionServerBaseUrl: data.options.storageServerUrl,
      sessionNamespace: data.options.sessionNamespace,
      sessionTime: timeout,
      // each login key must be used with 10 mins (might be used at the end of popup redirect)
      sessionId: loginId
    });
    const promise = loginSessionMgr.createSession(JSON.parse(JSON.stringify(data)));
    if (data.options.uxMode === UX_MODE2.REDIRECT && !skipAwait) {
      await promise;
    }
  }
  async _authorizeSession() {
    try {
      if (!this.sessionManager.sessionId) return {};
      const result = await this.sessionManager.authorizeSession();
      return result;
    } catch (err) {
      loglevel2.error("authorization failed", err);
      return {};
    }
  }
  updateState(data) {
    this.state = _objectSpread2(_objectSpread2({}, this.state), data);
  }
  async rehydrateSession() {
    const result = await this._authorizeSession();
    this.updateState(result);
  }
  async openloginHandler(url, dataObject) {
    let popupTimeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3 * 10;
    const loginId = OpenloginSessionManager.generateRandomSessionKey();
    await this.createLoginSession(loginId, dataObject);
    const configParams = {
      loginId,
      sessionNamespace: this.options.sessionNamespace,
      storageServerUrl: this.options.storageServerUrl
    };
    if (this.options.uxMode === UX_MODE2.REDIRECT) {
      const loginUrl2 = constructURL({
        baseURL: url,
        hash: {
          b64Params: jsonToBase642(configParams)
        }
      });
      window.location.href = loginUrl2;
      return void 0;
    }
    const loginUrl = constructURL({
      baseURL: url,
      hash: {
        b64Params: jsonToBase642(configParams)
      }
    });
    const currentWindow = new PopupHandler({
      url: loginUrl,
      timeout: popupTimeout
    });
    return new Promise((resolve, reject) => {
      currentWindow.on("close", () => {
        reject(LoginError.popupClosed());
      });
      currentWindow.listenOnChannel(loginId).then(resolve).catch(reject);
      try {
        currentWindow.open();
      } catch (error) {
        reject(error);
      }
    });
  }
};

// node_modules/@web3auth/openlogin-adapter/dist/openloginAdapter.esm.js
var import_lodash = __toESM(require_lodash());
var getOpenloginDefaultOptions = () => {
  return {
    adapterSettings: {
      network: OPENLOGIN_NETWORK.SAPPHIRE_MAINNET,
      clientId: "",
      uxMode: UX_MODE.POPUP
    },
    loginSettings: {},
    privateKeyProvider: void 0
  };
};
var OpenloginAdapter = class extends BaseAdapter {
  constructor(params = {}) {
    super(params);
    _defineProperty(this, "name", WALLET_ADAPTERS.OPENLOGIN);
    _defineProperty(this, "adapterNamespace", ADAPTER_NAMESPACES.MULTICHAIN);
    _defineProperty(this, "type", ADAPTER_CATEGORY.IN_APP);
    _defineProperty(this, "openloginInstance", null);
    _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
    _defineProperty(this, "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
    _defineProperty(this, "privateKeyProvider", null);
    _defineProperty(this, "openloginOptions", void 0);
    _defineProperty(this, "loginSettings", {
      loginProvider: ""
    });
    this.setAdapterSettings(_objectSpread2(_objectSpread2({}, params.adapterSettings), {}, {
      chainConfig: params.chainConfig,
      clientId: params.clientId || "",
      sessionTime: params.sessionTime,
      web3AuthNetwork: params.web3AuthNetwork,
      useCoreKitKey: params.useCoreKitKey,
      privateKeyProvider: params.privateKeyProvider
    }));
    this.loginSettings = params.loginSettings || {
      loginProvider: ""
    };
    this.privateKeyProvider = params.privateKeyProvider || null;
  }
  get chainConfigProxy() {
    return this.chainConfig ? _objectSpread2({}, this.chainConfig) : null;
  }
  get provider() {
    if (this.status !== ADAPTER_STATUS.NOT_READY && this.privateKeyProvider) {
      return this.privateKeyProvider;
    }
    return null;
  }
  set provider(_) {
    throw new Error("Not implemented");
  }
  async init(options) {
    super.checkInitializationRequirements();
    if (!this.clientId) throw WalletInitializationError.invalidParams("clientId is required before openlogin's initialization");
    if (!this.openloginOptions) throw WalletInitializationError.invalidParams("openloginOptions is required before openlogin's initialization");
    const isRedirectResult = this.openloginOptions.uxMode === UX_MODE.REDIRECT;
    this.openloginOptions = _objectSpread2(_objectSpread2({}, this.openloginOptions), {}, {
      replaceUrlOnRedirect: isRedirectResult,
      useCoreKitKey: this.useCoreKitKey
    });
    this.openloginInstance = new OpenLogin(_objectSpread2(_objectSpread2({}, this.openloginOptions), {}, {
      clientId: this.clientId,
      network: this.openloginOptions.network || this.web3AuthNetwork || OPENLOGIN_NETWORK.SAPPHIRE_MAINNET
    }));
    loglevel.debug("initializing openlogin adapter init");
    await this.openloginInstance.init();
    if (!this.chainConfig) throw WalletInitializationError.invalidParams("chainConfig is required before initialization");
    this.status = ADAPTER_STATUS.READY;
    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);
    try {
      loglevel.debug("initializing openlogin adapter");
      const finalPrivKey = this._getFinalPrivKey();
      if (finalPrivKey && (options.autoConnect || isRedirectResult)) {
        this.rehydrated = true;
        await this.connect();
      }
    } catch (error) {
      loglevel.error("Failed to connect with cached openlogin provider", error);
      this.emit("ERRORED", error);
    }
  }
  async connect(params = {
    loginProvider: ""
  }) {
    super.checkConnectionRequirements();
    this.status = ADAPTER_STATUS.CONNECTING;
    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread2(_objectSpread2({}, params), {}, {
      adapter: WALLET_ADAPTERS.OPENLOGIN
    }));
    try {
      await this.connectWithProvider(params);
      return this.provider;
    } catch (error) {
      loglevel.error("Failed to connect with openlogin provider", error);
      this.status = ADAPTER_STATUS.READY;
      this.emit(ADAPTER_EVENTS.ERRORED, error);
      if (error !== null && error !== void 0 && error.message.includes("user closed popup")) {
        throw WalletLoginError.popupClosed();
      } else if (error instanceof Web3AuthError) {
        throw error;
      }
      throw WalletLoginError.connectionError("Failed to login with openlogin", error);
    }
  }
  async enableMFA(params = {
    loginProvider: ""
  }) {
    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.openloginInstance) throw WalletInitializationError.notReady("openloginInstance is not ready");
    try {
      await this.openloginInstance.enableMFA(params);
    } catch (error) {
      loglevel.error("Failed to enable MFA with openlogin provider", error);
      if (error instanceof Web3AuthError) {
        throw error;
      }
      throw WalletLoginError.connectionError("Failed to enable MFA with openlogin", error);
    }
  }
  async disconnect(options = {
    cleanup: false
  }) {
    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.openloginInstance) throw WalletInitializationError.notReady("openloginInstance is not ready");
    await this.openloginInstance.logout();
    if (options.cleanup) {
      this.status = ADAPTER_STATUS.NOT_READY;
      this.openloginInstance = null;
      this.privateKeyProvider = null;
    } else {
      this.status = ADAPTER_STATUS.READY;
    }
    this.rehydrated = false;
    this.emit(ADAPTER_EVENTS.DISCONNECTED);
  }
  async authenticateUser() {
    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    const userInfo = await this.getUserInfo();
    return {
      idToken: userInfo.idToken
    };
  }
  async getUserInfo() {
    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.openloginInstance) throw WalletInitializationError.notReady("openloginInstance is not ready");
    const userInfo = this.openloginInstance.getUserInfo();
    return userInfo;
  }
  // should be called only before initialization.
  setAdapterSettings(adapterSettings) {
    super.setAdapterSettings(adapterSettings);
    const defaultOptions = getOpenloginDefaultOptions();
    loglevel.info("setting adapter settings", adapterSettings);
    this.openloginOptions = (0, import_lodash.default)(defaultOptions.adapterSettings, this.openloginOptions, adapterSettings);
    if (adapterSettings.web3AuthNetwork) {
      this.openloginOptions.network = adapterSettings.web3AuthNetwork;
    }
    if (adapterSettings.privateKeyProvider) {
      this.privateKeyProvider = adapterSettings.privateKeyProvider;
    }
  }
  async addChain(chainConfig, init = false) {
    var _this$privateKeyProvi;
    super.checkAddChainRequirements(chainConfig, init);
    (_this$privateKeyProvi = this.privateKeyProvider) === null || _this$privateKeyProvi === void 0 || _this$privateKeyProvi.addChain(chainConfig);
    this.addChainConfig(chainConfig);
  }
  async switchChain(params, init = false) {
    var _this$privateKeyProvi2;
    super.checkSwitchChainRequirements(params, init);
    await ((_this$privateKeyProvi2 = this.privateKeyProvider) === null || _this$privateKeyProvi2 === void 0 ? void 0 : _this$privateKeyProvi2.switchChain(params));
    this.setAdapterSettings({
      chainConfig: this.getChainConfig(params.chainId)
    });
  }
  _getFinalPrivKey() {
    if (!this.openloginInstance) return "";
    let finalPrivKey = this.openloginInstance.privKey;
    if (this.useCoreKitKey) {
      if (this.openloginInstance.privKey && !this.openloginInstance.coreKitKey) {
        throw WalletLoginError.coreKitKeyNotFound();
      }
      finalPrivKey = this.openloginInstance.coreKitKey;
    }
    return finalPrivKey;
  }
  _getFinalEd25519PrivKey() {
    if (!this.openloginInstance) return "";
    let finalPrivKey = this.openloginInstance.ed25519PrivKey;
    if (this.useCoreKitKey) {
      if (this.openloginInstance.ed25519PrivKey && !this.openloginInstance.coreKitEd25519Key) {
        throw WalletLoginError.coreKitKeyNotFound();
      }
      finalPrivKey = this.openloginInstance.coreKitEd25519Key;
    }
    return finalPrivKey;
  }
  async connectWithProvider(params = {
    loginProvider: ""
  }) {
    var _params$extraLoginOpt;
    if (!this.privateKeyProvider) throw WalletInitializationError.invalidParams("PrivateKey Provider is required before initialization");
    if (!this.openloginInstance) throw WalletInitializationError.notReady("openloginInstance is not ready");
    const keyAvailable = this._getFinalPrivKey();
    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {
      var _params$extraLoginOpt2;
      if (!this.loginSettings.curve) {
        this.loginSettings.curve = this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA ? SUPPORTED_KEY_CURVES.ED25519 : SUPPORTED_KEY_CURVES.SECP256K1;
      }
      if (!params.loginProvider && !this.loginSettings.loginProvider) throw WalletInitializationError.invalidParams("loginProvider is required for login");
      await this.openloginInstance.login((0, import_lodash.default)(this.loginSettings, params, {
        extraLoginOptions: _objectSpread2(_objectSpread2({}, params.extraLoginOptions || {}), {}, {
          login_hint: params.login_hint || ((_params$extraLoginOpt2 = params.extraLoginOptions) === null || _params$extraLoginOpt2 === void 0 ? void 0 : _params$extraLoginOpt2.login_hint)
        })
      }));
    }
    let finalPrivKey = this._getFinalPrivKey();
    if (finalPrivKey) {
      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {
        finalPrivKey = this._getFinalEd25519PrivKey();
      }
      await this.privateKeyProvider.setupProvider(finalPrivKey);
      this.status = ADAPTER_STATUS.CONNECTED;
      this.emit(ADAPTER_EVENTS.CONNECTED, {
        adapter: WALLET_ADAPTERS.OPENLOGIN,
        reconnected: this.rehydrated,
        provider: this.provider
      });
    }
  }
};

export {
  base64url,
  safebtoa,
  safeatob,
  base64toJSON,
  jsonToBase64,
  storageAvailable,
  MemoryStore,
  BrowserStorage,
  storeKey,
  UX_MODE,
  OPENLOGIN_NETWORK,
  SUPPORTED_KEY_CURVES,
  LOGIN_PROVIDER,
  MFA_LEVELS,
  OPENLOGIN_ACTIONS,
  BUILD_ENV,
  LANGUAGES,
  LANGUAGE_MAP,
  THEME_MODES,
  MFA_FACTOR,
  getColorsList,
  generateWhiteLabelTheme,
  applyWhiteLabelTheme,
  getOpenloginDefaultOptions,
  OpenloginAdapter
};
//# sourceMappingURL=chunk-HMWBIZAX.js.map
