{
  "version": 3,
  "sources": ["../../@web3auth/ethereum-provider/node_modules/@ethereumjs/rlp/src/index.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/types.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/util.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/baseTransaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/capabilities/eip1559.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/capabilities/legacy.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/capabilities/eip2718.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/capabilities/eip2930.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/eip1559Transaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/eip2930Transaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/constants.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/eip4844Transaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/capabilities/eip7702.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/eip7702Transaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/legacyTransaction.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/fromRpc.ts", "../../@web3auth/ethereum-provider/node_modules/@ethereumjs/tx/src/transactionFactory.ts"],
  "sourcesContent": ["export type Input = string | number | bigint | Uint8Array | Array<Input> | null | undefined\n\nexport type NestedUint8Array = Array<Uint8Array | NestedUint8Array>\n\nexport interface Decoded {\n  data: Uint8Array | NestedUint8Array\n  remainder: Uint8Array\n}\n\n/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/\nexport function encode(input: Input): Uint8Array {\n  if (Array.isArray(input)) {\n    const output: Uint8Array[] = []\n    let outputLength = 0\n    for (let i = 0; i < input.length; i++) {\n      const encoded = encode(input[i])\n      output.push(encoded)\n      outputLength += encoded.length\n    }\n    return concatBytes(encodeLength(outputLength, 192), ...output)\n  }\n  const inputBuf = toBytes(input)\n  if (inputBuf.length === 1 && inputBuf[0] < 128) {\n    return inputBuf\n  }\n  return concatBytes(encodeLength(inputBuf.length, 128), inputBuf)\n}\n\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */\nfunction safeSlice(input: Uint8Array, start: number, end: number) {\n  if (end > input.length) {\n    throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds')\n  }\n  return input.slice(start, end)\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */\nfunction decodeLength(v: Uint8Array): number {\n  if (v[0] === 0) {\n    throw new Error('invalid RLP: extra zeros')\n  }\n  return parseHexByte(bytesToHex(v))\n}\n\nfunction encodeLength(len: number, offset: number): Uint8Array {\n  if (len < 56) {\n    return Uint8Array.from([len + offset])\n  }\n  const hexLength = numberToHex(len)\n  const lLength = hexLength.length / 2\n  const firstByte = numberToHex(offset + 55 + lLength)\n  return Uint8Array.from(hexToBytes(firstByte + hexLength))\n}\n\n/**\n * RLP Decoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * @param input Will be converted to Uint8Array\n * @param stream Is the input a stream (false by default)\n * @returns decoded Array of Uint8Arrays containing the original message\n **/\nexport function decode(input: Input, stream?: false): Uint8Array | NestedUint8Array\nexport function decode(input: Input, stream?: true): Decoded\nexport function decode(input: Input, stream = false): Uint8Array | NestedUint8Array | Decoded {\n  if (typeof input === 'undefined' || input === null || (input as any).length === 0) {\n    return Uint8Array.from([])\n  }\n\n  const inputBytes = toBytes(input)\n  const decoded = _decode(inputBytes)\n\n  if (stream) {\n    return {\n      data: decoded.data,\n      remainder: decoded.remainder.slice(),\n    }\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error('invalid RLP: remainder must be zero')\n  }\n\n  return decoded.data\n}\n\n/** Decode an input with RLP */\nfunction _decode(input: Uint8Array): Decoded {\n  let length: number, llength: number, data: Uint8Array, innerRemainder: Uint8Array, d: Decoded\n  const decoded = []\n  const firstByte = input[0]\n\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.subarray(1),\n    }\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f\n\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = Uint8Array.from([])\n    } else {\n      data = safeSlice(input, 1, length)\n    }\n\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed')\n    }\n\n    return {\n      data,\n      remainder: input.subarray(length),\n    }\n  } else if (firstByte <= 0xbf) {\n    // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n    // followed by the length, followed by the string\n    llength = firstByte - 0xb6\n    if (input.length - 1 < llength) {\n      throw new Error('invalid RLP: not enough bytes for string length')\n    }\n    length = decodeLength(safeSlice(input, 1, llength))\n    if (length <= 55) {\n      throw new Error('invalid RLP: expected string length to be greater than 55')\n    }\n    data = safeSlice(input, llength, length + llength)\n\n    return {\n      data,\n      remainder: input.subarray(length + llength),\n    }\n  } else if (firstByte <= 0xf7) {\n    // a list between 0-55 bytes long\n    length = firstByte - 0xbf\n    innerRemainder = safeSlice(input, 1, length)\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n\n    return {\n      data: decoded,\n      remainder: input.subarray(length),\n    }\n  } else {\n    // a list over 55 bytes long\n    llength = firstByte - 0xf6\n    length = decodeLength(safeSlice(input, 1, llength))\n    if (length < 56) {\n      throw new Error('invalid RLP: encoded list too short')\n    }\n    const totalLength = llength + length\n    if (totalLength > input.length) {\n      throw new Error('invalid RLP: total length is larger than the data')\n    }\n\n    innerRemainder = safeSlice(input, llength, totalLength)\n\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n\n    return {\n      data: decoded,\n      remainder: input.subarray(totalLength),\n    }\n  }\n}\n\nconst cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'))\nfunction bytesToHex(uint8a: Uint8Array): string {\n  // Pre-caching chars with `cachedHexes` speeds this up 6x\n  let hex = ''\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += cachedHexes[uint8a[i]]\n  }\n  return hex\n}\n\nfunction parseHexByte(hexByte: string): number {\n  const byte = Number.parseInt(hexByte, 16)\n  if (Number.isNaN(byte)) throw new Error('Invalid byte sequence')\n  return byte\n}\n\n// Caching slows it down 2-3x\nfunction hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex)\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex')\n  const array = new Uint8Array(hex.length / 2)\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2\n    array[i] = parseHexByte(hex.slice(j, j + 2))\n  }\n  return array\n}\n\n/** Concatenates two Uint8Arrays into one. */\nfunction concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (arrays.length === 1) return arrays[0]\n  const length = arrays.reduce((a, arr) => a + arr.length, 0)\n  const result = new Uint8Array(length)\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i]\n    result.set(arr, pad)\n    pad += arr.length\n  }\n  return result\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any\ndeclare const TextDecoder: any\n\nfunction utf8ToBytes(utf: string): Uint8Array {\n  return new TextEncoder().encode(utf)\n}\n\n/** Transform an integer into its hexadecimal value */\nfunction numberToHex(integer: number | bigint): string {\n  if (integer < 0) {\n    throw new Error('Invalid integer as argument, must be unsigned!')\n  }\n  const hex = integer.toString(16)\n  return hex.length % 2 ? `0${hex}` : hex\n}\n\n/** Pad a string to be even */\nfunction padToEven(a: string): string {\n  return a.length % 2 ? `0${a}` : a\n}\n\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str: string): boolean {\n  return str.length >= 2 && str[0] === '0' && str[1] === 'x'\n}\n\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str: string): string {\n  if (typeof str !== 'string') {\n    return str\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str\n}\n\n/** Transform anything into a Uint8Array */\nfunction toBytes(v: Input): Uint8Array {\n  if (v instanceof Uint8Array) {\n    return v\n  }\n  if (typeof v === 'string') {\n    if (isHexPrefixed(v)) {\n      return hexToBytes(padToEven(stripHexPrefix(v)))\n    }\n    return utf8ToBytes(v)\n  }\n  if (typeof v === 'number' || typeof v === 'bigint') {\n    if (!v) {\n      return Uint8Array.from([])\n    }\n    return hexToBytes(numberToHex(v))\n  }\n  if (v === null || v === undefined) {\n    return Uint8Array.from([])\n  }\n  throw new Error('toBytes: received unsupported type ' + typeof v)\n}\n\nexport const utils = {\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  utf8ToBytes,\n}\n\nexport const RLP = { encode, decode }\n", "import { bytesToBigInt, toBytes } from '@ethereumjs/util'\n\nimport type { FeeMarketEIP1559Transaction } from './eip1559Transaction.js'\nimport type { AccessListEIP2930Transaction } from './eip2930Transaction.js'\nimport type { BlobEIP4844Transaction } from './eip4844Transaction.js'\nimport type { EOACodeEIP7702Transaction } from './eip7702Transaction.js'\nimport type { LegacyTransaction } from './legacyTransaction.js'\nimport type {\n  AccessList,\n  AccessListBytes,\n  AuthorizationList,\n  AuthorizationListBytes,\n  Common,\n  Hardfork,\n} from '@ethereumjs/common'\nimport type {\n  Address,\n  AddressLike,\n  BigIntLike,\n  BytesLike,\n  PrefixedHexString,\n} from '@ethereumjs/util'\nexport type {\n  AccessList,\n  AccessListBytes,\n  AccessListBytesItem,\n  AccessListItem,\n  AuthorizationList,\n  AuthorizationListBytes,\n  AuthorizationListBytesItem,\n  AuthorizationListItem,\n} from '@ethereumjs/common'\n\n/**\n * Can be used in conjunction with {@link Transaction[TransactionType].supports}\n * to query on tx capabilities\n */\nexport enum Capability {\n  /**\n   * Tx supports EIP-155 replay protection\n   * See: [155](https://eips.ethereum.org/EIPS/eip-155) Replay Attack Protection EIP\n   */\n  EIP155ReplayProtection = 155,\n\n  /**\n   * Tx supports EIP-1559 gas fee market mechanism\n   * See: [1559](https://eips.ethereum.org/EIPS/eip-1559) Fee Market EIP\n   */\n  EIP1559FeeMarket = 1559,\n\n  /**\n   * Tx is a typed transaction as defined in EIP-2718\n   * See: [2718](https://eips.ethereum.org/EIPS/eip-2718) Transaction Type EIP\n   */\n  EIP2718TypedTransaction = 2718,\n\n  /**\n   * Tx supports access list generation as defined in EIP-2930\n   * See: [2930](https://eips.ethereum.org/EIPS/eip-2930) Access Lists EIP\n   */\n  EIP2930AccessLists = 2930,\n\n  /**\n   * Tx supports setting EOA code\n   * See [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)\n   */\n  EIP7702EOACode = 7702,\n}\n\n/**\n * The options for initializing a {@link Transaction}.\n */\nexport interface TxOptions {\n  /**\n   * A {@link Common} object defining the chain and hardfork for the transaction.\n   *\n   * Object will be internally copied so that tx behavior don't incidentally\n   * change on future HF changes.\n   *\n   * Default: {@link Common} object set to `mainnet` and the default hardfork as defined in the {@link Common} class.\n   *\n   * Current default hardfork: `istanbul`\n   */\n  common?: Common\n  /**\n   * A transaction object by default gets frozen along initialization. This gives you\n   * strong additional security guarantees on the consistency of the tx parameters.\n   * It also enables tx hash caching when the `hash()` method is called multiple times.\n   *\n   * If you need to deactivate the tx freeze - e.g. because you want to subclass tx and\n   * add additional properties - it is strongly encouraged that you do the freeze yourself\n   * within your code instead.\n   *\n   * Default: true\n   */\n  freeze?: boolean\n\n  /**\n   * Allows unlimited contract code-size init while debugging. This (partially) disables EIP-3860.\n   * Gas cost for initcode size analysis will still be charged. Use with caution.\n   */\n  allowUnlimitedInitCodeSize?: boolean\n}\n\nexport function isAccessListBytes(input: AccessListBytes | AccessList): input is AccessListBytes {\n  if (input.length === 0) {\n    return true\n  }\n  const firstItem = input[0]\n  if (Array.isArray(firstItem)) {\n    return true\n  }\n  return false\n}\n\nexport function isAccessList(input: AccessListBytes | AccessList): input is AccessList {\n  return !isAccessListBytes(input) // This is exactly the same method, except the output is negated.\n}\n\nexport function isAuthorizationListBytes(\n  input: AuthorizationListBytes | AuthorizationList\n): input is AuthorizationListBytes {\n  if (input.length === 0) {\n    return true\n  }\n  const firstItem = input[0]\n  if (Array.isArray(firstItem)) {\n    return true\n  }\n  return false\n}\n\nexport function isAuthorizationList(\n  input: AuthorizationListBytes | AuthorizationList\n): input is AuthorizationList {\n  return !isAuthorizationListBytes(input) // This is exactly the same method, except the output is negated.\n}\n\nexport interface TransactionCache {\n  hash?: Uint8Array\n  dataFee?: {\n    value: bigint\n    hardfork: string | Hardfork\n  }\n  senderPubKey?: Uint8Array\n}\n\n/**\n * Encompassing type for all transaction types.\n */\nexport enum TransactionType {\n  Legacy = 0,\n  AccessListEIP2930 = 1,\n  FeeMarketEIP1559 = 2,\n  BlobEIP4844 = 3,\n  EOACodeEIP7702 = 4,\n}\n\nexport interface Transaction {\n  [TransactionType.Legacy]: LegacyTransaction\n  [TransactionType.FeeMarketEIP1559]: FeeMarketEIP1559Transaction\n  [TransactionType.AccessListEIP2930]: AccessListEIP2930Transaction\n  [TransactionType.BlobEIP4844]: BlobEIP4844Transaction\n  [TransactionType.EOACodeEIP7702]: EOACodeEIP7702Transaction\n}\n\nexport type TypedTransaction = Transaction[TransactionType]\n\nexport function isLegacyTx(tx: TypedTransaction): tx is LegacyTransaction {\n  return tx.type === TransactionType.Legacy\n}\n\nexport function isAccessListEIP2930Tx(tx: TypedTransaction): tx is AccessListEIP2930Transaction {\n  return tx.type === TransactionType.AccessListEIP2930\n}\n\nexport function isFeeMarketEIP1559Tx(tx: TypedTransaction): tx is FeeMarketEIP1559Transaction {\n  return tx.type === TransactionType.FeeMarketEIP1559\n}\n\nexport function isBlobEIP4844Tx(tx: TypedTransaction): tx is BlobEIP4844Transaction {\n  return tx.type === TransactionType.BlobEIP4844\n}\n\nexport function isEOACodeEIP7702Tx(tx: TypedTransaction): tx is EOACodeEIP7702Transaction {\n  return tx.type === TransactionType.EOACodeEIP7702\n}\n\nexport interface TransactionInterface<T extends TransactionType = TransactionType> {\n  readonly common: Common\n  readonly nonce: bigint\n  readonly gasLimit: bigint\n  readonly to?: Address\n  readonly value: bigint\n  readonly data: Uint8Array\n  readonly v?: bigint\n  readonly r?: bigint\n  readonly s?: bigint\n  readonly cache: TransactionCache\n  supports(capability: Capability): boolean\n  type: TransactionType\n  getBaseFee(): bigint\n  getDataFee(): bigint\n  getUpfrontCost(): bigint\n  toCreationAddress(): boolean\n  raw(): TxValuesArray[T]\n  serialize(): Uint8Array\n  getMessageToSign(): Uint8Array | Uint8Array[]\n  getHashedMessageToSign(): Uint8Array\n  hash(): Uint8Array\n  getMessageToVerifySignature(): Uint8Array\n  getValidationErrors(): string[]\n  isSigned(): boolean\n  isValid(): boolean\n  verifySignature(): boolean\n  getSenderAddress(): Address\n  getSenderPublicKey(): Uint8Array\n  sign(privateKey: Uint8Array): Transaction[T]\n  toJSON(): JsonTx\n  errorStr(): string\n}\n\nexport interface LegacyTxInterface<T extends TransactionType = TransactionType>\n  extends TransactionInterface<T> {}\n\nexport interface EIP2718CompatibleTx<T extends TransactionType = TransactionType>\n  extends TransactionInterface<T> {\n  readonly chainId: bigint\n  getMessageToSign(): Uint8Array\n}\n\nexport interface EIP2930CompatibleTx<T extends TransactionType = TransactionType>\n  extends EIP2718CompatibleTx<T> {\n  readonly accessList: AccessListBytes\n  readonly AccessListJSON: AccessList\n}\n\nexport interface EIP1559CompatibleTx<T extends TransactionType = TransactionType>\n  extends EIP2930CompatibleTx<T> {\n  readonly maxPriorityFeePerGas: bigint\n  readonly maxFeePerGas: bigint\n}\n\nexport interface EIP4844CompatibleTx<T extends TransactionType = TransactionType>\n  extends EIP1559CompatibleTx<T> {\n  readonly maxFeePerBlobGas: bigint\n  blobVersionedHashes: Uint8Array[]\n  blobs?: Uint8Array[]\n  kzgCommitments?: Uint8Array[]\n  kzgProofs?: Uint8Array[]\n  serializeNetworkWrapper(): Uint8Array\n  numBlobs(): number\n}\n\nexport interface EIP7702CompatibleTx<T extends TransactionType = TransactionType>\n  extends EIP1559CompatibleTx<T> {\n  // ChainID, Address, [nonce], y_parity, r, s\n  readonly authorizationList: AuthorizationListBytes\n}\n\nexport interface TxData {\n  [TransactionType.Legacy]: LegacyTxData\n  [TransactionType.AccessListEIP2930]: AccessListEIP2930TxData\n  [TransactionType.FeeMarketEIP1559]: FeeMarketEIP1559TxData\n  [TransactionType.BlobEIP4844]: BlobEIP4844TxData\n  [TransactionType.EOACodeEIP7702]: EOACodeEIP7702TxData\n}\n\nexport type TypedTxData = TxData[TransactionType]\n\nexport function isLegacyTxData(txData: TypedTxData): txData is LegacyTxData {\n  const txType = Number(bytesToBigInt(toBytes(txData.type)))\n  return txType === TransactionType.Legacy\n}\n\nexport function isAccessListEIP2930TxData(txData: TypedTxData): txData is AccessListEIP2930TxData {\n  const txType = Number(bytesToBigInt(toBytes(txData.type)))\n  return txType === TransactionType.AccessListEIP2930\n}\n\nexport function isFeeMarketEIP1559TxData(txData: TypedTxData): txData is FeeMarketEIP1559TxData {\n  const txType = Number(bytesToBigInt(toBytes(txData.type)))\n  return txType === TransactionType.FeeMarketEIP1559\n}\n\nexport function isBlobEIP4844TxData(txData: TypedTxData): txData is BlobEIP4844TxData {\n  const txType = Number(bytesToBigInt(toBytes(txData.type)))\n  return txType === TransactionType.BlobEIP4844\n}\n\nexport function isEOACodeEIP7702TxData(txData: TypedTxData): txData is EOACodeEIP7702TxData {\n  const txType = Number(bytesToBigInt(toBytes(txData.type)))\n  return txType === TransactionType.EOACodeEIP7702\n}\n\n/**\n * Legacy {@link Transaction} Data\n */\nexport type LegacyTxData = {\n  /**\n   * The transaction's nonce.\n   */\n  nonce?: BigIntLike\n\n  /**\n   * The transaction's gas price.\n   */\n  gasPrice?: BigIntLike | null\n\n  /**\n   * The transaction's gas limit.\n   */\n  gasLimit?: BigIntLike\n\n  /**\n   * The transaction's the address is sent to.\n   */\n  to?: AddressLike | ''\n\n  /**\n   * The amount of Ether sent.\n   */\n  value?: BigIntLike\n\n  /**\n   * This will contain the data of the message or the init of a contract.\n   */\n  data?: BytesLike | ''\n\n  /**\n   * EC recovery ID.\n   */\n  v?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  r?: BigIntLike\n\n  /**\n   * EC signature parameter.\n   */\n  s?: BigIntLike\n\n  /**\n   * The transaction type\n   */\n\n  type?: BigIntLike\n}\n\n/**\n * {@link AccessListEIP2930Transaction} data.\n */\nexport interface AccessListEIP2930TxData extends LegacyTxData {\n  /**\n   * The transaction's chain ID\n   */\n  chainId?: BigIntLike\n\n  /**\n   * The access list which contains the addresses/storage slots which the transaction wishes to access\n   */\n  accessList?: AccessListBytes | AccessList | null\n}\n\n/**\n * {@link FeeMarketEIP1559Transaction} data.\n */\nexport interface FeeMarketEIP1559TxData extends AccessListEIP2930TxData {\n  /**\n   * The transaction's gas price, inherited from {@link Transaction}.  This property is not used for EIP1559\n   * transactions and should always be undefined for this specific transaction type.\n   */\n  gasPrice?: never | null\n  /**\n   * The maximum inclusion fee per gas (this fee is given to the miner)\n   */\n  maxPriorityFeePerGas?: BigIntLike\n  /**\n   * The maximum total fee\n   */\n  maxFeePerGas?: BigIntLike\n}\n\n/**\n * {@link BlobEIP4844Transaction} data.\n */\nexport interface BlobEIP4844TxData extends FeeMarketEIP1559TxData {\n  /**\n   * The versioned hashes used to validate the blobs attached to a transaction\n   */\n  blobVersionedHashes?: BytesLike[]\n  /**\n   * The maximum fee per blob gas paid for the transaction\n   */\n  maxFeePerBlobGas?: BigIntLike\n  /**\n   * The blobs associated with a transaction\n   */\n  blobs?: BytesLike[]\n  /**\n   * The KZG commitments corresponding to the versioned hashes for each blob\n   */\n  kzgCommitments?: BytesLike[]\n  /**\n   * The KZG proofs associated with the transaction\n   */\n  kzgProofs?: BytesLike[]\n  /**\n   * An array of arbitrary strings that blobs are to be constructed from\n   */\n  blobsData?: string[]\n}\n\n/**\n * {@link EOACodeEIP7702Tx} data.\n */\nexport interface EOACodeEIP7702TxData extends FeeMarketEIP1559TxData {\n  authorizationList?: AuthorizationListBytes | AuthorizationList | never\n}\n\nexport interface TxValuesArray {\n  [TransactionType.Legacy]: LegacyTxValuesArray\n  [TransactionType.AccessListEIP2930]: AccessListEIP2930TxValuesArray\n  [TransactionType.FeeMarketEIP1559]: FeeMarketEIP1559TxValuesArray\n  [TransactionType.BlobEIP4844]: BlobEIP4844TxValuesArray\n  [TransactionType.EOACodeEIP7702]: EOACodeEIP7702TxValuesArray\n}\n\n/**\n * Bytes values array for a legacy {@link Transaction}\n */\ntype LegacyTxValuesArray = Uint8Array[]\n\n/**\n * Bytes values array for an {@link AccessListEIP2930Transaction}\n */\ntype AccessListEIP2930TxValuesArray = [\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  AccessListBytes,\n  Uint8Array?,\n  Uint8Array?,\n  Uint8Array?\n]\n\n/**\n * Bytes values array for a {@link FeeMarketEIP1559Transaction}\n */\ntype FeeMarketEIP1559TxValuesArray = [\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  AccessListBytes,\n  Uint8Array?,\n  Uint8Array?,\n  Uint8Array?\n]\n\n/**\n * Bytes values array for a {@link EOACodeEIP7702Transaction}\n */\ntype EOACodeEIP7702TxValuesArray = [\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  AccessListBytes,\n  AuthorizationListBytes,\n  Uint8Array?,\n  Uint8Array?,\n  Uint8Array?\n]\n\n/**\n * Bytes values array for a {@link BlobEIP4844Transaction}\n */\ntype BlobEIP4844TxValuesArray = [\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  AccessListBytes,\n  Uint8Array,\n  Uint8Array[],\n  Uint8Array?,\n  Uint8Array?,\n  Uint8Array?\n]\n\nexport type BlobEIP4844NetworkValuesArray = [\n  BlobEIP4844TxValuesArray,\n  Uint8Array[],\n  Uint8Array[],\n  Uint8Array[]\n]\n\ntype JsonAccessListItem = { address: string; storageKeys: string[] }\n\n/**\n * Generic interface for all tx types with a\n * JSON representation of a transaction.\n *\n * Note that all values are marked as optional\n * and not all the values are present on all tx types\n * (an EIP1559 tx e.g. lacks a `gasPrice`).\n */\nexport interface JsonTx {\n  nonce?: PrefixedHexString\n  gasPrice?: PrefixedHexString\n  gasLimit?: PrefixedHexString\n  to?: PrefixedHexString\n  data?: PrefixedHexString\n  v?: PrefixedHexString\n  r?: PrefixedHexString\n  s?: PrefixedHexString\n  value?: PrefixedHexString\n  chainId?: PrefixedHexString\n  accessList?: JsonAccessListItem[] // TODO should this not be AccessList?\n  authorizationList?: AuthorizationList\n  type?: PrefixedHexString\n  maxPriorityFeePerGas?: PrefixedHexString\n  maxFeePerGas?: PrefixedHexString\n  maxFeePerBlobGas?: PrefixedHexString\n  blobVersionedHashes?: PrefixedHexString[]\n}\n\nexport type JsonBlobTxNetworkWrapper = JsonTx & {\n  blobs: PrefixedHexString[]\n  kzgCommitments: PrefixedHexString[]\n  kzgProofs: PrefixedHexString[]\n}\n\n/*\n * Based on https://ethereum.org/en/developers/docs/apis/json-rpc/\n */\nexport interface JsonRpcTx {\n  blockHash: string | null // DATA, 32 Bytes - hash of the block where this transaction was in. null when it's pending.\n  blockNumber: string | null // QUANTITY - block number where this transaction was in. null when it's pending.\n  from: string // DATA, 20 Bytes - address of the sender.\n  gas: string // QUANTITY - gas provided by the sender.\n  gasPrice: string // QUANTITY - gas price provided by the sender in wei. If EIP-1559 tx, defaults to maxFeePerGas.\n  maxFeePerGas?: string // QUANTITY - max total fee per gas provided by the sender in wei.\n  maxPriorityFeePerGas?: string // QUANTITY - max priority fee per gas provided by the sender in wei.\n  type: string // QUANTITY - EIP-2718 Typed Transaction type\n  accessList?: JsonTx['accessList'] // EIP-2930 access list\n  chainId?: string // Chain ID that this transaction is valid on.\n  hash: string // DATA, 32 Bytes - hash of the transaction.\n  input: string // DATA - the data send along with the transaction.\n  nonce: string // QUANTITY - the number of transactions made by the sender prior to this one.\n  to: string | null /// DATA, 20 Bytes - address of the receiver. null when it's a contract creation transaction.\n  transactionIndex: string | null // QUANTITY - integer of the transactions index position in the block. null when it's pending.\n  value: string // QUANTITY - value transferred in Wei.\n  v: string // QUANTITY - ECDSA recovery id\n  r: string // DATA, 32 Bytes - ECDSA signature r\n  s: string // DATA, 32 Bytes - ECDSA signature s\n  maxFeePerBlobGas?: string // QUANTITY - max data fee for blob transactions\n  blobVersionedHashes?: string[] // DATA - array of 32 byte versioned hashes for blob transactions\n}\n", "import {\n  type PrefixedHexString,\n  bytesToHex,\n  hexToBytes,\n  setLengthLeft,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\n\nimport { isAccessList, isAuthorizationList } from './types.js'\n\nimport type {\n  AccessList,\n  AccessListBytes,\n  AccessListItem,\n  AuthorizationList,\n  AuthorizationListBytes,\n  TransactionType,\n} from './types.js'\nimport type { AuthorizationListItem, Common } from '@ethereumjs/common'\n\nexport function checkMaxInitCodeSize(common: Common, length: number) {\n  const maxInitCodeSize = common.param('vm', 'maxInitCodeSize')\n  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {\n    throw new Error(\n      `the initcode size of this transaction is too large: it is ${length} while the max is ${common.param(\n        'vm',\n        'maxInitCodeSize'\n      )}`\n    )\n  }\n}\n\nexport class AccessLists {\n  public static getAccessListData(accessList: AccessListBytes | AccessList) {\n    let AccessListJSON\n    let bufferAccessList\n    if (isAccessList(accessList)) {\n      AccessListJSON = accessList\n      const newAccessList: AccessListBytes = []\n\n      for (let i = 0; i < accessList.length; i++) {\n        const item: AccessListItem = accessList[i]\n        const addressBytes = hexToBytes(item.address)\n        const storageItems: Uint8Array[] = []\n        for (let index = 0; index < item.storageKeys.length; index++) {\n          storageItems.push(hexToBytes(item.storageKeys[index]))\n        }\n        newAccessList.push([addressBytes, storageItems])\n      }\n      bufferAccessList = newAccessList\n    } else {\n      bufferAccessList = accessList ?? []\n      // build the JSON\n      const json: AccessList = []\n      for (let i = 0; i < bufferAccessList.length; i++) {\n        const data = bufferAccessList[i]\n        const address = bytesToHex(data[0])\n        const storageKeys: PrefixedHexString[] = []\n        for (let item = 0; item < data[1].length; item++) {\n          storageKeys.push(bytesToHex(data[1][item]))\n        }\n        const jsonItem: AccessListItem = {\n          address,\n          storageKeys,\n        }\n        json.push(jsonItem)\n      }\n      AccessListJSON = json\n    }\n\n    return {\n      AccessListJSON,\n      accessList: bufferAccessList,\n    }\n  }\n\n  public static verifyAccessList(accessList: AccessListBytes) {\n    for (let key = 0; key < accessList.length; key++) {\n      const accessListItem = accessList[key]\n      const address = accessListItem[0]\n      const storageSlots = accessListItem[1]\n      if ((<any>accessListItem)[2] !== undefined) {\n        throw new Error(\n          'Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.'\n        )\n      }\n      if (address.length !== 20) {\n        throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes')\n      }\n      for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {\n        if (storageSlots[storageSlot].length !== 32) {\n          throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes')\n        }\n      }\n    }\n  }\n\n  public static getAccessListJSON(accessList: AccessListBytes) {\n    const accessListJSON = []\n    for (let index = 0; index < accessList.length; index++) {\n      const item: any = accessList[index]\n      const JSONItem: any = {\n        address: bytesToHex(setLengthLeft(item[0], 20)),\n        storageKeys: [],\n      }\n      const storageSlots: Uint8Array[] = item[1]\n      for (let slot = 0; slot < storageSlots.length; slot++) {\n        const storageSlot = storageSlots[slot]\n        JSONItem.storageKeys.push(bytesToHex(setLengthLeft(storageSlot, 32)))\n      }\n      accessListJSON.push(JSONItem)\n    }\n    return accessListJSON\n  }\n\n  public static getDataFeeEIP2930(accessList: AccessListBytes, common: Common): number {\n    const accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost')\n    const accessListAddressCost = common.param('gasPrices', 'accessListAddressCost')\n\n    let slots = 0\n    for (let index = 0; index < accessList.length; index++) {\n      const item = accessList[index]\n      const storageSlots = item[1]\n      slots += storageSlots.length\n    }\n\n    const addresses = accessList.length\n    return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost)\n  }\n}\n\nexport class AuthorizationLists {\n  public static getAuthorizationListData(\n    authorizationList: AuthorizationListBytes | AuthorizationList\n  ) {\n    let AuthorizationListJSON\n    let bufferAuthorizationList\n    if (isAuthorizationList(authorizationList)) {\n      AuthorizationListJSON = authorizationList\n      const newAuthorizationList: AuthorizationListBytes = []\n      const jsonItems = ['chainId', 'address', 'nonce', 'yParity', 'r', 's']\n      for (let i = 0; i < authorizationList.length; i++) {\n        const item: AuthorizationListItem = authorizationList[i]\n        for (const key of jsonItems) {\n          // @ts-ignore TODO why does TsScript fail here?\n          if (item[key] === undefined) {\n            throw new Error(`EIP-7702 authorization list invalid: ${key} is not defined`)\n          }\n        }\n        const chainId = hexToBytes(item.chainId)\n        const addressBytes = hexToBytes(item.address)\n        const nonceList = []\n        for (let j = 0; j < item.nonce.length; j++) {\n          nonceList.push(hexToBytes(item.nonce[j]))\n        }\n        const yParity = hexToBytes(item.yParity)\n        const r = hexToBytes(item.r)\n        const s = hexToBytes(item.s)\n\n        newAuthorizationList.push([chainId, addressBytes, nonceList, yParity, r, s])\n      }\n      bufferAuthorizationList = newAuthorizationList\n    } else {\n      bufferAuthorizationList = authorizationList ?? []\n      // build the JSON\n      const json: AuthorizationList = []\n      for (let i = 0; i < bufferAuthorizationList.length; i++) {\n        const data = bufferAuthorizationList[i]\n        const chainId = bytesToHex(data[0])\n        const address = bytesToHex(data[1])\n        const nonces = data[2]\n        const nonceList: PrefixedHexString[] = []\n        for (let j = 0; j < nonces.length; j++) {\n          nonceList.push(bytesToHex(nonces[j]))\n        }\n        const yParity = bytesToHex(data[3])\n        const r = bytesToHex(data[4])\n        const s = bytesToHex(data[5])\n        const jsonItem: AuthorizationListItem = {\n          chainId,\n          address,\n          nonce: nonceList,\n          yParity,\n          r,\n          s,\n        }\n        json.push(jsonItem)\n      }\n      AuthorizationListJSON = json\n    }\n\n    return {\n      AuthorizationListJSON,\n      authorizationList: bufferAuthorizationList,\n    }\n  }\n\n  public static verifyAuthorizationList(authorizationList: AuthorizationListBytes) {\n    for (let key = 0; key < authorizationList.length; key++) {\n      const authorizationListItem = authorizationList[key]\n      const address = authorizationListItem[1]\n      const nonceList = authorizationListItem[2]\n      const yParity = authorizationListItem[3]\n      const r = authorizationListItem[4]\n      const s = authorizationListItem[5]\n      validateNoLeadingZeroes({ yParity, r, s })\n      if (address.length !== 20) {\n        throw new Error('Invalid EIP-7702 transaction: address length should be 20 bytes')\n      }\n      if (nonceList.length > 1) {\n        throw new Error('Invalid EIP-7702 transaction: nonce list should consist of at most 1 item')\n      } else if (nonceList.length === 1) {\n        validateNoLeadingZeroes({ nonce: nonceList[0] })\n      }\n    }\n  }\n\n  public static getDataFeeEIP7702(authorityList: AuthorizationListBytes, common: Common): number {\n    const perAuthBaseCost = common.param('gasPrices', 'perAuthBaseCost')\n    return authorityList.length * Number(perAuthBaseCost)\n  }\n}\n\nexport function txTypeBytes(txType: TransactionType): Uint8Array {\n  return hexToBytes(`0x${txType.toString(16).padStart(2, '0')}`)\n}\n", "import { Chain, Common } from '@ethereumjs/common'\nimport {\n  Address,\n  BIGINT_0,\n  MAX_INTEGER,\n  MAX_UINT64,\n  bigIntToHex,\n  bytesToBigInt,\n  bytesToHex,\n  ecsign,\n  publicToAddress,\n  toBytes,\n  unpadBytes,\n} from '@ethereumjs/util'\n\nimport { Capability, TransactionType } from './types.js'\nimport { checkMaxInitCodeSize } from './util.js'\n\nimport type {\n  JsonTx,\n  Transaction,\n  TransactionCache,\n  TransactionInterface,\n  TxData,\n  TxOptions,\n  TxValuesArray,\n} from './types.js'\nimport type { BigIntLike } from '@ethereumjs/util'\n\n/**\n * This base class will likely be subject to further\n * refactoring along the introduction of additional tx types\n * on the Ethereum network.\n *\n * It is therefore not recommended to use directly.\n */\nexport abstract class BaseTransaction<T extends TransactionType>\n  implements TransactionInterface<T>\n{\n  protected readonly _type: TransactionType\n\n  public readonly nonce: bigint\n  public readonly gasLimit: bigint\n  public readonly to?: Address\n  public readonly value: bigint\n  public readonly data: Uint8Array\n\n  public readonly v?: bigint\n  public readonly r?: bigint\n  public readonly s?: bigint\n\n  public readonly common!: Common\n\n  public cache: TransactionCache = {\n    hash: undefined,\n    dataFee: undefined,\n    senderPubKey: undefined,\n  }\n\n  protected readonly txOptions: TxOptions\n\n  /**\n   * List of tx type defining EIPs,\n   * e.g. 1559 (fee market) and 2930 (access lists)\n   * for FeeMarketEIP1559Transaction objects\n   */\n  protected activeCapabilities: number[] = []\n\n  /**\n   * The default chain the tx falls back to if no Common\n   * is provided and if the chain can't be derived from\n   * a passed in chainId (only EIP-2718 typed txs) or\n   * EIP-155 signature (legacy txs).\n   *\n   * @hidden\n   */\n  protected DEFAULT_CHAIN = Chain.Mainnet\n\n  constructor(txData: TxData[T], opts: TxOptions) {\n    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData\n    this._type = Number(bytesToBigInt(toBytes(type)))\n\n    this.txOptions = opts\n\n    const toB = toBytes(to === '' ? '0x' : to)\n    const vB = toBytes(v)\n    const rB = toBytes(r)\n    const sB = toBytes(s)\n\n    this.nonce = bytesToBigInt(toBytes(nonce))\n    this.gasLimit = bytesToBigInt(toBytes(gasLimit))\n    this.to = toB.length > 0 ? new Address(toB) : undefined\n    this.value = bytesToBigInt(toBytes(value))\n    this.data = toBytes(data === '' ? '0x' : data)\n\n    this.v = vB.length > 0 ? bytesToBigInt(vB) : undefined\n    this.r = rB.length > 0 ? bytesToBigInt(rB) : undefined\n    this.s = sB.length > 0 ? bytesToBigInt(sB) : undefined\n\n    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s })\n\n    // geth limits gasLimit to 2^64-1\n    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64)\n\n    // EIP-2681 limits nonce to 2^64-1 (cannot equal 2^64-1)\n    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true)\n\n    const createContract = this.to === undefined || this.to === null\n    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false\n    const common = opts.common ?? this._getCommon()\n    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {\n      checkMaxInitCodeSize(common, this.data.length)\n    }\n  }\n\n  /**\n   * Returns the transaction type.\n   *\n   * Note: legacy txs will return tx type `0`.\n   */\n  get type() {\n    return this._type\n  }\n\n  /**\n   * Checks if a tx type defining capability is active\n   * on a tx, for example the EIP-1559 fee market mechanism\n   * or the EIP-2930 access list feature.\n   *\n   * Note that this is different from the tx type itself,\n   * so EIP-2930 access lists can very well be active\n   * on an EIP-1559 tx for example.\n   *\n   * This method can be useful for feature checks if the\n   * tx type is unknown (e.g. when instantiated with\n   * the tx factory).\n   *\n   * See `Capabilities` in the `types` module for a reference\n   * on all supported capabilities.\n   */\n  supports(capability: Capability) {\n    return this.activeCapabilities.includes(capability)\n  }\n\n  /**\n   * Validates the transaction signature and minimum gas requirements.\n   * @returns {string[]} an array of error strings\n   */\n  getValidationErrors(): string[] {\n    const errors = []\n\n    if (this.isSigned() && !this.verifySignature()) {\n      errors.push('Invalid Signature')\n    }\n\n    if (this.getBaseFee() > this.gasLimit) {\n      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`)\n    }\n\n    return errors\n  }\n\n  /**\n   * Validates the transaction signature and minimum gas requirements.\n   * @returns {boolean} true if the transaction is valid, false otherwise\n   */\n  isValid(): boolean {\n    const errors = this.getValidationErrors()\n\n    return errors.length === 0\n  }\n\n  /**\n   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)\n   */\n  getBaseFee(): bigint {\n    const txFee = this.common.param('gasPrices', 'tx')\n    let fee = this.getDataFee()\n    if (txFee) fee += txFee\n    if (this.common.gteHardfork('homestead') && this.toCreationAddress()) {\n      const txCreationFee = this.common.param('gasPrices', 'txCreation')\n      if (txCreationFee) fee += txCreationFee\n    }\n    return fee\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    const txDataZero = this.common.param('gasPrices', 'txDataZero')\n    const txDataNonZero = this.common.param('gasPrices', 'txDataNonZero')\n\n    let cost = BIGINT_0\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] === 0 ? (cost += txDataZero) : (cost += txDataNonZero)\n    }\n\n    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {\n      const dataLength = BigInt(Math.ceil(this.data.length / 32))\n      const initCodeCost = this.common.param('gasPrices', 'initCodeWordCost') * dataLength\n      cost += initCodeCost\n    }\n\n    return cost\n  }\n\n  /**\n   * Returns the effective priority fee. This is the priority fee which the coinbase will receive\n   * once it is included in the block\n   * @param baseFee Optional baseFee of the block. Note for EIP1559 and EIP4844 this is required.\n   */\n  abstract getEffectivePriorityFee(baseFee: bigint | undefined): bigint\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  abstract getUpfrontCost(): bigint\n\n  /**\n   * If the tx's `to` is to the creation address\n   */\n  toCreationAddress(): boolean {\n    return this.to === undefined || this.to.bytes.length === 0\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of this transaction, in order.\n   *\n   * Use {@link BaseTransaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Bytes values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BaseTransaction.getMessageToSign}.\n   */\n  abstract raw(): TxValuesArray[T]\n\n  /**\n   * Returns the encoding of the transaction.\n   */\n  abstract serialize(): Uint8Array\n\n  // Returns the raw unsigned tx, which is used to sign the transaction.\n  abstract getMessageToSign(): Uint8Array | Uint8Array[]\n\n  // Returns the hashed unsigned tx, which is used to sign the transaction.\n  abstract getHashedMessageToSign(): Uint8Array\n\n  abstract hash(): Uint8Array\n\n  abstract getMessageToVerifySignature(): Uint8Array\n\n  public isSigned(): boolean {\n    const { v, r, s } = this\n    if (v === undefined || r === undefined || s === undefined) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Determines if the signature is valid\n   */\n  verifySignature(): boolean {\n    try {\n      // Main signature verification is done in `getSenderPublicKey()`\n      const publicKey = this.getSenderPublicKey()\n      return unpadBytes(publicKey).length !== 0\n    } catch (e: any) {\n      return false\n    }\n  }\n\n  /**\n   * Returns the sender's address\n   */\n  getSenderAddress(): Address {\n    return new Address(publicToAddress(this.getSenderPublicKey()))\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  abstract getSenderPublicKey(): Uint8Array\n\n  /**\n   * Signs a transaction.\n   *\n   * Note that the signed tx is returned as a new object,\n   * use as follows:\n   * ```javascript\n   * const signedTx = tx.sign(privateKey)\n   * ```\n   */\n  sign(privateKey: Uint8Array): Transaction[T] {\n    if (privateKey.length !== 32) {\n      const msg = this._errorMsg('Private key must be 32 bytes in length.')\n      throw new Error(msg)\n    }\n\n    // Hack for the constellation that we have got a legacy tx after spuriousDragon with a non-EIP155 conforming signature\n    // and want to recreate a signature (where EIP155 should be applied)\n    // Leaving this hack lets the legacy.spec.ts -> sign(), verifySignature() test fail\n    // 2021-06-23\n    let hackApplied = false\n    if (\n      this.type === TransactionType.Legacy &&\n      this.common.gteHardfork('spuriousDragon') &&\n      !this.supports(Capability.EIP155ReplayProtection)\n    ) {\n      this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      hackApplied = true\n    }\n\n    const msgHash = this.getHashedMessageToSign()\n    const ecSignFunction = this.common.customCrypto?.ecsign ?? ecsign\n    const { v, r, s } = ecSignFunction(msgHash, privateKey)\n    const tx = this.addSignature(v, r, s, true)\n\n    // Hack part 2\n    if (hackApplied) {\n      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection)\n      if (index > -1) {\n        this.activeCapabilities.splice(index, 1)\n      }\n    }\n\n    return tx\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    return {\n      type: bigIntToHex(BigInt(this.type)),\n      nonce: bigIntToHex(this.nonce),\n      gasLimit: bigIntToHex(this.gasLimit),\n      to: this.to !== undefined ? this.to.toString() : undefined,\n      value: bigIntToHex(this.value),\n      data: bytesToHex(this.data),\n      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,\n      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,\n      s: this.s !== undefined ? bigIntToHex(this.s) : undefined,\n    }\n  }\n\n  /**\n   * Returns a new transaction with the same data fields as the current, but now signed\n   * @param v The `v` value of the signature\n   * @param r The `r` value of the signature\n   * @param s The `s` value of the signature\n   * @param convertV Set this to `true` if the raw output of `ecsign` is used. If this is `false` (default)\n   *                 then the raw value passed for `v` will be used for the signature. For legacy transactions,\n   *                 if this is set to `true`, it will also set the right `v` value for the chain id.\n   */\n  abstract addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV?: boolean\n  ): Transaction[T]\n\n  /**\n   * Does chain ID checks on common and returns a common\n   * to be used on instantiation\n   * @hidden\n   *\n   * @param common - {@link Common} instance from tx options\n   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)\n   */\n  protected _getCommon(common?: Common, chainId?: BigIntLike) {\n    // Chain ID provided\n    if (chainId !== undefined) {\n      const chainIdBigInt = bytesToBigInt(toBytes(chainId))\n      if (common) {\n        if (common.chainId() !== chainIdBigInt) {\n          const msg = this._errorMsg(\n            `The chain ID does not match the chain ID of Common. Got: ${chainIdBigInt}, expected: ${common.chainId()}`\n          )\n          throw new Error(msg)\n        }\n        // Common provided, chain ID does match\n        // -> Return provided Common\n        return common.copy()\n      } else {\n        if (Common.isSupportedChainId(chainIdBigInt)) {\n          // No Common, chain ID supported by Common\n          // -> Instantiate Common with chain ID\n          return new Common({ chain: chainIdBigInt })\n        } else {\n          // No Common, chain ID not supported by Common\n          // -> Instantiate custom Common derived from DEFAULT_CHAIN\n          return Common.custom(\n            {\n              name: 'custom-chain',\n              networkId: chainIdBigInt,\n              chainId: chainIdBigInt,\n            },\n            { baseChain: this.DEFAULT_CHAIN }\n          )\n        }\n      }\n    } else {\n      // No chain ID provided\n      // -> return Common provided or create new default Common\n      return common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN })\n    }\n  }\n\n  /**\n   * Validates that an object with BigInt values cannot exceed the specified bit limit.\n   * @param values Object containing string keys and BigInt values\n   * @param bits Number of bits to check (64 or 256)\n   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value\n   */\n  protected _validateCannotExceedMaxInteger(\n    values: { [key: string]: bigint | undefined },\n    bits = 256,\n    cannotEqual = false\n  ) {\n    for (const [key, value] of Object.entries(values)) {\n      switch (bits) {\n        case 64:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_UINT64) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_UINT64) {\n              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`)\n              throw new Error(msg)\n            }\n          }\n          break\n        case 256:\n          if (cannotEqual) {\n            if (value !== undefined && value >= MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          } else {\n            if (value !== undefined && value > MAX_INTEGER) {\n              const msg = this._errorMsg(\n                `${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`\n              )\n              throw new Error(msg)\n            }\n          }\n          break\n        default: {\n          const msg = this._errorMsg('unimplemented bits value')\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n\n  protected static _validateNotArray(values: { [key: string]: any }) {\n    const txDataKeys = [\n      'nonce',\n      'gasPrice',\n      'gasLimit',\n      'to',\n      'value',\n      'data',\n      'v',\n      'r',\n      's',\n      'type',\n      'baseFee',\n      'maxFeePerGas',\n      'chainId',\n    ]\n    for (const [key, value] of Object.entries(values)) {\n      if (txDataKeys.includes(key)) {\n        if (Array.isArray(value)) {\n          throw new Error(`${key} cannot be an array`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public abstract errorStr(): string\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected abstract _errorMsg(msg: string): string\n\n  /**\n   * Returns the shared error postfix part for _error() method\n   * tx type implementations.\n   */\n  protected _getSharedErrorPostfix() {\n    let hash = ''\n    try {\n      hash = this.isSigned() ? bytesToHex(this.hash()) : 'not available (unsigned)'\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let isSigned = ''\n    try {\n      isSigned = this.isSigned().toString()\n    } catch (e: any) {\n      hash = 'error'\n    }\n    let hf = ''\n    try {\n      hf = this.common.hardfork()\n    } catch (e: any) {\n      hf = 'error'\n    }\n\n    let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `\n    postfix += `signed=${isSigned} hf=${hf}`\n\n    return postfix\n  }\n}\n", "import type { EIP1559CompatibleTx } from '../types.js'\n\nexport function getUpfrontCost(tx: EIP1559CompatibleTx, baseFee: bigint): bigint {\n  const prio = tx.maxPriorityFeePerGas\n  const maxBase = tx.maxFeePerGas - baseFee\n  const inclusionFeePerGas = prio < maxBase ? prio : maxBase\n  const gasPrice = inclusionFeePerGas + baseFee\n  return tx.gasLimit * gasPrice + tx.value\n}\n\nexport function getEffectivePriorityFee(\n  tx: EIP1559CompatibleTx,\n  baseFee: bigint | undefined\n): bigint {\n  if (baseFee === undefined || baseFee > tx.maxFeePerGas) {\n    throw new Error('Tx cannot pay baseFee')\n  }\n\n  // The remaining fee for the coinbase, which can take up to this value, capped at `maxPriorityFeePerGas`\n  const remainingFee = tx.maxFeePerGas - baseFee\n\n  return tx.maxPriorityFeePerGas < remainingFee ? tx.maxPriorityFeePerGas : remainingFee\n}\n", "import { SECP256K1_ORDER_DIV_2, bigIntToUnpaddedBytes, ecrecover } from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\n\nimport { BaseTransaction } from '../baseTransaction.js'\nimport { Capability } from '../types.js'\n\nimport type { LegacyTxInterface } from '../types.js'\n\nexport function errorMsg(tx: LegacyTxInterface, msg: string) {\n  return `${msg} (${tx.errorStr()})`\n}\n\nexport function isSigned(tx: LegacyTxInterface): boolean {\n  const { v, r, s } = tx\n  if (v === undefined || r === undefined || s === undefined) {\n    return false\n  } else {\n    return true\n  }\n}\n\n/**\n * The amount of gas paid for the data in this tx\n */\nexport function getDataFee(tx: LegacyTxInterface, extraCost?: bigint): bigint {\n  if (tx.cache.dataFee && tx.cache.dataFee.hardfork === tx.common.hardfork()) {\n    return tx.cache.dataFee.value\n  }\n\n  const cost = BaseTransaction.prototype.getDataFee.bind(tx)() + (extraCost ?? 0n)\n\n  if (Object.isFrozen(tx)) {\n    tx.cache.dataFee = {\n      value: cost,\n      hardfork: tx.common.hardfork(),\n    }\n  }\n\n  return cost\n}\n\nexport function hash(tx: LegacyTxInterface): Uint8Array {\n  if (!tx.isSigned()) {\n    const msg = errorMsg(tx, 'Cannot call hash method if transaction is not signed')\n    throw new Error(msg)\n  }\n\n  const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256\n\n  if (Object.isFrozen(tx)) {\n    if (!tx.cache.hash) {\n      tx.cache.hash = keccakFunction(tx.serialize())\n    }\n    return tx.cache.hash\n  }\n\n  return keccakFunction(tx.serialize())\n}\n\n/**\n * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.\n * Reasoning: https://ethereum.stackexchange.com/a/55728\n */\nexport function validateHighS(tx: LegacyTxInterface): void {\n  const { s } = tx\n  if (tx.common.gteHardfork('homestead') && s !== undefined && s > SECP256K1_ORDER_DIV_2) {\n    const msg = errorMsg(\n      tx,\n      'Invalid Signature: s-values greater than secp256k1n/2 are considered invalid'\n    )\n    throw new Error(msg)\n  }\n}\n\nexport function getSenderPublicKey(tx: LegacyTxInterface): Uint8Array {\n  if (tx.cache.senderPubKey !== undefined) {\n    return tx.cache.senderPubKey\n  }\n\n  const msgHash = tx.getMessageToVerifySignature()\n\n  const { v, r, s } = tx\n\n  validateHighS(tx)\n\n  try {\n    const ecrecoverFunction = tx.common.customCrypto.ecrecover ?? ecrecover\n    const sender = ecrecoverFunction(\n      msgHash,\n      v!,\n      bigIntToUnpaddedBytes(r!),\n      bigIntToUnpaddedBytes(s!),\n      tx.supports(Capability.EIP155ReplayProtection) ? tx.common.chainId() : undefined\n    )\n    if (Object.isFrozen(tx)) {\n      tx.cache.senderPubKey = sender\n    }\n    return sender\n  } catch (e: any) {\n    const msg = errorMsg(tx, 'Invalid Signature')\n    throw new Error(msg)\n  }\n}\n\nexport function getEffectivePriorityFee(gasPrice: bigint, baseFee: bigint | undefined): bigint {\n  if (baseFee !== undefined && baseFee > gasPrice) {\n    throw new Error('Tx cannot pay baseFee')\n  }\n\n  if (baseFee === undefined) {\n    return gasPrice\n  }\n\n  return gasPrice - baseFee\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport { BIGINT_0, BIGINT_1, concatBytes } from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\n\nimport { txTypeBytes } from '../util.js'\n\nimport { errorMsg } from './legacy.js'\n\nimport type { EIP2718CompatibleTx } from '../types.js'\nimport type { Input } from '@ethereumjs/rlp'\n\nexport function getHashedMessageToSign(tx: EIP2718CompatibleTx): Uint8Array {\n  const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256\n  return keccakFunction(tx.getMessageToSign())\n}\n\nexport function serialize(tx: EIP2718CompatibleTx, base?: Input): Uint8Array {\n  return concatBytes(txTypeBytes(tx.type), RLP.encode(base ?? tx.raw()))\n}\n\nexport function validateYParity(tx: EIP2718CompatibleTx) {\n  const { v } = tx\n  if (v !== undefined && v !== BIGINT_0 && v !== BIGINT_1) {\n    const msg = errorMsg(tx, 'The y-parity of the transaction should either be 0 or 1')\n    throw new Error(msg)\n  }\n}\n", "import { AccessLists } from '../util.js'\n\nimport * as Legacy from './legacy.js'\n\nimport type { EIP2930CompatibleTx } from '../types.js'\n\n/**\n * The amount of gas paid for the data in this tx\n */\nexport function getDataFee(tx: EIP2930CompatibleTx): bigint {\n  return Legacy.getDataFee(tx, BigInt(AccessLists.getDataFeeEIP2930(tx.accessList, tx.common)))\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  BIGINT_0,\n  BIGINT_27,\n  MAX_INTEGER,\n  bigIntToHex,\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  equalsBytes,\n  toBytes,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\n\nimport { BaseTransaction } from './baseTransaction.js'\nimport * as EIP1559 from './capabilities/eip1559.js'\nimport * as EIP2718 from './capabilities/eip2718.js'\nimport * as EIP2930 from './capabilities/eip2930.js'\nimport * as Legacy from './capabilities/legacy.js'\nimport { TransactionType } from './types.js'\nimport { AccessLists, txTypeBytes } from './util.js'\n\nimport type {\n  AccessList,\n  AccessListBytes,\n  TxData as AllTypesTxData,\n  TxValuesArray as AllTypesTxValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types.js'\nimport type { Common } from '@ethereumjs/common'\n\ntype TxData = AllTypesTxData[TransactionType.FeeMarketEIP1559]\ntype TxValuesArray = AllTypesTxValuesArray[TransactionType.FeeMarketEIP1559]\n\n/**\n * Typed transaction with a new gas fee market mechanism\n *\n * - TransactionType: 2\n * - EIP: [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)\n */\nexport class FeeMarketEIP1559Transaction extends BaseTransaction<TransactionType.FeeMarketEIP1559> {\n  // implements EIP1559CompatibleTx<TransactionType.FeeMarketEIP1559>\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBytes\n  public readonly AccessListJSON: AccessList\n  public readonly maxPriorityFeePerGas: bigint\n  public readonly maxFeePerGas: bigint\n\n  public readonly common: Common\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new FeeMarketEIP1559Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   */\n  public static fromSerializedTx(serialized: Uint8Array, opts: TxOptions = {}) {\n    if (\n      equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.FeeMarketEIP1559)) ===\n      false\n    ) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${\n          TransactionType.FeeMarketEIP1559\n        }, received: ${bytesToHex(serialized.subarray(0, 1))}`\n      )\n    }\n\n    const values = RLP.decode(serialized.subarray(1))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return FeeMarketEIP1559Transaction.fromValuesArray(values as TxValuesArray, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 9 && values.length !== 12) {\n      throw new Error(\n        'Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).'\n      )\n    }\n\n    const [\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList,\n      v,\n      r,\n      s,\n    ] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s })\n\n    return new FeeMarketEIP1559Transaction(\n      {\n        chainId: bytesToBigInt(chainId),\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? [],\n        v: v !== undefined ? bytesToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Uint8Array)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TransactionType.FeeMarketEIP1559 }, opts)\n    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    if (!this.common.isActivatedEIP(1559)) {\n      throw new Error('EIP-1559 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas))\n    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas))\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg(\n        'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'\n      )\n      throw new Error(msg)\n    }\n\n    EIP2718.validateYParity(this)\n    Legacy.validateHighS(this)\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    return EIP2930.getDataFee(this)\n  }\n\n  /**\n   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas\n   * @param baseFee Base fee retrieved from block\n   */\n  getEffectivePriorityFee(baseFee: bigint): bigint {\n    return EIP1559.getEffectivePriorityFee(this, baseFee)\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n  getUpfrontCost(baseFee: bigint = BIGINT_0): bigint {\n    return EIP1559.getUpfrontCost(this, baseFee)\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of the EIP-1559 transaction, in order.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   *\n   * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Bytes values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBytes(this.chainId),\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),\n      bigIntToUnpaddedBytes(this.maxFeePerGas),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),\n      this.r !== undefined ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),\n      this.s !== undefined ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-1559 transaction.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Uint8Array {\n    return EIP2718.serialize(this)\n  }\n\n  /**\n   * Returns the raw serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input\n   * ```\n   */\n  getMessageToSign(): Uint8Array {\n    return EIP2718.serialize(this, this.raw().slice(0, 9))\n  }\n\n  /**\n   * Returns the hashed serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   */\n  getHashedMessageToSign(): Uint8Array {\n    return EIP2718.getHashedMessageToSign(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Uint8Array {\n    return Legacy.hash(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Uint8Array {\n    return this.getHashedMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Uint8Array {\n    return Legacy.getSenderPublicKey(this)\n  }\n\n  addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV: boolean = false\n  ): FeeMarketEIP1559Transaction {\n    r = toBytes(r)\n    s = toBytes(s)\n    const opts = { ...this.txOptions, common: this.common }\n\n    return FeeMarketEIP1559Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: convertV ? v - BIGINT_27 : v, // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bytesToBigInt(r),\n        s: bytesToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n    const baseJson = super.toJSON()\n\n    return {\n      ...baseJson,\n      chainId: bigIntToHex(this.chainId),\n      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(this.maxFeePerGas),\n      accessList: accessListJSON,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return Legacy.errorMsg(this, msg)\n  }\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  BIGINT_27,\n  MAX_INTEGER,\n  bigIntToHex,\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  equalsBytes,\n  toBytes,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\n\nimport { BaseTransaction } from './baseTransaction.js'\nimport * as EIP2718 from './capabilities/eip2718.js'\nimport * as EIP2930 from './capabilities/eip2930.js'\nimport * as Legacy from './capabilities/legacy.js'\nimport { TransactionType } from './types.js'\nimport { AccessLists, txTypeBytes } from './util.js'\n\nimport type {\n  AccessList,\n  AccessListBytes,\n  TxData as AllTypesTxData,\n  TxValuesArray as AllTypesTxValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types.js'\nimport type { Common } from '@ethereumjs/common'\n\ntype TxData = AllTypesTxData[TransactionType.AccessListEIP2930]\ntype TxValuesArray = AllTypesTxValuesArray[TransactionType.AccessListEIP2930]\n\n/**\n * Typed transaction with optional access lists\n *\n * - TransactionType: 1\n * - EIP: [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930)\n */\nexport class AccessListEIP2930Transaction extends BaseTransaction<TransactionType.AccessListEIP2930> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBytes\n  public readonly AccessListJSON: AccessList\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new AccessListEIP2930Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   */\n  public static fromSerializedTx(serialized: Uint8Array, opts: TxOptions = {}) {\n    if (\n      equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.AccessListEIP2930)) ===\n      false\n    ) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${\n          TransactionType.AccessListEIP2930\n        }, received: ${bytesToHex(serialized.subarray(0, 1))}`\n      )\n    }\n\n    const values = RLP.decode(Uint8Array.from(serialized.subarray(1)))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return AccessListEIP2930Transaction.fromValuesArray(values as TxValuesArray, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 8 && values.length !== 11) {\n      throw new Error(\n        'Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).'\n      )\n    }\n\n    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    const emptyAccessList: AccessList = []\n\n    return new AccessListEIP2930Transaction(\n      {\n        chainId: bytesToBigInt(chainId),\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? emptyAccessList,\n        v: v !== undefined ? bytesToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Uint8Array)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TransactionType.AccessListEIP2930 }, opts)\n    const { chainId, accessList, gasPrice } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    // EIP-2718 check is done in Common\n    if (!this.common.isActivatedEIP(2930)) {\n      throw new Error('EIP-2930 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.gasPrice = bytesToBigInt(toBytes(gasPrice))\n\n    this._validateCannotExceedMaxInteger({\n      gasPrice: this.gasPrice,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * gasPrice cannot exceed MAX_INTEGER')\n      throw new Error(msg)\n    }\n\n    EIP2718.validateYParity(this)\n    Legacy.validateHighS(this)\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  getEffectivePriorityFee(baseFee?: bigint): bigint {\n    return Legacy.getEffectivePriorityFee(this.gasPrice, baseFee)\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    return EIP2930.getDataFee(this)\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of the EIP-2930 transaction, in order.\n   *\n   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)]`\n   *\n   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Bytes values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBytes(this.chainId),\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.gasPrice),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n      this.accessList,\n      this.v !== undefined ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),\n      this.r !== undefined ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),\n      this.s !== undefined ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-2930 transaction.\n   *\n   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,\n   * signatureYParity (v), signatureR (r), signatureS (s)])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Uint8Array {\n    return EIP2718.serialize(this)\n  }\n\n  /**\n   * Returns the raw serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input\n   * ```\n   */\n  getMessageToSign(): Uint8Array {\n    return EIP2718.serialize(this, this.raw().slice(0, 8))\n  }\n\n  /**\n   * Returns the hashed serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   */\n  getHashedMessageToSign(): Uint8Array {\n    return EIP2718.getHashedMessageToSign(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Uint8Array {\n    return Legacy.hash(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Uint8Array {\n    return this.getHashedMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Uint8Array {\n    return Legacy.getSenderPublicKey(this)\n  }\n\n  addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV: boolean = false\n  ): AccessListEIP2930Transaction {\n    r = toBytes(r)\n    s = toBytes(s)\n    const opts = { ...this.txOptions, common: this.common }\n\n    return AccessListEIP2930Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: convertV ? v - BIGINT_27 : v, // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bytesToBigInt(r),\n        s: bytesToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n    const baseJson = super.toJSON()\n\n    return {\n      ...baseJson,\n      chainId: bigIntToHex(this.chainId),\n      gasPrice: bigIntToHex(this.gasPrice),\n      accessList: accessListJSON,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    // Keep ? for this.accessList since this otherwise causes Hardhat E2E tests to fail\n    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length ?? 0}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return Legacy.errorMsg(this, msg)\n  }\n}\n", "/** EIP4844 constants */\n\nexport const MAX_CALLDATA_SIZE = 16777216 // 2 ** 24\nexport const MAX_ACCESS_LIST_SIZE = 16777216 // 2 ** 24\nexport const MAX_VERSIONED_HASHES_LIST_SIZE = 16777216 // 2 ** 24\nexport const LIMIT_BLOBS_PER_TX = 6 // 786432 / 2^17 (`MAX_BLOB_GAS_PER_BLOCK` / `GAS_PER_BLOB`)\nexport const MAX_TX_WRAP_KZG_COMMITMENTS = 16777216 // 2 ** 24\nexport const FIELD_ELEMENTS_PER_BLOB = 4096 // This is also in the Common 4844 parameters but needed here since types can't access Common params\nexport const BYTES_PER_FIELD_ELEMENT = 32\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  BIGINT_0,\n  BIGINT_27,\n  MAX_INTEGER,\n  bigIntToHex,\n  bigIntToUnpaddedBytes,\n  blobsToCommitments,\n  blobsToProofs,\n  bytesToBigInt,\n  bytesToHex,\n  commitmentsToVersionedHashes,\n  computeVersionedHash,\n  equalsBytes,\n  getBlobs,\n  toBytes,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\n\nimport { BaseTransaction } from './baseTransaction.js'\nimport * as EIP1559 from './capabilities/eip1559.js'\nimport * as EIP2718 from './capabilities/eip2718.js'\nimport * as EIP2930 from './capabilities/eip2930.js'\nimport * as Legacy from './capabilities/legacy.js'\nimport { LIMIT_BLOBS_PER_TX } from './constants.js'\nimport { TransactionType } from './types.js'\nimport { AccessLists, txTypeBytes } from './util.js'\n\nimport type {\n  AccessList,\n  AccessListBytes,\n  TxData as AllTypesTxData,\n  TxValuesArray as AllTypesTxValuesArray,\n  BlobEIP4844NetworkValuesArray,\n  JsonBlobTxNetworkWrapper,\n  JsonTx,\n  TxOptions,\n} from './types.js'\nimport type { Common } from '@ethereumjs/common'\nimport type { Kzg } from '@ethereumjs/util'\n\ntype TxData = AllTypesTxData[TransactionType.BlobEIP4844]\ntype TxValuesArray = AllTypesTxValuesArray[TransactionType.BlobEIP4844]\n\nconst validateBlobTransactionNetworkWrapper = (\n  blobVersionedHashes: Uint8Array[],\n  blobs: Uint8Array[],\n  commitments: Uint8Array[],\n  kzgProofs: Uint8Array[],\n  version: number,\n  kzg: Kzg\n) => {\n  if (!(blobVersionedHashes.length === blobs.length && blobs.length === commitments.length)) {\n    throw new Error('Number of blobVersionedHashes, blobs, and commitments not all equal')\n  }\n  if (blobVersionedHashes.length === 0) {\n    throw new Error('Invalid transaction with empty blobs')\n  }\n\n  let isValid\n  try {\n    isValid = kzg.verifyBlobKzgProofBatch(blobs, commitments, kzgProofs)\n  } catch (error) {\n    throw new Error(`KZG verification of blobs fail with error=${error}`)\n  }\n  if (!isValid) {\n    throw new Error('KZG proof cannot be verified from blobs/commitments')\n  }\n\n  for (let x = 0; x < blobVersionedHashes.length; x++) {\n    const computedVersionedHash = computeVersionedHash(commitments[x], version)\n    if (!equalsBytes(computedVersionedHash, blobVersionedHashes[x])) {\n      throw new Error(`commitment for blob at index ${x} does not match versionedHash`)\n    }\n  }\n}\n\n/**\n * Typed transaction with a new gas fee market mechanism for transactions that include \"blobs\" of data\n *\n * - TransactionType: 3\n * - EIP: [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844)\n */\nexport class BlobEIP4844Transaction extends BaseTransaction<TransactionType.BlobEIP4844> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBytes\n  public readonly AccessListJSON: AccessList\n  public readonly maxPriorityFeePerGas: bigint\n  public readonly maxFeePerGas: bigint\n  public readonly maxFeePerBlobGas: bigint\n\n  public readonly common: Common\n  public blobVersionedHashes: Uint8Array[]\n  blobs?: Uint8Array[] // This property should only be populated when the transaction is in the \"Network Wrapper\" format\n  kzgCommitments?: Uint8Array[] // This property should only be populated when the transaction is in the \"Network Wrapper\" format\n  kzgProofs?: Uint8Array[] // This property should only be populated when the transaction is in the \"Network Wrapper\" format\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static constructors or factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TransactionType.BlobEIP4844 }, opts)\n    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerBlobGas } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    if (!this.common.isActivatedEIP(1559)) {\n      throw new Error('EIP-1559 not enabled on Common')\n    }\n\n    if (!this.common.isActivatedEIP(4844)) {\n      throw new Error('EIP-4844 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas))\n    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas))\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg(\n        'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'\n      )\n      throw new Error(msg)\n    }\n\n    this.maxFeePerBlobGas = bytesToBigInt(\n      toBytes((maxFeePerBlobGas ?? '') === '' ? '0x' : maxFeePerBlobGas)\n    )\n\n    this.blobVersionedHashes = (txData.blobVersionedHashes ?? []).map((vh) => toBytes(vh))\n    EIP2718.validateYParity(this)\n    Legacy.validateHighS(this)\n\n    for (const hash of this.blobVersionedHashes) {\n      if (hash.length !== 32) {\n        const msg = this._errorMsg('versioned hash is invalid length')\n        throw new Error(msg)\n      }\n      if (BigInt(hash[0]) !== this.common.param('sharding', 'blobCommitmentVersionKzg')) {\n        const msg = this._errorMsg('versioned hash does not start with KZG commitment version')\n        throw new Error(msg)\n      }\n    }\n    if (this.blobVersionedHashes.length > LIMIT_BLOBS_PER_TX) {\n      const msg = this._errorMsg(`tx can contain at most ${LIMIT_BLOBS_PER_TX} blobs`)\n      throw new Error(msg)\n    } else if (this.blobVersionedHashes.length === 0) {\n      const msg = this._errorMsg(`tx should contain at least one blob`)\n      throw new Error(msg)\n    }\n    if (this.to === undefined) {\n      const msg = this._errorMsg(\n        `tx should have a \"to\" field and cannot be used to create contracts`\n      )\n      throw new Error(msg)\n    }\n\n    this.blobs = txData.blobs?.map((blob) => toBytes(blob))\n    this.kzgCommitments = txData.kzgCommitments?.map((commitment) => toBytes(commitment))\n    this.kzgProofs = txData.kzgProofs?.map((proof) => toBytes(proof))\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  public static fromTxData(txData: TxData, opts?: TxOptions) {\n    if (opts?.common?.customCrypto?.kzg === undefined) {\n      throw new Error(\n        'A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx'\n      )\n    }\n    const kzg = opts!.common!.customCrypto!.kzg!\n    if (txData.blobsData !== undefined) {\n      if (txData.blobs !== undefined) {\n        throw new Error('cannot have both raw blobs data and encoded blobs in constructor')\n      }\n      if (txData.kzgCommitments !== undefined) {\n        throw new Error('cannot have both raw blobs data and KZG commitments in constructor')\n      }\n      if (txData.blobVersionedHashes !== undefined) {\n        throw new Error('cannot have both raw blobs data and versioned hashes in constructor')\n      }\n      if (txData.kzgProofs !== undefined) {\n        throw new Error('cannot have both raw blobs data and KZG proofs in constructor')\n      }\n      txData.blobs = getBlobs(txData.blobsData.reduce((acc, cur) => acc + cur))\n      txData.kzgCommitments = blobsToCommitments(kzg, txData.blobs as Uint8Array[])\n      txData.blobVersionedHashes = commitmentsToVersionedHashes(\n        txData.kzgCommitments as Uint8Array[]\n      )\n      txData.kzgProofs = blobsToProofs(\n        kzg,\n        txData.blobs as Uint8Array[],\n        txData.kzgCommitments as Uint8Array[]\n      )\n    }\n\n    return new BlobEIP4844Transaction(txData, opts)\n  }\n\n  /**\n   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas\n   * @param baseFee Base fee retrieved from block\n   */\n  getEffectivePriorityFee(baseFee: bigint): bigint {\n    return EIP1559.getEffectivePriorityFee(this, baseFee)\n  }\n\n  /**\n   * Creates the minimal representation of a blob transaction from the network wrapper version.\n   * The minimal representation is used when adding transactions to an execution payload/block\n   * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments\n   * @param opts - dictionary of {@link TxOptions}\n   * @returns the \"minimal\" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)\n   */\n  public static minimalFromNetworkWrapper(\n    txData: BlobEIP4844Transaction,\n    opts?: TxOptions\n  ): BlobEIP4844Transaction {\n    if (opts?.common?.customCrypto?.kzg === undefined) {\n      throw new Error(\n        'A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx'\n      )\n    }\n\n    const tx = BlobEIP4844Transaction.fromTxData(\n      {\n        ...txData,\n        ...{ blobs: undefined, kzgCommitments: undefined, kzgProofs: undefined },\n      },\n      opts\n    )\n    return tx\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x03 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data,\n   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s])`\n   */\n  public static fromSerializedTx(serialized: Uint8Array, opts: TxOptions = {}) {\n    if (opts.common?.customCrypto?.kzg === undefined) {\n      throw new Error(\n        'A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx'\n      )\n    }\n\n    if (\n      equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.BlobEIP4844)) === false\n    ) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${\n          TransactionType.BlobEIP4844\n        }, received: ${bytesToHex(serialized.subarray(0, 1))}`\n      )\n    }\n\n    const values = RLP.decode(serialized.subarray(1))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return BlobEIP4844Transaction.fromValuesArray(values as TxValuesArray, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    if (opts.common?.customCrypto?.kzg === undefined) {\n      throw new Error(\n        'A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx'\n      )\n    }\n\n    if (values.length !== 11 && values.length !== 14) {\n      throw new Error(\n        'Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).'\n      )\n    }\n\n    const [\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList,\n      maxFeePerBlobGas,\n      blobVersionedHashes,\n      v,\n      r,\n      s,\n    ] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      value,\n      maxFeePerBlobGas,\n      v,\n      r,\n      s,\n    })\n\n    return new BlobEIP4844Transaction(\n      {\n        chainId: bytesToBigInt(chainId),\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? [],\n        maxFeePerBlobGas,\n        blobVersionedHashes,\n        v: v !== undefined ? bytesToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Uint8Array)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)\n   * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper\n   * @param opts any TxOptions defined\n   * @returns a BlobEIP4844Transaction\n   */\n  public static fromSerializedBlobTxNetworkWrapper(\n    serialized: Uint8Array,\n    opts?: TxOptions\n  ): BlobEIP4844Transaction {\n    if (!opts || !opts.common) {\n      throw new Error('common instance required to validate versioned hashes')\n    }\n\n    if (opts.common?.customCrypto?.kzg === undefined) {\n      throw new Error(\n        'A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx'\n      )\n    }\n\n    if (\n      equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.BlobEIP4844)) === false\n    ) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${\n          TransactionType.BlobEIP4844\n        }, received: ${bytesToHex(serialized.subarray(0, 1))}`\n      )\n    }\n\n    // Validate network wrapper\n    const networkTxValues = RLP.decode(serialized.subarray(1))\n    if (networkTxValues.length !== 4) {\n      throw Error(`Expected 4 values in the deserialized network transaction`)\n    }\n    const [txValues, blobs, kzgCommitments, kzgProofs] =\n      networkTxValues as BlobEIP4844NetworkValuesArray\n\n    // Construct the tx but don't freeze yet, we will assign blobs etc once validated\n    const decodedTx = BlobEIP4844Transaction.fromValuesArray(txValues, { ...opts, freeze: false })\n    if (decodedTx.to === undefined) {\n      throw Error('BlobEIP4844Transaction can not be send without a valid `to`')\n    }\n\n    const version = Number(opts.common.param('sharding', 'blobCommitmentVersionKzg'))\n    validateBlobTransactionNetworkWrapper(\n      decodedTx.blobVersionedHashes,\n      blobs,\n      kzgCommitments,\n      kzgProofs,\n      version,\n      opts.common.customCrypto.kzg\n    )\n\n    // set the network blob data on the tx\n    decodedTx.blobs = blobs\n    decodedTx.kzgCommitments = kzgCommitments\n    decodedTx.kzgProofs = kzgProofs\n\n    // freeze the tx\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(decodedTx)\n    }\n\n    return decodedTx\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    return EIP2930.getDataFee(this)\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n  getUpfrontCost(baseFee: bigint = BIGINT_0): bigint {\n    return EIP1559.getUpfrontCost(this, baseFee)\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of the EIP-4844 transaction, in order.\n   *\n   * Format: [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data,\n   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s]`.\n   *\n   * Use {@link BlobEIP4844Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Bytes values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link BlobEIP4844Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBytes(this.chainId),\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),\n      bigIntToUnpaddedBytes(this.maxFeePerGas),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n      this.accessList,\n      bigIntToUnpaddedBytes(this.maxFeePerBlobGas),\n      this.blobVersionedHashes,\n      this.v !== undefined ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),\n      this.r !== undefined ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),\n      this.s !== undefined ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-4844 transaction.\n   *\n   * Format: `0x03 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s])`.\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Uint8Array {\n    return EIP2718.serialize(this)\n  }\n\n  /**\n   * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)\n   */\n  serializeNetworkWrapper(): Uint8Array {\n    if (\n      this.blobs === undefined ||\n      this.kzgCommitments === undefined ||\n      this.kzgProofs === undefined\n    ) {\n      throw new Error(\n        'cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided'\n      )\n    }\n\n    return EIP2718.serialize(this, [this.raw(), this.blobs, this.kzgCommitments, this.kzgProofs])\n  }\n\n  /**\n   * Returns the raw serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input\n   * ```\n   */\n  getMessageToSign(): Uint8Array {\n    return EIP2718.serialize(this, this.raw().slice(0, 11))\n  }\n\n  /**\n   * Returns the hashed serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   */\n  getHashedMessageToSign(): Uint8Array {\n    return EIP2718.getHashedMessageToSign(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link BlobEIP4844Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Uint8Array {\n    return Legacy.hash(this)\n  }\n\n  getMessageToVerifySignature(): Uint8Array {\n    return this.getHashedMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Uint8Array {\n    return Legacy.getSenderPublicKey(this)\n  }\n\n  /**\n   * Returns the EIP 4844 transaction network wrapper in JSON format similar to toJSON, including\n   * blobs, commitments, and proofs fields\n   * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper\n   * @param opts any TxOptions defined\n   * @returns JsonBlobTxNetworkWrapper with blobs, KZG commitments, and KZG proofs fields\n   */\n  public static networkWrapperToJson(\n    serialized: Uint8Array,\n    opts?: TxOptions\n  ): JsonBlobTxNetworkWrapper {\n    const tx = this.fromSerializedBlobTxNetworkWrapper(serialized, opts)\n\n    const accessListJSON = AccessLists.getAccessListJSON(tx.accessList)\n    const baseJson = tx.toJSON()\n\n    return {\n      ...baseJson,\n      chainId: bigIntToHex(tx.chainId),\n      maxPriorityFeePerGas: bigIntToHex(tx.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(tx.maxFeePerGas),\n      accessList: accessListJSON,\n      maxFeePerBlobGas: bigIntToHex(tx.maxFeePerBlobGas),\n      blobVersionedHashes: tx.blobVersionedHashes.map((hash) => bytesToHex(hash)),\n      blobs: tx.blobs!.map((bytes) => bytesToHex(bytes)),\n      kzgCommitments: tx.kzgCommitments!.map((bytes) => bytesToHex(bytes)),\n      kzgProofs: tx.kzgProofs!.map((bytes) => bytesToHex(bytes)),\n    }\n  }\n\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n    const baseJson = super.toJSON()\n\n    return {\n      ...baseJson,\n      chainId: bigIntToHex(this.chainId),\n      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(this.maxFeePerGas),\n      accessList: accessListJSON,\n      maxFeePerBlobGas: bigIntToHex(this.maxFeePerBlobGas),\n      blobVersionedHashes: this.blobVersionedHashes.map((hash) => bytesToHex(hash)),\n    }\n  }\n\n  addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV: boolean = false\n  ): BlobEIP4844Transaction {\n    r = toBytes(r)\n    s = toBytes(s)\n    const opts = { ...this.txOptions, common: this.common }\n\n    return BlobEIP4844Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        v: convertV ? v - BIGINT_27 : v, // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bytesToBigInt(r),\n        s: bytesToBigInt(s),\n        maxFeePerBlobGas: this.maxFeePerBlobGas,\n        blobVersionedHashes: this.blobVersionedHashes,\n        blobs: this.blobs,\n        kzgCommitments: this.kzgCommitments,\n        kzgProofs: this.kzgProofs,\n      },\n      opts\n    )\n  }\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return Legacy.errorMsg(this, msg)\n  }\n\n  /**\n   * @returns the number of blobs included with this transaction\n   */\n  public numBlobs(): number {\n    return this.blobVersionedHashes.length\n  }\n}\n", "import { AccessLists } from '../util.js'\n\nimport * as Legacy from './legacy.js'\n\nimport type { EIP7702CompatibleTx } from '../types.js'\n\n/**\n * The amount of gas paid for the data in this tx\n */\nexport function getDataFee(tx: EIP7702CompatibleTx): bigint {\n  const eip2930Cost = BigInt(AccessLists.getDataFeeEIP2930(tx.accessList, tx.common))\n  const eip7702Cost = BigInt(\n    tx.authorizationList.length * Number(tx.common.param('gasPrices', 'perAuthBaseCost'))\n  )\n  return Legacy.getDataFee(tx, eip2930Cost + eip7702Cost)\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  BIGINT_0,\n  BIGINT_27,\n  MAX_INTEGER,\n  bigIntToHex,\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  equalsBytes,\n  toBytes,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\n\nimport { BaseTransaction } from './baseTransaction.js'\nimport * as EIP1559 from './capabilities/eip1559.js'\nimport * as EIP2718 from './capabilities/eip2718.js'\nimport * as EIP7702 from './capabilities/eip7702.js'\nimport * as Legacy from './capabilities/legacy.js'\nimport { TransactionType } from './types.js'\nimport { AccessLists, AuthorizationLists, txTypeBytes } from './util.js'\n\nimport type {\n  AccessList,\n  AccessListBytes,\n  TxData as AllTypesTxData,\n  TxValuesArray as AllTypesTxValuesArray,\n  AuthorizationList,\n  AuthorizationListBytes,\n  JsonTx,\n  TxOptions,\n} from './types.js'\nimport type { Common } from '@ethereumjs/common'\n\ntype TxData = AllTypesTxData[TransactionType.EOACodeEIP7702]\ntype TxValuesArray = AllTypesTxValuesArray[TransactionType.EOACodeEIP7702]\n\n/**\n * Typed transaction with the ability to set codes on EOA accounts\n *\n * - TransactionType: 4\n * - EIP: [EIP-7702](https://github.com/ethereum/EIPs/blob/62419ca3f45375db00b04a368ea37c0bfb05386a/EIPS/eip-7702.md)\n */\nexport class EOACodeEIP7702Transaction extends BaseTransaction<TransactionType.EOACodeEIP7702> {\n  public readonly chainId: bigint\n  public readonly accessList: AccessListBytes\n  public readonly AccessListJSON: AccessList\n  public readonly authorizationList: AuthorizationListBytes\n  public readonly AuthorizationListJSON: AuthorizationList\n  public readonly maxPriorityFeePerGas: bigint\n  public readonly maxFeePerGas: bigint\n\n  public readonly common: Common\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, v, r, s }\n   *\n   * Notes:\n   * - `chainId` will be set automatically if not provided\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new EOACodeEIP7702Transaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `0x04 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS])`\n   */\n  public static fromSerializedTx(serialized: Uint8Array, opts: TxOptions = {}) {\n    if (\n      equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.EOACodeEIP7702)) === false\n    ) {\n      throw new Error(\n        `Invalid serialized tx input: not an EIP-7702 transaction (wrong tx type, expected: ${\n          TransactionType.EOACodeEIP7702\n        }, received: ${bytesToHex(serialized.subarray(0, 1))}`\n      )\n    }\n\n    const values = RLP.decode(serialized.subarray(1))\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input: must be array')\n    }\n\n    return EOACodeEIP7702Transaction.fromValuesArray(values as TxValuesArray, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, signatureYParity, signatureR, signatureS]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    if (values.length !== 10 && values.length !== 13) {\n      throw new Error(\n        'Invalid EIP-7702 transaction. Only expecting 10 values (for unsigned tx) or 13 values (for signed tx).'\n      )\n    }\n\n    const [\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gasLimit,\n      to,\n      value,\n      data,\n      accessList,\n      authorityList,\n      v,\n      r,\n      s,\n    ] = values\n\n    this._validateNotArray({ chainId, v })\n    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s })\n\n    return new EOACodeEIP7702Transaction(\n      {\n        chainId: bytesToBigInt(chainId),\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gasLimit,\n        to,\n        value,\n        data,\n        accessList: accessList ?? [],\n        authorizationList: authorityList ?? [],\n        v: v !== undefined ? bytesToBigInt(v) : undefined, // EIP2930 supports v's with value 0 (empty Uint8Array)\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TransactionType.EOACodeEIP7702 }, opts)\n    const { chainId, accessList, authorizationList, maxFeePerGas, maxPriorityFeePerGas } = txData\n\n    this.common = this._getCommon(opts.common, chainId)\n    this.chainId = this.common.chainId()\n\n    if (!this.common.isActivatedEIP(7702)) {\n      throw new Error('EIP-7702 not enabled on Common')\n    }\n    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930, 7702])\n\n    // Populate the access list fields\n    const accessListData = AccessLists.getAccessListData(accessList ?? [])\n    this.accessList = accessListData.accessList\n    this.AccessListJSON = accessListData.AccessListJSON\n    // Verify the access list format.\n    AccessLists.verifyAccessList(this.accessList)\n\n    // Populate the authority list fields\n    const authorizationListData = AuthorizationLists.getAuthorizationListData(\n      authorizationList ?? []\n    )\n    this.authorizationList = authorizationListData.authorizationList\n    this.AuthorizationListJSON = authorizationListData.AuthorizationListJSON\n    // Verify the authority list format.\n    AuthorizationLists.verifyAuthorizationList(this.authorizationList)\n\n    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas))\n    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas))\n\n    this._validateCannotExceedMaxInteger({\n      maxFeePerGas: this.maxFeePerGas,\n      maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n    })\n\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {\n      const msg = this._errorMsg('gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n      const msg = this._errorMsg(\n        'maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)'\n      )\n      throw new Error(msg)\n    }\n\n    EIP2718.validateYParity(this)\n    Legacy.validateHighS(this)\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    return EIP7702.getDataFee(this)\n  }\n\n  /**\n   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas\n   * @param baseFee Base fee retrieved from block\n   */\n  getEffectivePriorityFee(baseFee: bigint): bigint {\n    return EIP1559.getEffectivePriorityFee(this, baseFee)\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   * @param baseFee The base fee of the block (will be set to 0 if not provided)\n   */\n  getUpfrontCost(baseFee: bigint = BIGINT_0): bigint {\n    return EIP1559.getUpfrontCost(this, baseFee)\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of the EIP-7702 transaction, in order.\n   *\n   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, authorizationList, signatureYParity, signatureR, signatureS]`\n   *\n   * Use {@link EOACodeEIP7702Transaction.serialize} to add a transaction to a block\n   * with {@link Block.fromValuesArray}.\n   *\n   * For an unsigned tx this method uses the empty Bytes values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link EOACodeEIP7702Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBytes(this.chainId),\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),\n      bigIntToUnpaddedBytes(this.maxFeePerGas),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n      this.accessList,\n      this.authorizationList,\n      this.v !== undefined ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),\n      this.r !== undefined ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),\n      this.s !== undefined ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the EIP-7702 transaction.\n   *\n   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,\n   * accessList, authorizationList, signatureYParity, signatureR, signatureS])`\n   *\n   * Note that in contrast to the legacy tx serialization format this is not\n   * valid RLP any more due to the raw tx type preceding and concatenated to\n   * the RLP encoding of the values.\n   */\n  serialize(): Uint8Array {\n    return EIP2718.serialize(this)\n  }\n\n  /**\n   * Returns the raw serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   *\n   * ```javascript\n   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input\n   * ```\n   */\n  getMessageToSign(): Uint8Array {\n    return EIP2718.serialize(this, this.raw().slice(0, 10))\n  }\n\n  /**\n   * Returns the hashed serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: in contrast to the legacy tx the raw message format is already\n   * serialized and doesn't need to be RLP encoded any more.\n   */\n  getHashedMessageToSign(): Uint8Array {\n    return EIP2718.getHashedMessageToSign(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link EOACodeEIP7702Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  public hash(): Uint8Array {\n    return Legacy.hash(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  public getMessageToVerifySignature(): Uint8Array {\n    return this.getHashedMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  public getSenderPublicKey(): Uint8Array {\n    return Legacy.getSenderPublicKey(this)\n  }\n\n  addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV: boolean = false\n  ): EOACodeEIP7702Transaction {\n    r = toBytes(r)\n    s = toBytes(s)\n    const opts = { ...this.txOptions, common: this.common }\n\n    return EOACodeEIP7702Transaction.fromTxData(\n      {\n        chainId: this.chainId,\n        nonce: this.nonce,\n        maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n        maxFeePerGas: this.maxFeePerGas,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        accessList: this.accessList,\n        authorizationList: this.authorizationList,\n        v: convertV ? v - BIGINT_27 : v, // This looks extremely hacky: @ethereumjs/util actually adds 27 to the value, the recovery bit is either 0 or 1.\n        r: bytesToBigInt(r),\n        s: bytesToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction\n   */\n  toJSON(): JsonTx {\n    const accessListJSON = AccessLists.getAccessListJSON(this.accessList)\n    const baseJson = super.toJSON()\n\n    return {\n      ...baseJson,\n      chainId: bigIntToHex(this.chainId),\n      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),\n      maxFeePerGas: bigIntToHex(this.maxFeePerGas),\n      accessList: accessListJSON,\n      authorizationList: this.AuthorizationListJSON,\n    }\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return Legacy.errorMsg(this, msg)\n  }\n}\n", "import { RLP } from '@ethereumjs/rlp'\nimport {\n  BIGINT_2,\n  BIGINT_8,\n  MAX_INTEGER,\n  bigIntToHex,\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  toBytes,\n  unpadBytes,\n  validateNoLeadingZeroes,\n} from '@ethereumjs/util'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\n\nimport { BaseTransaction } from './baseTransaction.js'\nimport * as Legacy from './capabilities/legacy.js'\nimport { Capability, TransactionType } from './types.js'\n\nimport type {\n  TxData as AllTypesTxData,\n  TxValuesArray as AllTypesTxValuesArray,\n  JsonTx,\n  TxOptions,\n} from './types.js'\nimport type { Common } from '@ethereumjs/common'\n\ntype TxData = AllTypesTxData[TransactionType.Legacy]\ntype TxValuesArray = AllTypesTxValuesArray[TransactionType.Legacy]\n\nfunction meetsEIP155(_v: bigint, chainId: bigint) {\n  const v = Number(_v)\n  const chainIdDoubled = Number(chainId) * 2\n  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36\n}\n\n/**\n * An Ethereum non-typed (legacy) transaction\n */\nexport class LegacyTransaction extends BaseTransaction<TransactionType.Legacy> {\n  public readonly gasPrice: bigint\n\n  public readonly common: Common\n  private keccakFunction: (msg: Uint8Array) => Uint8Array\n\n  /**\n   * Instantiate a transaction from a data dictionary.\n   *\n   * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }\n   *\n   * Notes:\n   * - All parameters are optional and have some basic default values\n   */\n  public static fromTxData(txData: TxData, opts: TxOptions = {}) {\n    return new LegacyTransaction(txData, opts)\n  }\n\n  /**\n   * Instantiate a transaction from the serialized tx.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   */\n  public static fromSerializedTx(serialized: Uint8Array, opts: TxOptions = {}) {\n    const values = RLP.decode(serialized)\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized tx input. Must be array')\n    }\n\n    return this.fromValuesArray(values as TxValuesArray, opts)\n  }\n\n  /**\n   * Create a transaction from a values array.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   */\n  public static fromValuesArray(values: TxValuesArray, opts: TxOptions = {}) {\n    // If length is not 6, it has length 9. If v/r/s are empty Uint8Arrays, it is still an unsigned transaction\n    // This happens if you get the RLP data from `raw()`\n    if (values.length !== 6 && values.length !== 9) {\n      throw new Error(\n        'Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).'\n      )\n    }\n\n    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values\n\n    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s })\n\n    return new LegacyTransaction(\n      {\n        nonce,\n        gasPrice,\n        gasLimit,\n        to,\n        value,\n        data,\n        v,\n        r,\n        s,\n      },\n      opts\n    )\n  }\n\n  /**\n   * This constructor takes the values, validates them, assigns them and freezes the object.\n   *\n   * It is not recommended to use this constructor directly. Instead use\n   * the static factory methods to assist in creating a Transaction object from\n   * varying data types.\n   */\n  public constructor(txData: TxData, opts: TxOptions = {}) {\n    super({ ...txData, type: TransactionType.Legacy }, opts)\n\n    this.common = this._validateTxV(this.v, opts.common)\n    this.keccakFunction = this.common.customCrypto.keccak256 ?? keccak256\n    this.gasPrice = bytesToBigInt(toBytes(txData.gasPrice))\n\n    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {\n      const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)')\n      throw new Error(msg)\n    }\n\n    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice })\n    BaseTransaction._validateNotArray(txData)\n\n    if (this.common.gteHardfork('spuriousDragon')) {\n      if (!this.isSigned()) {\n        this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n      } else {\n        // EIP155 spec:\n        // If block.number >= 2,675,000 and v = CHAIN_ID * 2 + 35 or v = CHAIN_ID * 2 + 36\n        // then when computing the hash of a transaction for purposes of signing or recovering\n        // instead of hashing only the first six elements (i.e. nonce, gasprice, startgas, to, value, data)\n        // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0.\n        // v and chain ID meet EIP-155 conditions\n        if (meetsEIP155(this.v!, this.common.chainId())) {\n          this.activeCapabilities.push(Capability.EIP155ReplayProtection)\n        }\n      }\n    }\n\n    const freeze = opts?.freeze ?? true\n    if (freeze) {\n      Object.freeze(this)\n    }\n  }\n\n  getEffectivePriorityFee(baseFee?: bigint): bigint {\n    return Legacy.getEffectivePriorityFee(this.gasPrice, baseFee)\n  }\n\n  /**\n   * Returns a Uint8Array Array of the raw Bytes of the legacy transaction, in order.\n   *\n   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`\n   *\n   * For legacy txs this is also the correct format to add transactions\n   * to a block with {@link Block.fromValuesArray} (use the `serialize()` method\n   * for typed txs).\n   *\n   * For an unsigned tx this method returns the empty Bytes values\n   * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant\n   * representation have a look at {@link Transaction.getMessageToSign}.\n   */\n  raw(): TxValuesArray {\n    return [\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.gasPrice),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n      this.v !== undefined ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),\n      this.r !== undefined ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),\n      this.s !== undefined ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0),\n    ]\n  }\n\n  /**\n   * Returns the serialized encoding of the legacy transaction.\n   *\n   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`\n   *\n   * For an unsigned tx this method uses the empty Uint8Array values for the\n   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant\n   * representation for external signing use {@link Transaction.getMessageToSign}.\n   */\n  serialize(): Uint8Array {\n    return RLP.encode(this.raw())\n  }\n\n  /**\n   * Returns the raw unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   *\n   * Note: the raw message message format for the legacy tx is not RLP encoded\n   * and you might need to do yourself with:\n   *\n   * ```javascript\n   * import { RLP } from '@ethereumjs/rlp'\n   * const message = tx.getMessageToSign()\n   * const serializedMessage = RLP.encode(message)) // use this for the HW wallet input\n   * ```\n   */\n  getMessageToSign(): Uint8Array[] {\n    const message = [\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.gasPrice),\n      bigIntToUnpaddedBytes(this.gasLimit),\n      this.to !== undefined ? this.to.bytes : new Uint8Array(0),\n      bigIntToUnpaddedBytes(this.value),\n      this.data,\n    ]\n\n    if (this.supports(Capability.EIP155ReplayProtection)) {\n      message.push(bigIntToUnpaddedBytes(this.common.chainId()))\n      message.push(unpadBytes(toBytes(0)))\n      message.push(unpadBytes(toBytes(0)))\n    }\n\n    return message\n  }\n\n  /**\n   * Returns the hashed serialized unsigned tx, which can be used\n   * to sign the transaction (e.g. for sending to a hardware wallet).\n   */\n  getHashedMessageToSign() {\n    const message = this.getMessageToSign()\n    return this.keccakFunction(RLP.encode(message))\n  }\n\n  /**\n   * The amount of gas paid for the data in this tx\n   */\n  getDataFee(): bigint {\n    return Legacy.getDataFee(this)\n  }\n\n  /**\n   * The up front amount that an account must have for this transaction to be valid\n   */\n  getUpfrontCost(): bigint {\n    return this.gasLimit * this.gasPrice + this.value\n  }\n\n  /**\n   * Computes a sha3-256 hash of the serialized tx.\n   *\n   * This method can only be used for signed txs (it throws otherwise).\n   * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.\n   */\n  hash(): Uint8Array {\n    return Legacy.hash(this)\n  }\n\n  /**\n   * Computes a sha3-256 hash which can be used to verify the signature\n   */\n  getMessageToVerifySignature() {\n    if (!this.isSigned()) {\n      const msg = this._errorMsg('This transaction is not signed')\n      throw new Error(msg)\n    }\n    return this.getHashedMessageToSign()\n  }\n\n  /**\n   * Returns the public key of the sender\n   */\n  getSenderPublicKey(): Uint8Array {\n    return Legacy.getSenderPublicKey(this)\n  }\n\n  addSignature(\n    v: bigint,\n    r: Uint8Array | bigint,\n    s: Uint8Array | bigint,\n    convertV: boolean = false\n  ): LegacyTransaction {\n    r = toBytes(r)\n    s = toBytes(s)\n    if (convertV && this.supports(Capability.EIP155ReplayProtection)) {\n      v += this.common.chainId() * BIGINT_2 + BIGINT_8\n    }\n\n    const opts = { ...this.txOptions, common: this.common }\n\n    return LegacyTransaction.fromTxData(\n      {\n        nonce: this.nonce,\n        gasPrice: this.gasPrice,\n        gasLimit: this.gasLimit,\n        to: this.to,\n        value: this.value,\n        data: this.data,\n        v,\n        r: bytesToBigInt(r),\n        s: bytesToBigInt(s),\n      },\n      opts\n    )\n  }\n\n  /**\n   * Returns an object with the JSON representation of the transaction.\n   */\n  toJSON(): JsonTx {\n    const baseJson = super.toJSON()\n    return {\n      ...baseJson,\n      gasPrice: bigIntToHex(this.gasPrice),\n    }\n  }\n\n  /**\n   * Validates tx's `v` value\n   */\n  protected _validateTxV(_v?: bigint, common?: Common): Common {\n    let chainIdBigInt\n    const v = _v !== undefined ? Number(_v) : undefined\n    // Check for valid v values in the scope of a signed legacy tx\n    if (v !== undefined) {\n      // v is 1. not matching the EIP-155 chainId included case and...\n      // v is 2. not matching the classic v=27 or v=28 case\n      if (v < 37 && v !== 27 && v !== 28) {\n        throw new Error(\n          `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`\n        )\n      }\n    }\n\n    // No unsigned tx and EIP-155 activated and chain ID included\n    if (\n      v !== undefined &&\n      v !== 0 &&\n      (!common || common.gteHardfork('spuriousDragon')) &&\n      v !== 27 &&\n      v !== 28\n    ) {\n      if (common) {\n        if (!meetsEIP155(BigInt(v), common.chainId())) {\n          throw new Error(\n            `Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`\n          )\n        }\n      } else {\n        // Derive the original chain ID\n        let numSub\n        if ((v - 35) % 2 === 0) {\n          numSub = 35\n        } else {\n          numSub = 36\n        }\n        // Use derived chain ID to create a proper Common\n        chainIdBigInt = BigInt(v - numSub) / BIGINT_2\n      }\n    }\n    return this._getCommon(common, chainIdBigInt)\n  }\n\n  /**\n   * Return a compact error string representation of the object\n   */\n  public errorStr() {\n    let errorStr = this._getSharedErrorPostfix()\n    errorStr += ` gasPrice=${this.gasPrice}`\n    return errorStr\n  }\n\n  /**\n   * Internal helper function to create an annotated error message\n   *\n   * @param msg Base error message\n   * @hidden\n   */\n  protected _errorMsg(msg: string) {\n    return Legacy.errorMsg(this, msg)\n  }\n}\n", "import { TypeOutput, setLengthLeft, toBytes, toType } from '@ethereumjs/util'\n\nimport type { TypedTxData } from './types.js'\n\nexport const normalizeTxParams = (_txParams: any): TypedTxData => {\n  const txParams = Object.assign({}, _txParams)\n\n  txParams.gasLimit = toType(txParams.gasLimit ?? txParams.gas, TypeOutput.BigInt)\n  txParams.data = txParams.data === undefined ? txParams.input : txParams.data\n\n  // check and convert gasPrice and value params\n  txParams.gasPrice = txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined\n  txParams.value = txParams.value !== undefined ? BigInt(txParams.value) : undefined\n\n  // strict byte length checking\n  txParams.to =\n    txParams.to !== null && txParams.to !== undefined\n      ? setLengthLeft(toBytes(txParams.to), 20)\n      : null\n\n  // Normalize the v/r/s values. If RPC returns '0x0', ensure v/r/s are set to `undefined` in the tx.\n  // If this is not done, then the transaction creation will throw, because `v` is `0`.\n  // Note: this still means that `isSigned` will return `false`.\n  // v/r/s values are `0x0` on networks like Optimism, where the tx is a system tx.\n  // For instance: https://optimistic.etherscan.io/tx/0xf4304cb09b3f58a8e5d20fec5f393c96ccffe0269aaf632cb2be7a8a0f0c91cc\n\n  txParams.v = txParams.v === '0x0' ? '0x' : txParams.v\n  txParams.r = txParams.r === '0x0' ? '0x' : txParams.r\n  txParams.s = txParams.s === '0x0' ? '0x' : txParams.s\n\n  if (txParams.v !== '0x' || txParams.r !== '0x' || txParams.s !== '0x') {\n    txParams.v = toType(txParams.v, TypeOutput.BigInt)\n  }\n\n  return txParams\n}\n", "import { fetchFromProvider, getProvider } from '@ethereumjs/util'\n\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction.js'\nimport { AccessListEIP2930Transaction } from './eip2930Transaction.js'\nimport { BlobEIP4844Transaction } from './eip4844Transaction.js'\nimport { EOACodeEIP7702Transaction } from './eip7702Transaction.js'\nimport { normalizeTxParams } from './fromRpc.js'\nimport { LegacyTransaction } from './legacyTransaction.js'\nimport {\n  TransactionType,\n  isAccessListEIP2930TxData,\n  isBlobEIP4844TxData,\n  isEOACodeEIP7702TxData,\n  isFeeMarketEIP1559TxData,\n  isLegacyTxData,\n} from './types.js'\n\nimport type { Transaction, TxData, TxOptions, TypedTxData } from './types.js'\nimport type { EthersProvider } from '@ethereumjs/util'\n\nexport class TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  private constructor() {}\n\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  public static fromTxData<T extends TransactionType>(\n    txData: TypedTxData,\n    txOptions: TxOptions = {}\n  ): Transaction[T] {\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return LegacyTransaction.fromTxData(txData, txOptions) as Transaction[T]\n    } else {\n      if (isLegacyTxData(txData)) {\n        return LegacyTransaction.fromTxData(txData, txOptions) as Transaction[T]\n      } else if (isAccessListEIP2930TxData(txData)) {\n        return AccessListEIP2930Transaction.fromTxData(txData, txOptions) as Transaction[T]\n      } else if (isFeeMarketEIP1559TxData(txData)) {\n        return FeeMarketEIP1559Transaction.fromTxData(txData, txOptions) as Transaction[T]\n      } else if (isBlobEIP4844TxData(txData)) {\n        return BlobEIP4844Transaction.fromTxData(txData, txOptions) as Transaction[T]\n      } else if (isEOACodeEIP7702TxData(txData)) {\n        return EOACodeEIP7702Transaction.fromTxData(txData, txOptions) as Transaction[T]\n      } else {\n        throw new Error(`Tx instantiation with type ${(txData as TypedTxData)?.type} not supported`)\n      }\n    }\n  }\n\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Uint8Array\n   * @param txOptions - The transaction options\n   */\n  public static fromSerializedData<T extends TransactionType>(\n    data: Uint8Array,\n    txOptions: TxOptions = {}\n  ): Transaction[T] {\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      switch (data[0]) {\n        case TransactionType.AccessListEIP2930:\n          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions) as Transaction[T]\n        case TransactionType.FeeMarketEIP1559:\n          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions) as Transaction[T]\n        case TransactionType.BlobEIP4844:\n          return BlobEIP4844Transaction.fromSerializedTx(data, txOptions) as Transaction[T]\n        case TransactionType.EOACodeEIP7702:\n          return EOACodeEIP7702Transaction.fromSerializedTx(data, txOptions) as Transaction[T]\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`)\n      }\n    } else {\n      return LegacyTransaction.fromSerializedTx(data, txOptions) as Transaction[T]\n    }\n  }\n\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Uint8Array (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Uint8Array[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Uint8Array or Uint8Array[]\n   * @param txOptions - The transaction options\n   */\n  public static fromBlockBodyData(data: Uint8Array | Uint8Array[], txOptions: TxOptions = {}) {\n    if (data instanceof Uint8Array) {\n      return this.fromSerializedData(data, txOptions)\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return LegacyTransaction.fromValuesArray(data, txOptions)\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input')\n    }\n  }\n\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - a url string for a JSON-RPC provider or an Ethers JsonRPCProvider object\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  public static async fromJsonRpcProvider(\n    provider: string | EthersProvider,\n    txHash: string,\n    txOptions?: TxOptions\n  ) {\n    const prov = getProvider(provider)\n    const txData = await fetchFromProvider(prov, {\n      method: 'eth_getTransactionByHash',\n      params: [txHash],\n    })\n    if (txData === null) {\n      throw new Error('No data returned from provider')\n    }\n    return TransactionFactory.fromRPC(txData, txOptions)\n  }\n\n  /**\n   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`\n   * Note that this normalizes some of the parameters\n   * @param txData The RPC-encoded data\n   * @param txOptions The transaction options\n   * @returns\n   */\n  public static async fromRPC<T extends TransactionType>(\n    txData: TxData[T],\n    txOptions: TxOptions = {}\n  ): Promise<Transaction[T]> {\n    return TransactionFactory.fromTxData(normalizeTxParams(txData), txOptions)\n  }\n}\n"],
  "mappings": "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",
  "names": ["concatBytes", "toBytes", "bytesToHex", "hexToBytes", "Capability", "TransactionType", "hash", "getEffectivePriorityFee", "getDataFee", "getDataFee", "getEffectivePriorityFee", "getDataFee", "hash", "getDataFee", "getDataFee", "getDataFee", "getEffectivePriorityFee"]
}
