{
  "version": 3,
  "sources": ["../../deepmerge/dist/cjs.js", "../../async-mutex/index.mjs", "../../@toruslabs/ethereum-controllers/dist/ethereumControllers.esm.js", "../../fast-json-patch/module/core.mjs", "../../fast-json-patch/module/helpers.mjs", "../../fast-json-patch/module/duplex.mjs", "../../fast-json-patch/index.mjs", "../../@web3auth/ws-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js", "../../@web3auth/ws-embed/dist/embed.esm.js", "../../@web3auth/wallet-services-plugin/dist/walletServicesPlugin.esm.js"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { CHAIN_NAMESPACES, BaseController, randomId, TransactionStatus, TRANSACTION_TYPES, formatSmallNumbers, addressSlicer, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, significantDigits, BaseBlockTracker, timeout, BaseCurrencyController, cloneDeep, BaseKeyringController, PROVIDER_JRPC_METHODS, createFetchMiddleware, createInflightCacheMiddleware, createSwappableProxy, createEventEmitterProxy, BasePreferencesController, isUnauthorizedError, TX_EVENTS, BaseTransactionStateManager, omitBy, transactionMatchesNetwork as transactionMatchesNetwork$1, pickBy } from '@toruslabs/base-controllers';\nimport { Mutex } from 'async-mutex';\nimport { BrowserProvider, toQuantity, Contract, Interface, isHexString as isHexString$1, JsonRpcProvider, keccak256 } from 'ethers';\nimport log from 'loglevel';\nimport { isHexString, addHexPrefix, isValidAddress, stripHexPrefix, toChecksumAddress, bytesToHex, privateToPublic, privateToAddress, ecsign, bigIntToBytes } from '@ethereumjs/util';\nimport BigNumber from 'bignumber.js';\nimport { rpcErrors, providerErrors, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware, providerFromMiddleware, JRPCEngine, providerFromEngine, SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { get } from '@toruslabs/http-helpers';\nimport _objectDestructuringEmpty from '@babel/runtime/helpers/objectDestructuringEmpty';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport BN, { BN as BN$1 } from 'bn.js';\nimport { concatSig, personalSign, signTypedData, getEncryptionPublicKey, decrypt, typedSignatureHash, TYPED_MESSAGE_SCHEMA, SignTypedDataVersion } from '@metamask/eth-sig-util';\nimport stringify from 'fast-safe-stringify';\nimport deepmerge from 'deepmerge';\nimport jsonDiffer from 'fast-json-patch';\n\nconst erc20Abi = [{\n  constant: true,\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_spender\",\n    type: \"address\"\n  }, {\n    name: \"_value\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [{\n    name: \"success\",\n    type: \"bool\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_from\",\n    type: \"address\"\n  }, {\n    name: \"_to\",\n    type: \"address\"\n  }, {\n    name: \"_value\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [{\n    name: \"success\",\n    type: \"bool\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"decimals\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_owner\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"balance\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_to\",\n    type: \"address\"\n  }, {\n    name: \"_value\",\n    type: \"uint256\"\n  }],\n  name: \"transfer\",\n  outputs: [{\n    name: \"success\",\n    type: \"bool\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_spender\",\n    type: \"address\"\n  }, {\n    name: \"_value\",\n    type: \"uint256\"\n  }, {\n    name: \"_extraData\",\n    type: \"bytes\"\n  }],\n  name: \"approveAndCall\",\n  outputs: [{\n    name: \"success\",\n    type: \"bool\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_owner\",\n    type: \"address\"\n  }, {\n    name: \"_spender\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    name: \"remaining\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"_initialAmount\",\n    type: \"uint256\"\n  }, {\n    name: \"_tokenName\",\n    type: \"string\"\n  }, {\n    name: \"_decimalUnits\",\n    type: \"uint8\"\n  }, {\n    name: \"_tokenSymbol\",\n    type: \"string\"\n  }],\n  type: \"constructor\"\n}, {\n  payable: false,\n  type: \"fallback\"\n}];\nconst erc721Abi = [{\n  constant: true,\n  inputs: [{\n    name: \"interfaceID\",\n    type: \"bytes4\"\n  }],\n  name: \"supportsInterface\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    name: \"_name\",\n    type: \"string\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"getApproved\",\n  outputs: [{\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_approved\",\n    type: \"address\"\n  }, {\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [],\n  payable: true,\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_from\",\n    type: \"address\"\n  }, {\n    name: \"_to\",\n    type: \"address\"\n  }, {\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [],\n  payable: true,\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_owner\",\n    type: \"address\"\n  }, {\n    name: \"_index\",\n    type: \"uint256\"\n  }],\n  name: \"tokenOfOwnerByIndex\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_from\",\n    type: \"address\"\n  }, {\n    name: \"_to\",\n    type: \"address\"\n  }, {\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"safeTransferFrom\",\n  outputs: [],\n  payable: true,\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_index\",\n    type: \"uint256\"\n  }],\n  name: \"tokenByIndex\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"ownerOf\",\n  outputs: [{\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_owner\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    name: \"_symbol\",\n    type: \"string\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_tokenId\",\n    type: \"uint256\"\n  }],\n  name: \"tokenURI\",\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst erc1155Abi = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"_owner\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"_id\",\n    type: \"uint256\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address[]\",\n    name: \"_owners\",\n    type: \"address[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"_ids\",\n    type: \"uint256[]\"\n  }],\n  name: \"balanceOfBatch\",\n  outputs: [{\n    internalType: \"uint256[]\",\n    name: \"\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_operator\",\n    type: \"address\"\n  }],\n  name: \"isApprovedForAll\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"isOperator\",\n    type: \"bool\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"_to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"_id\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"_amount\",\n    type: \"uint256\"\n  }, {\n    internalType: \"bytes\",\n    name: \"_data\",\n    type: \"bytes\"\n  }],\n  name: \"safeTransferFrom\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"_operator\",\n    type: \"address\"\n  }, {\n    internalType: \"bool\",\n    name: \"_approved\",\n    type: \"bool\"\n  }],\n  name: \"setApprovalForAll\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"bytes4\",\n    name: \"_interfaceID\",\n    type: \"bytes4\"\n  }],\n  name: \"supportsInterface\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"_id\",\n    type: \"uint256\"\n  }],\n  name: \"uri\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst singleBalanceCheckerAbi = [{\n  payable: true,\n  stateMutability: \"payable\",\n  type: \"fallback\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"user\",\n    type: \"address\"\n  }, {\n    name: \"token\",\n    type: \"address\"\n  }],\n  name: \"tokenBalance\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"users\",\n    type: \"address[]\"\n  }, {\n    name: \"tokens\",\n    type: \"address[]\"\n  }],\n  name: \"balances\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256[]\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}];\n\nconst LOCALHOST = \"localhost\";\nconst CONTRACT_TYPE_ETH = \"eth\";\nconst CONTRACT_TYPE_ERC20 = \"erc20\";\nconst CONTRACT_TYPE_ERC721 = \"erc721\";\nconst CONTRACT_TYPE_ERC1155 = \"erc1155\";\nconst ERC1155_INTERFACE_ID = \"0xd9b67a26\";\nconst ERC721_INTERFACE_ID = \"0x80ac58cd\";\nconst ERC721_METADATA_INTERFACE_ID = \"0x5b5e139f\";\nconst ERC721_ENUMERABLE_INTERFACE_ID = \"0x780e9d63\";\nconst MAINNET_CHAIN_ID = \"0x1\";\nconst POLYGON_CHAIN_ID = \"0x89\";\nconst BSC_MAINNET_CHAIN_ID = \"0x38\";\nconst AVALANCHE_MAINNET_CHAIN_ID = \"0xa86a\";\nconst XDAI_CHAIN_ID = \"0x64\";\nconst ARBITRUM_MAINNET_CHAIN_ID = \"0xa4b1\";\nconst OPTIMISM_MAINNET_CHAIN_ID = \"0xa\";\nconst CELO_MAINNET_CHAIN_ID = \"0xa4ec\";\nconst BASE_CHAIN_ID = \"0x2105\";\nconst SEPOLIA_CHAIN_ID = \"0xaa36a7\";\nconst POLYGON_AMOY_CHAIN_ID = \"0x13882\";\nconst BSC_TESTNET_CHAIN_ID = \"0x61\";\nconst AVALANCHE_TESTNET_CHAIN_ID = \"0xa869\";\nconst ARBITRUM_TESTNET_CHAIN_ID = \"0x66eee\";\nconst OPTIMISM_TESTNET_CHAIN_ID = \"0xaa37dc\";\nconst BASE_TESTNET_CHAIN_ID = \"0x14a34\";\nconst INFURA_KEY = process.env.VITE_APP_INFURA_PROJECT_KEY;\nconst SUPPORTED_NETWORKS = {\n  [MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://etherscan.io\",\n    chainId: MAINNET_CHAIN_ID,\n    displayName: \"Ethereum\",\n    logo: \"eth.svg\",\n    rpcTarget: `https://mainnet.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\"\n  },\n  [POLYGON_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://polygonscan.com\",\n    chainId: POLYGON_CHAIN_ID,\n    displayName: \"Polygon\",\n    logo: \"polygon.svg\",\n    rpcTarget: `https://polygon-mainnet.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"MATIC\",\n    tickerName: \"Matic Network Token\"\n  },\n  [BSC_MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://bscscan.com\",\n    chainId: BSC_MAINNET_CHAIN_ID,\n    displayName: \"Binance Smart Chain (BSC)\",\n    logo: \"bnb_logo.svg\",\n    rpcTarget: `https://bsc-dataseed.binance.org`,\n    ticker: \"BNB\",\n    tickerName: \"Binance Coin\"\n  },\n  [AVALANCHE_MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://snowtrace.io\",\n    chainId: AVALANCHE_MAINNET_CHAIN_ID,\n    displayName: \"Avalanche\",\n    logo: \"avax.svg\",\n    rpcTarget: `https://api.avax.network/ext/bc/C/rpc`,\n    ticker: \"AVAX\",\n    tickerName: \"Avalanche\"\n  },\n  [OPTIMISM_MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://optimistic.etherscan.io\",\n    chainId: OPTIMISM_MAINNET_CHAIN_ID,\n    displayName: \"Optimism\",\n    logo: \"optimism.svg\",\n    rpcTarget: `https://optimism-mainnet.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\"\n  },\n  [CELO_MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://explorer.celo.org\",\n    chainId: CELO_MAINNET_CHAIN_ID,\n    displayName: \"Celo Mainnet\",\n    logo: \"celo.svg\",\n    rpcTarget: `https://celo-mainnet.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"CELO\",\n    tickerName: \"Celo\"\n  },\n  [ARBITRUM_MAINNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://arbiscan.io\",\n    chainId: ARBITRUM_MAINNET_CHAIN_ID,\n    displayName: \"Arbitrum One\",\n    logo: \"arbitrum.svg\",\n    rpcTarget: `https://arbitrum-mainnet.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\"\n  },\n  [XDAI_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://gnosis.blockscout.com\",\n    chainId: XDAI_CHAIN_ID,\n    displayName: \"xDai\",\n    logo: \"xDai.svg\",\n    rpcTarget: `https://rpc.gnosischain.com`,\n    ticker: \"DAI\",\n    tickerName: \"xDai Token\"\n  },\n  [BASE_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://basescan.org\",\n    chainId: BASE_CHAIN_ID,\n    displayName: \"Base\",\n    logo: \"base.svg\",\n    rpcTarget: `https://mainnet.base.org`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\"\n  },\n  [SEPOLIA_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://sepolia.etherscan.io\",\n    chainId: SEPOLIA_CHAIN_ID,\n    displayName: \"Sepolia Test Network\",\n    logo: \"eth.svg\",\n    rpcTarget: `https://sepolia.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\",\n    isTestnet: true\n  },\n  [POLYGON_AMOY_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://amoy.polygonscan.com\",\n    chainId: POLYGON_AMOY_CHAIN_ID,\n    displayName: \"Polygon Amoy\",\n    logo: \"polygon.svg\",\n    rpcTarget: `https://polygon-amoy.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"MATIC\",\n    tickerName: \"Matic Network Token\",\n    isTestnet: true\n  },\n  [BSC_TESTNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://testnet.bscscan.com\",\n    chainId: BSC_TESTNET_CHAIN_ID,\n    displayName: \"Binance Smart Chain Testnet\",\n    logo: \"bnb_logo.svg\",\n    rpcTarget: `https://data-seed-prebsc-1-s1.binance.org:8545`,\n    ticker: \"BNB\",\n    tickerName: \"Binance Coin\",\n    isTestnet: true\n  },\n  [AVALANCHE_TESTNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://testnet.snowtrace.io\",\n    chainId: AVALANCHE_TESTNET_CHAIN_ID,\n    displayName: \"Avalanche Testnet C-Chain\",\n    logo: \"avax.svg\",\n    rpcTarget: `https://api.avax-test.network/ext/bc/C/rpc`,\n    ticker: \"AVAX\",\n    tickerName: \"Avalanche\",\n    isTestnet: true\n  },\n  [ARBITRUM_TESTNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://sepolia.arbiscan.io\",\n    chainId: ARBITRUM_TESTNET_CHAIN_ID,\n    displayName: \"Arbitrum Sepolia\",\n    logo: \"arbitrum.svg\",\n    rpcTarget: `https://arbitrum-sepolia.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\",\n    isTestnet: true\n  },\n  [OPTIMISM_TESTNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://sepolia-optimistic.etherscan.io\",\n    chainId: OPTIMISM_TESTNET_CHAIN_ID,\n    displayName: \"Optimism Sepolia\",\n    logo: \"optimism.svg\",\n    rpcTarget: `https://optimism-sepolia.infura.io/v3/${INFURA_KEY}`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\",\n    isTestnet: true\n  },\n  [BASE_TESTNET_CHAIN_ID]: {\n    chainNamespace: CHAIN_NAMESPACES.EIP155,\n    decimals: 18,\n    blockExplorerUrl: \"https://sepolia.basescan.org\",\n    chainId: BASE_TESTNET_CHAIN_ID,\n    displayName: \"Base Sepolia\",\n    logo: \"base.svg\",\n    rpcTarget: `https://sepolia.base.org`,\n    ticker: \"ETH\",\n    tickerName: \"Ethereum\",\n    isTestnet: true\n  }\n};\nconst METHOD_TYPES = {\n  GET_ACCOUNTS: \"eth_accounts\",\n  ETH_TRANSACTION: \"eth_sendTransaction\",\n  ETH_REQUEST_ACCOUNTS: \"eth_requestAccounts\",\n  ETH_SEND_RAW_TRANSACTION: \"eth_sendRawTransaction\",\n  ETH_SIGN: \"eth_sign\",\n  ETH_SIGN_TYPED_DATA: \"eth_signTypedData\",\n  ETH_SIGN_TYPED_DATA_V3: \"eth_signTypedData_v3\",\n  ETH_SIGN_TYPED_DATA_V4: \"eth_signTypedData_v4\",\n  PERSONAL_SIGN: \"personal_sign\",\n  ETH_GET_TRANSACTION_COUNT: \"eth_getTransactionCount\",\n  ETH_GET_TRANSACTION_BY_HASH: \"eth_getTransactionByHash\",\n  ETH_GET_ENCRYPTION_PUBLIC_KEY: \"eth_getEncryptionPublicKey\",\n  ETH_DECRYPT: \"eth_decrypt\",\n  ETH_GET_TRANSACTION_RECEIPT: \"eth_getTransactionReceipt\",\n  WATCH_ASSET: \"wallet_watchAsset\",\n  ETH_GET_BLOCK_BY_HASH: \"eth_getBlockByHash\",\n  ETH_GET_CODE: \"eth_getCode\",\n  ETH_GET_GAS_PRICE: \"eth_gasPrice\",\n  SWITCH_CHAIN: \"wallet_switchEthereumChain\",\n  ADD_CHAIN: \"wallet_addEthereumChain\"\n};\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  // Fee Market describes the way gas is set after the london hardfork, and was\n  // defined by EIP-1559.\n  FEE_MARKET: \"fee-market\",\n  // Legacy describes gasPrice estimates from before london hardfork, when the\n  // user is connected to mainnet and are presented with fast/average/slow\n  // estimate levels to choose from.\n  LEGACY: \"legacy\",\n  // EthGasPrice describes a gasPrice estimate received from eth_gasPrice. Post\n  // london this value should only be used for legacy type transactions when on\n  // networks that support EIP-1559. This type of estimate is the most accurate\n  // to display on custom networks that don't support EIP-1559.\n  ETH_GASPRICE: \"eth_gasPrice\",\n  // NoEstimate describes the state of the controller before receiving its first\n  // estimate.\n  NONE: \"none\"\n};\n\n// https://help.optimism.io/hc/en-us/articles/4411895794715-Transaction-fees\nconst CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {\n  [OPTIMISM_MAINNET_CHAIN_ID]: 1,\n  [OPTIMISM_TESTNET_CHAIN_ID]: 1\n};\nconst OLD_ERC721_LIST = {\n  \"0x06012c8cf97bead5deae237070f9587f8e7a266d\": {\n    name: \"Cryptokitties\",\n    logo: \"dapp-cryptokitty.svg\",\n    erc20: true,\n    symbol: \"CK\",\n    decimals: 0\n  }\n};\nconst TEST_CHAINS = [SEPOLIA_CHAIN_ID];\nconst ETHERSCAN_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, CELO_MAINNET_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];\nconst SIMPLEHASH_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, CELO_MAINNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];\nconst COINGECKO_SUPPORTED_CURRENCIES = new Set([\"btc\", \"eth\", \"ltc\", \"bch\", \"bnb\", \"eos\", \"xrp\", \"xlm\", \"link\", \"dot\", \"yfi\", \"usd\", \"aed\", \"ars\", \"aud\", \"bdt\", \"bhd\", \"bmd\", \"brl\", \"cad\", \"chf\", \"clp\", \"cny\", \"czk\", \"dkk\", \"eur\", \"gbp\", \"hkd\", \"huf\", \"idr\", \"ils\", \"inr\", \"jpy\", \"krw\", \"kwd\", \"lkr\", \"mmk\", \"mxn\", \"myr\", \"ngn\", \"nok\", \"nzd\", \"php\", \"pkr\", \"pln\", \"rub\", \"sar\", \"sek\", \"sgd\", \"thb\", \"try\", \"twd\", \"uah\", \"vef\", \"vnd\", \"zar\", \"xdr\", \"xag\", \"xau\", \"bits\", \"sats\"]);\nconst COINGECKO_PLATFORMS_CHAIN_CODE_MAP = {\n  [POLYGON_CHAIN_ID]: {\n    platform: \"polygon-pos\",\n    currency: \"matic\"\n  },\n  [BSC_MAINNET_CHAIN_ID]: {\n    platform: \"binance-smart-chain\",\n    currency: \"bnb\"\n  },\n  [MAINNET_CHAIN_ID]: {\n    platform: \"ethereum\",\n    currency: \"eth\"\n  },\n  [ARBITRUM_MAINNET_CHAIN_ID]: {\n    platform: \"arbitrum-one\",\n    currency: \"eth\"\n  },\n  [OPTIMISM_MAINNET_CHAIN_ID]: {\n    platform: \"optimistic-ethereum\",\n    currency: \"eth\"\n  },\n  [CELO_MAINNET_CHAIN_ID]: {\n    platform: \"celo\",\n    currency: \"celo\"\n  },\n  [XDAI_CHAIN_ID]: {\n    platform: \"xdai\",\n    currency: \"xDAI\"\n  },\n  [AVALANCHE_MAINNET_CHAIN_ID]: {\n    platform: \"avalanche\",\n    currency: \"avax\"\n  },\n  [BASE_CHAIN_ID]: {\n    platform: \"base\",\n    currency: \"eth\"\n  }\n};\nconst MessageStatus = {\n  UNAPPROVED: \"unapproved\",\n  SIGNED: \"signed\",\n  PENDING: \"pending\",\n  APPROVED: \"approved\",\n  REJECTED: \"rejected\",\n  FAILED: \"failed\"\n};\nconst MESSAGE_EVENTS = {\n  UNAPPROVED_MESSAGE: \"unapprovedMessage\"\n};\n\nconst SINGLE_CALL_BALANCES_ADDRESSES = {\n  [MAINNET_CHAIN_ID]: \"0xb1f8e55c7f64d203c1400b9d8555d050f94adf39\",\n  // [SEPOLIA_CHAIN_ID]: SINGLE_CALL_BALANCES_ADDRESS_SEPOLIA,\n  // [FANTOM_CHAIN_ID]: \"0x07f697424ABe762bB808c109860c04eA488ff92B\",\n  [BSC_MAINNET_CHAIN_ID]: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\",\n  [OPTIMISM_MAINNET_CHAIN_ID]: \"0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC\",\n  [POLYGON_CHAIN_ID]: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\",\n  [AVALANCHE_MAINNET_CHAIN_ID]: \"0xD023D153a0DFa485130ECFdE2FAA7e612EF94818\",\n  [ARBITRUM_MAINNET_CHAIN_ID]: \"0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c\"\n};\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\n/**\n * Tracks accounts based on blocks.\n * If block tracker provides latest block, we query accounts from it.\n * Preferences state changes also retrigger accounts update.\n * Network state changes also retrigger accounts update.\n */\nclass AccountTrackerController extends BaseController {\n  constructor({\n    config,\n    state,\n    provider,\n    blockTracker,\n    getIdentities,\n    onPreferencesStateChange,\n    getCurrentChainId\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"blockTracker\", void 0);\n    _defineProperty(this, \"mutex\", new Mutex());\n    _defineProperty(this, \"ethersProvider\", void 0);\n    _defineProperty(this, \"getIdentities\", void 0);\n    _defineProperty(this, \"getCurrentChainId\", void 0);\n    this.defaultState = {\n      accounts: {}\n    };\n    this.initialize();\n    this.provider = provider;\n    this.blockTracker = blockTracker;\n    this.ethersProvider = new BrowserProvider(this.provider, \"any\");\n    this.getIdentities = getIdentities;\n    this.getCurrentChainId = getCurrentChainId;\n    onPreferencesStateChange(() => {\n      const refreshNeeded = this.syncAccounts();\n      if (refreshNeeded) {\n        log.info(\"onPreferencesStateChange called\");\n        this.refresh();\n      }\n    });\n    this.blockTrackerListener = this.blockTrackerListener.bind(this);\n  }\n  blockTrackerListener() {\n    this.refresh();\n  }\n  startPolling() {\n    this.stopPolling();\n    // Initiate block tracker internal tracking.\n    if (Object.keys(this.state.accounts).length > 0) {\n      // Adding this listener on block tracker triggers it to start polling.\n      this.blockTracker.on(\"latest\", this.blockTrackerListener);\n    }\n  }\n  stopPolling() {\n    this.blockTracker.removeListener(\"latest\", this.blockTrackerListener);\n  }\n  syncAccounts() {\n    const {\n      accounts\n    } = this.state;\n    const addresses = Object.keys(this.getIdentities());\n    const existing = Object.keys(accounts);\n    const newAddresses = addresses.filter(address => existing.indexOf(address) === -1);\n    const oldAddresses = existing.filter(address => addresses.indexOf(address) === -1);\n    let isUpdated = false;\n    newAddresses.forEach(address => {\n      isUpdated = true;\n      accounts[address] = {\n        balance: \"0x0\"\n      };\n    });\n    oldAddresses.forEach(address => {\n      isUpdated = true;\n      delete accounts[address];\n    });\n    this.update({\n      accounts: _objectSpread({}, accounts)\n    });\n    return isUpdated;\n  }\n  async refresh() {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      this._updateAccounts();\n    } catch (error) {} finally {\n      releaseLock();\n    }\n  }\n  async _updateAccounts() {\n    const {\n      accounts\n    } = this.state;\n    const addresses = Object.keys(accounts);\n    const chainId = this.getCurrentChainId();\n    if (chainId === \"loading\") return;\n    if (addresses.length > 0) {\n      if (SINGLE_CALL_BALANCES_ADDRESSES[chainId]) {\n        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESSES[chainId]);\n        return;\n      }\n      log.info(\"falling back to ethQuery.getBalance\");\n      await Promise.all(addresses.map(x => this._updateAccount(x)));\n    }\n  }\n  async _updateAccount(address) {\n    const balance = await this.provider.request({\n      method: \"eth_getBalance\",\n      params: [address, \"latest\"]\n    });\n    const {\n      accounts\n    } = this.state;\n    if (!accounts[address]) return;\n    accounts[address] = {\n      balance: toQuantity(balance)\n    };\n    this.update({\n      accounts\n    });\n  }\n  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {\n    const ethContract = new Contract(deployedContractAddress, singleBalanceCheckerAbi, this.ethersProvider);\n    try {\n      const result = await ethContract.balances(addresses, [ZERO_ADDRESS]);\n      const {\n        accounts\n      } = this.state;\n      addresses.forEach((address, index) => {\n        const balance = toQuantity(result[index]);\n        if (!accounts[address]) return;\n        accounts[address] = {\n          balance\n        };\n      });\n      return this.update({\n        accounts\n      });\n    } catch (error) {\n      log.warn(\"Torus - Account Tracker single call balance fetch failed\", error);\n      return Promise.all(addresses.map(x => this._updateAccount(x)));\n    }\n  }\n}\n\nconst erc20Interface = new Interface(erc20Abi);\nconst erc721Interface = new Interface(erc721Abi);\nconst erc1155Interface = new Interface(erc1155Abi);\n\n// functions that handle normalizing of that key in txParams\n\nconst normalizers = {\n  from: (from, LowerCase = true) => LowerCase ? addHexPrefix(from).toLowerCase() : addHexPrefix(from),\n  to: (to, LowerCase = true) => LowerCase ? addHexPrefix(to).toLowerCase() : addHexPrefix(to),\n  nonce: nonce => addHexPrefix(nonce),\n  customNonceValue: nonce => addHexPrefix(nonce),\n  value: value => addHexPrefix(value),\n  data: data => addHexPrefix(data),\n  gas: gas => addHexPrefix(gas),\n  gasPrice: gasPrice => addHexPrefix(gasPrice),\n  type: addHexPrefix,\n  maxFeePerGas: addHexPrefix,\n  maxPriorityFeePerGas: addHexPrefix\n};\n\n/**\n * normalizes txParams\n */\nfunction normalizeTxParameters(txParameters, lowerCase = true) {\n  // apply only keys in the normalizers\n  const normalizedTxParameters = {\n    id: txParameters.id || randomId(),\n    from: txParameters.from\n  };\n  for (const key in normalizers) {\n    const currentKey = key;\n    if (txParameters[currentKey])\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      normalizedTxParameters[currentKey] = normalizers[currentKey](txParameters[currentKey], lowerCase);\n  }\n  return normalizedTxParameters;\n}\nfunction transactionMatchesNetwork(transaction, chainId) {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n  return false;\n}\n\n/**\n * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied\n * and valid inputs. This will return false for non hex string inputs.\n *  the transaction to check\n * @returns true if transaction uses valid EIP1559 fields\n */\nfunction isEIP1559Transaction(transaction) {\n  var _transaction$transact, _transaction$transact2;\n  return isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact = transaction.transaction) === null || _transaction$transact === void 0 ? void 0 : _transaction$transact.maxFeePerGas)) && isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact2 = transaction.transaction) === null || _transaction$transact2 === void 0 ? void 0 : _transaction$transact2.maxPriorityFeePerGas));\n}\n\n/**\n * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not\n * supplied and that the gasPrice field is valid if it is provided. This will\n * return false if gasPrice is a non hex string.\n * transaction -\n *  the transaction to check\n * @returns true if transaction uses valid Legacy fields OR lacks\n *  EIP1559 fields\n */\nfunction isLegacyTransaction(transaction) {\n  return typeof transaction.transaction.maxFeePerGas === \"undefined\" && typeof transaction.transaction.maxPriorityFeePerGas === \"undefined\" && (typeof transaction.transaction.gasPrice === \"undefined\" || isHexString(addHexPrefix(transaction.transaction.gasPrice)));\n}\n\n/**\n * Given two fields, ensure that the second field is not included in txParams,\n * and if it is throw an invalidParams error.\n */\nfunction ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {\n  if (typeof txParams[mutuallyExclusiveField] !== \"undefined\") {\n    throw rpcErrors.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);\n  }\n}\n\n/**\n * Ensures that the provided value for field is a string, throws an\n * invalidParams error if field is not a string.\n */\nfunction ensureFieldIsString(txParams, field) {\n  if (typeof txParams[field] !== \"string\") {\n    throw rpcErrors.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);\n  }\n}\n\n/**\n * Ensures that the provided txParams has the proper 'type' specified for the\n * given field, if it is provided. If types do not match throws an\n * invalidParams error.\n */\nfunction ensureProperTransactionEnvelopeTypeProvided(txParams, field) {\n  switch (field) {\n    case \"maxFeePerGas\":\n    case \"maxPriorityFeePerGas\":\n      if (txParams.type && txParams.type !== TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {\n        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type \"${txParams.type}\" but ` + `including maxFeePerGas and maxPriorityFeePerGas requires type: \"${TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}\"`);\n      }\n      break;\n    case \"gasPrice\":\n    default:\n      if (txParams.type && txParams.type === TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {\n        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type \"${txParams.type}\" but ` + \"included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas\");\n      }\n  }\n}\n\n/**\n * validates the from field in  txParams\n */\nfunction validateFrom(txParams) {\n  if (!(typeof txParams.from === \"string\")) {\n    throw rpcErrors.invalidParams(`Invalid \"from\" address \"${txParams.from}\": not a string.`);\n  }\n  if (!isValidAddress(txParams.from)) {\n    throw rpcErrors.invalidParams('Invalid \"from\" address.');\n  }\n}\n\n/**\n * validates the to field in  txParams\n */\nfunction validateRecipient(txParameters) {\n  if (txParameters.to === \"0x\" || txParameters.to === null) {\n    if (txParameters.data) {\n      delete txParameters.to;\n    } else {\n      throw rpcErrors.invalidParams('Invalid \"to\" address.');\n    }\n  } else if (txParameters.to !== undefined && !isValidAddress(txParameters.to)) {\n    throw rpcErrors.invalidParams('Invalid \"to\" address.');\n  }\n  return txParameters;\n}\n\n/**\n * Validates the given tx parameters\n * @throws if the tx params contains invalid fields\n */\nfunction validateTxParameters(txParams, eip1559Compatibility = true) {\n  if (!txParams || typeof txParams !== \"object\" || Array.isArray(txParams)) {\n    throw rpcErrors.invalidParams(\"Invalid transaction params: must be an object.\");\n  }\n  if (!txParams.to && !txParams.data) {\n    throw rpcErrors.invalidParams('Invalid transaction params: must specify \"data\" for contract deployments, or \"to\" (and optionally \"data\") for all other types of transactions.');\n  }\n  if (isEIP1559Transaction({\n    transaction: txParams\n  }) && !eip1559Compatibility) {\n    throw rpcErrors.invalidParams(\"Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559\");\n  }\n  Object.entries(txParams).forEach(([key, value]) => {\n    // validate types\n    switch (key) {\n      case \"from\":\n        validateFrom(txParams);\n        break;\n      case \"to\":\n        validateRecipient(txParams);\n        break;\n      case \"gasPrice\":\n        ensureProperTransactionEnvelopeTypeProvided(txParams, \"gasPrice\");\n        ensureMutuallyExclusiveFieldsNotProvided(txParams, \"gasPrice\", \"maxFeePerGas\");\n        ensureMutuallyExclusiveFieldsNotProvided(txParams, \"gasPrice\", \"maxPriorityFeePerGas\");\n        ensureFieldIsString(txParams, \"gasPrice\");\n        break;\n      case \"maxFeePerGas\":\n        ensureProperTransactionEnvelopeTypeProvided(txParams, \"maxFeePerGas\");\n        ensureMutuallyExclusiveFieldsNotProvided(txParams, \"maxFeePerGas\", \"gasPrice\");\n        ensureFieldIsString(txParams, \"maxFeePerGas\");\n        break;\n      case \"maxPriorityFeePerGas\":\n        ensureProperTransactionEnvelopeTypeProvided(txParams, \"maxPriorityFeePerGas\");\n        ensureMutuallyExclusiveFieldsNotProvided(txParams, \"maxPriorityFeePerGas\", \"gasPrice\");\n        ensureFieldIsString(txParams, \"maxPriorityFeePerGas\");\n        break;\n      case \"value\":\n        ensureFieldIsString(txParams, \"value\");\n        if (value.toString().includes(\"-\")) {\n          throw rpcErrors.invalidParams(`Invalid transaction value \"${value}\": not a positive number.`);\n        }\n        if (value.toString().includes(\".\")) {\n          throw rpcErrors.invalidParams(`Invalid transaction value of \"${value}\": number must be in wei.`);\n        }\n        break;\n      case \"chainId\":\n        if (typeof value !== \"number\" && typeof value !== \"string\") {\n          throw rpcErrors.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);\n        }\n        break;\n      default:\n        ensureFieldIsString(txParams, key);\n    }\n  });\n}\nfunction normalizeAndValidateTxParams(txParams, lowerCase = true) {\n  const normalizedTxParams = normalizeTxParameters(txParams, lowerCase);\n  validateTxParameters(normalizedTxParams);\n  return normalizedTxParams;\n}\n\n/**\n * @returns an array of states that can be considered final\n */\nfunction getFinalStates() {\n  return [TransactionStatus.rejected,\n  // the user has responded no!\n  TransactionStatus.confirmed,\n  // the tx has been included in a block.\n  TransactionStatus.failed,\n  // the tx failed for some reason, included on tx data.\n  TransactionStatus.dropped // the tx nonce was already used\n  ];\n}\nfunction parseStandardTokenTransactionData(data) {\n  try {\n    const txDesc = erc20Interface.parseTransaction({\n      data\n    });\n    if (txDesc) return {\n      name: txDesc.name,\n      methodParams: txDesc.args.toArray(),\n      type: CONTRACT_TYPE_ERC20\n    };\n  } catch {\n    // ignore and next try to parse with erc721 ABI\n  }\n  try {\n    const txDesc = erc721Interface.parseTransaction({\n      data\n    });\n    if (txDesc) return {\n      name: txDesc.name,\n      methodParams: txDesc.args.toArray(),\n      type: CONTRACT_TYPE_ERC721\n    };\n  } catch {\n    // ignore and next try to parse with erc1155 ABI\n  }\n  try {\n    const txDesc = erc1155Interface.parseTransaction({\n      data\n    });\n    if (txDesc) return {\n      name: txDesc.name,\n      methodParams: txDesc.args.toArray(),\n      type: CONTRACT_TYPE_ERC1155\n    };\n  } catch {\n    // ignore and return undefined\n  }\n  return undefined;\n}\nconst readAddressAsContract = async (provider, address) => {\n  let contractCode;\n  try {\n    contractCode = await provider.request({\n      method: METHOD_TYPES.ETH_GET_CODE,\n      params: [address, \"latest\"]\n    });\n  } catch (e) {\n    contractCode = null;\n  }\n  const isContractAddress = contractCode ? contractCode !== \"0x\" && contractCode !== \"0x0\" : false;\n  return {\n    contractCode,\n    isContractAddress\n  };\n};\nasync function determineTransactionType(txParams, provider) {\n  const {\n    data,\n    to\n  } = txParams;\n  let name = \"\";\n  let methodParams = [];\n  let type = \"\";\n  try {\n    ({\n      name,\n      methodParams,\n      type\n    } = data && parseStandardTokenTransactionData(data) || {});\n  } catch (error) {\n    log.debug(\"Failed to parse transaction data\", error);\n  }\n  let result;\n  let contractCode = \"\";\n  if (data && !to) {\n    result = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n  } else {\n    const {\n      contractCode: resultCode,\n      isContractAddress\n    } = await readAddressAsContract(provider, to);\n    contractCode = resultCode;\n    if (isContractAddress) {\n      const valueExists = txParams.value && Number(txParams.value) !== 0;\n      const tokenMethodName = [TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, TRANSACTION_TYPES.COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM, TRANSACTION_TYPES.SET_APPROVAL_FOR_ALL].find(x => {\n        var _name;\n        return x.toLowerCase() === ((_name = name) === null || _name === void 0 ? void 0 : _name.toLowerCase());\n      });\n      result = data && tokenMethodName && !valueExists ? tokenMethodName : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    } else {\n      result = TRANSACTION_TYPES.SENT_ETHER;\n    }\n  }\n  return {\n    type: type || CONTRACT_TYPE_ETH,\n    category: result,\n    methodParams,\n    getCodeResponse: contractCode\n  };\n}\n\nfunction hexToBn(hex) {\n  return new BigNumber(stripHexPrefix(hex), 16);\n}\nfunction BNToHex(bn) {\n  return addHexPrefix(bn.toString(16));\n}\nfunction getEtherScanHashLink(txHash, chainId) {\n  if (!SUPPORTED_NETWORKS[chainId]) return \"\";\n  return `${SUPPORTED_NETWORKS[chainId].blockExplorerUrl}/tx/${txHash}`;\n}\nconst formatPastTx = params => {\n  var _transaction$to;\n  const {\n    transaction,\n    lowerCaseSelectedAddress,\n    blockExplorerUrl\n  } = params;\n  let totalAmountString = \"\";\n  if (transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155) totalAmountString = transaction.symbol;else if (transaction.type === CONTRACT_TYPE_ERC20) totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.symbol, true);else totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.type_name, true);\n  const currencyAmountString = transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155 || transaction.isEtherscan ? \"\" : formatSmallNumbers(Number.parseFloat(transaction.currency_amount), transaction.selected_currency, true);\n  const finalObject = {\n    id: transaction.created_at.toString(),\n    date: new Date(transaction.created_at).toString(),\n    from: transaction.from,\n    from_aa_address: transaction.from_aa_address,\n    slicedFrom: typeof transaction.from === \"string\" ? addressSlicer(transaction.from) : \"\",\n    to: transaction.to,\n    slicedTo: typeof transaction.to === \"string\" ? addressSlicer(transaction.to) : \"\",\n    action: lowerCaseSelectedAddress === ((_transaction$to = transaction.to) === null || _transaction$to === void 0 ? void 0 : _transaction$to.toLowerCase()) || \"\" ? ACTIVITY_ACTION_RECEIVE : ACTIVITY_ACTION_SEND,\n    totalAmount: transaction.total_amount,\n    totalAmountString,\n    currencyAmount: transaction.currency_amount,\n    currencyAmountString,\n    amount: `${totalAmountString} / ${currencyAmountString}`,\n    status: transaction.status,\n    etherscanLink: blockExplorerUrl ? `${blockExplorerUrl}/tx/${transaction.transaction_hash}` : \"\",\n    chainId: transaction.chain_id,\n    ethRate: Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.total_amount) && Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.currency_amount) ? `1 ${transaction.symbol} = ${significantDigits(Number.parseFloat(transaction.currency_amount) / Number.parseFloat(transaction.total_amount))}` : \"\",\n    currencyUsed: transaction.selected_currency,\n    type: transaction.type,\n    type_name: transaction.type_name,\n    type_image_link: transaction.type_image_link,\n    transaction_hash: transaction.transaction_hash,\n    transaction_category: transaction.transaction_category,\n    isEtherscan: transaction.isEtherscan,\n    input: transaction.input || \"\",\n    token_id: transaction.token_id || \"\",\n    contract_address: transaction.contract_address || \"\",\n    nonce: transaction.nonce || \"\",\n    is_cancel: !!transaction.is_cancel || false,\n    gas: transaction.gas || \"\",\n    gasPrice: transaction.gasPrice || \"\"\n  };\n  return finalObject;\n};\n\n/**\n * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt\n */\nconst getEthTxStatus = async (hash, provider) => {\n  try {\n    const result = await provider.request({\n      method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,\n      params: [hash]\n    });\n    if (result === null) return TransactionStatus.submitted;\n    if (result && result.status === \"0x1\") return TransactionStatus.confirmed;\n    if (result && result.status === \"0x0\") return TransactionStatus.rejected;\n    return undefined;\n  } catch (err) {\n    log.warn(\"unable to fetch transaction status\", err);\n    return undefined;\n  }\n};\nfunction formatDate(inputDate) {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return `${day} ${month} ${year}`;\n}\nfunction formatTime(time) {\n  return new Date(time).toTimeString().slice(0, 8);\n}\nconst idleTimeTracker = (activityThresholdTime => {\n  let isIdle = false;\n  let idleTimeout = null;\n  const resetTimer = () => {\n    if (idleTimeout) {\n      window.clearTimeout(idleTimeout);\n    }\n    isIdle = false;\n    idleTimeout = window.setTimeout(() => {\n      isIdle = true;\n    }, activityThresholdTime * 1000);\n  };\n  if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    window.addEventListener(\"load\", resetTimer);\n    document.addEventListener(\"mousemove\", resetTimer);\n    document.addEventListener(\"keydown\", resetTimer);\n  }\n  function checkIfIdle() {\n    return isIdle;\n  }\n  return {\n    checkIfIdle\n  };\n})(60 * 3);\nfunction isAddressByChainId(address, _chainId) {\n  // TOOD: add rsk network checks.\n  return isValidAddress(address);\n}\nfunction toChecksumAddressByChainId(address, chainId) {\n  // TOOD: add rsk network checks.\n  if (!isAddressByChainId(address)) return address;\n  return toChecksumAddress(address);\n}\nconst GAS_LIMITS = {\n  // maximum gasLimit of a simple send\n  SIMPLE: addHexPrefix(21000 .toString(16)),\n  // a base estimate for token transfers.\n  BASE_TOKEN_ESTIMATE: addHexPrefix(100000 .toString(16))\n};\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n  return new BigNumber(a, 10).lt(b, 10);\n}\nconst getIpfsEndpoint = path => `https://infura-ipfs.io/${path}`;\nfunction sanitizeNftMetdataUrl(url) {\n  let finalUri = url;\n  if (url !== null && url !== void 0 && url.startsWith(\"ipfs\")) {\n    const ipfsPath = url.split(\"ipfs://\")[1];\n    finalUri = getIpfsEndpoint(ipfsPath);\n  }\n  return finalUri;\n}\nfunction getChainType(chainId) {\n  if (chainId === MAINNET_CHAIN_ID) {\n    return \"mainnet\";\n  } else if (TEST_CHAINS.includes(chainId)) {\n    return \"testnet\";\n  }\n  return \"custom\";\n}\nconst addEtherscanTransactions = async params => {\n  const {\n    txn,\n    lowerCaseSelectedAddress,\n    provider,\n    chainId,\n    blockExplorerUrl\n  } = params;\n  const transactionPromises = await Promise.all(txn.map(async tx => {\n    var _SUPPORTED_NETWORKS$c, _SUPPORTED_NETWORKS$c2;\n    const {\n      category,\n      type\n    } = await determineTransactionType(_objectSpread(_objectSpread({}, tx), {}, {\n      data: tx.input\n    }), provider);\n    tx.transaction_category = tx.transaction_category || category;\n    tx.type_image_link = ((_SUPPORTED_NETWORKS$c = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c === void 0 ? void 0 : _SUPPORTED_NETWORKS$c.logo) || \"\";\n    tx.type_name = (_SUPPORTED_NETWORKS$c2 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c2 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c2.ticker;\n    tx.type = type;\n    return tx;\n  }));\n  const finalTxs = transactionPromises.reduce((accumulator, x) => {\n    var _SUPPORTED_NETWORKS$c3, _SUPPORTED_NETWORKS$c4;\n    let totalAmountString = x.value ? new BigNumber(x.value).div(new BigNumber(10).pow(new BigNumber(x.tokenDecimal || 18))).toString() : \"\";\n    let type = CONTRACT_TYPE_ETH;\n    if (x.contractAddress !== \"\") {\n      if (x.tokenID) {\n        type = x.tokenValue ? CONTRACT_TYPE_ERC1155 : CONTRACT_TYPE_ERC721;\n      } else {\n        type = CONTRACT_TYPE_ERC20;\n      }\n    }\n    if (type === CONTRACT_TYPE_ERC1155) {\n      totalAmountString = x.tokenValue;\n    }\n    const etherscanTransaction = {\n      type,\n      type_image_link: x.type_image_link || \"n/a\",\n      type_name: x.tokenName || ((_SUPPORTED_NETWORKS$c3 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c3 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c3.ticker) || \"n/a\",\n      symbol: x.tokenSymbol || ((_SUPPORTED_NETWORKS$c4 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c4 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c4.ticker),\n      token_id: x.tokenID || \"\",\n      total_amount: totalAmountString,\n      created_at: new Date(Number(x.timeStamp) * 1000),\n      from: x.from,\n      to: x.to,\n      transaction_hash: x.hash,\n      status: x.txreceipt_status && x.txreceipt_status === \"0\" ? TransactionStatus.failed : TransactionStatus.confirmed,\n      isEtherscan: true,\n      input: x.input,\n      contract_address: x.contractAddress,\n      transaction_category: x.transaction_category,\n      gas: `0x${new BigNumber(x.gasUsed || 0, 10).toString(16)}`,\n      gasPrice: `0x${new BigNumber(x.gasPrice || 0, 10).toString(16)}`,\n      chain_id: chainId,\n      currency_amount: \"\",\n      nonce: x.nonce,\n      from_aa_address: \"\",\n      is_cancel: false,\n      selected_currency: \"\"\n    };\n    accumulator.push(formatPastTx({\n      transaction: etherscanTransaction,\n      lowerCaseSelectedAddress,\n      blockExplorerUrl\n    }));\n    return accumulator;\n  }, []);\n  return finalTxs;\n};\n\nconst DEFAULT_POLLING_INTERVAL = 20;\nconst DEFAULT_RETRY_TIMEOUT = 2;\nconst SEC = 1000;\nclass PollingBlockTracker extends BaseBlockTracker {\n  constructor({\n    config,\n    state = {}\n  }) {\n    if (!config.provider) {\n      throw new Error(\"PollingBlockTracker - no provider specified.\");\n    }\n    super({\n      config,\n      state\n    });\n    const pollingInterval = config.pollingInterval || DEFAULT_POLLING_INTERVAL;\n    const retryTimeout = config.retryTimeout || DEFAULT_RETRY_TIMEOUT;\n\n    // merge default + provided config.\n    this.defaultConfig = {\n      provider: config.provider,\n      pollingInterval: pollingInterval * SEC,\n      retryTimeout: retryTimeout * SEC,\n      setSkipCacheFlag: config.setSkipCacheFlag || false\n    };\n    this.initialize();\n  }\n  async checkForLatestBlock() {\n    await this._updateLatestBlock();\n    return this.getLatestBlock();\n  }\n\n  // overrides the BaseBlockTracker._start method.\n  _start() {\n    this._synchronize().catch(err => this.emit(\"error\", err));\n  }\n  async _synchronize() {\n    while (this.state._isRunning) {\n      if (idleTimeTracker.checkIfIdle()) return;\n      try {\n        await this._updateLatestBlock();\n        await timeout(this.config.pollingInterval);\n      } catch (err) {\n        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${err.stack}`);\n        try {\n          this.emit(\"error\", newErr);\n        } catch (emitErr) {\n          log.error(newErr);\n        }\n        await timeout(this.config.retryTimeout);\n      }\n    }\n  }\n  async _updateLatestBlock() {\n    // fetch + set latest block\n    const latestBlock = await this._fetchLatestBlock();\n    this._newPotentialLatest(latestBlock);\n  }\n  async _fetchLatestBlock() {\n    try {\n      const block = await this.config.provider.request({\n        method: \"eth_getBlockByNumber\",\n        params: [\"latest\", false]\n      });\n      return {\n        blockHash: block.hash,\n        idempotencyKey: block.number,\n        timestamp: block.timestamp,\n        baseFeePerGas: block.baseFeePerGas,\n        gasLimit: block.gasLimit\n      };\n    } catch (error) {\n      log.error(\"Polling Block Tracker: \", error);\n      throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${error.message}`);\n    }\n  }\n}\n\nclass CurrencyController extends BaseCurrencyController {\n  constructor({\n    config,\n    state,\n    onNetworkChanged\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"conversionInterval\", void 0);\n    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {\n      commonDenomination: \"USD\",\n      commonDenominatorPrice: 0\n    });\n    this.initialize();\n    onNetworkChanged(networkState => {\n      // to be called as (listener) => this.networkController.on('networkDidChange', listener);\n      if (networkState.providerConfig.ticker.toUpperCase() !== this.state.nativeCurrency.toUpperCase()) {\n        this.setNativeCurrency(networkState.providerConfig.ticker);\n        this.updateConversionRate();\n      }\n    });\n  }\n  setCommonDenomination(commonDenomination) {\n    this.update({\n      commonDenomination\n    });\n  }\n  getCommonDenomination() {\n    return this.state.commonDenomination;\n  }\n  setCommonDenominatorPrice(commonDenominatorPrice) {\n    this.update({\n      commonDenominatorPrice\n    });\n  }\n  getCommonDenominatorPrice() {\n    return this.state.commonDenominatorPrice;\n  }\n\n  /**\n   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is\n   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the\n   * previous interval is clear and a new one is created.\n   */\n  scheduleConversionInterval() {\n    if (this.conversionInterval) {\n      window.clearInterval(this.conversionInterval);\n    }\n    this.conversionInterval = window.setInterval(() => {\n      if (!idleTimeTracker.checkIfIdle()) {\n        this.updateConversionRate();\n      }\n    }, this.config.pollInterval);\n  }\n\n  /**\n   * Updates the conversionRate and conversionDate properties associated with the currentCurrency. Updated info is\n   * fetched from an external API\n   */\n  async updateConversionRate() {\n    const currentCurrency = this.getCurrentCurrency();\n    const nativeCurrency = this.getNativeCurrency();\n    const commonDenomination = this.getCommonDenomination();\n    const conversionRate = await this.retrieveConversionRate(nativeCurrency, currentCurrency, commonDenomination);\n    const currentCurrencyRate = Number.parseFloat(conversionRate[currentCurrency.toUpperCase()]);\n    const commonDenominationRate = Number.parseFloat(conversionRate[commonDenomination.toUpperCase()]);\n    // set conversion rate\n    if (currentCurrencyRate || commonDenominationRate) {\n      // ETC\n      this.setConversionRate(currentCurrencyRate);\n      this.setConversionDate(Math.floor(Date.now() / 1000).toString());\n      if (currentCurrency.toUpperCase() === commonDenomination.toUpperCase()) {\n        this.setCommonDenominatorPrice(currentCurrencyRate);\n      } else {\n        this.setCommonDenominatorPrice(commonDenominationRate);\n      }\n    } else {\n      this.setConversionRate(0);\n      this.setConversionDate(\"N/A\");\n    }\n  }\n  async retrieveConversionRate(fromCurrency, toCurrency, commonDenomination) {\n    try {\n      let apiUrl = `${this.config.api}/currency?fsym=${fromCurrency.toUpperCase()}&tsyms=${toCurrency.toUpperCase()}`;\n      if (commonDenomination && commonDenomination.toUpperCase() !== toCurrency.toUpperCase()) {\n        apiUrl += `,${commonDenomination.toUpperCase()}`;\n      }\n      const parsedResponse = await get(apiUrl);\n      return parsedResponse;\n    } catch (error) {\n      log.error(error, `CurrencyController - updateCommonDenominatorPrice: Failed to query rate for currency: ${fromCurrency}/ ${toCurrency}`);\n    }\n    return {\n      [toCurrency.toUpperCase()]: \"0\",\n      [commonDenomination.toUpperCase()]: \"0\"\n    };\n  }\n}\n\nconst _excluded$1 = [\"aBase\", \"bBase\"],\n  _excluded2 = [\"aBase\", \"bBase\"],\n  _excluded3 = [\"multiplicandBase\", \"multiplierBase\"];\n\n// Big Number Constants\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1000000000000000000\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1000000000\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\");\n// Setter Maps\nconst toBigNumber = {\n  hex: n => new BigNumber(stripHexPrefix(n), 16),\n  dec: n => new BigNumber(String(n), 10),\n  BN: n => new BigNumber(n.toString(16), 16)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10),\n  BN: n => new BN(n.toString(16))\n};\n\n// Utility function for checking base types\nconst isValidBase = base => Number.isInteger(base) && base > 1;\n\n/**\n * Utility method to convert a value between denominations, formats and currencies.\n */\nconst converter = ({\n  value,\n  fromNumericBase,\n  fromDenomination,\n  fromCurrency,\n  toNumericBase,\n  toDenomination,\n  toCurrency,\n  numberOfDecimals,\n  conversionRate,\n  invertConversionRate,\n  roundDown\n}) => {\n  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n  if (fromCurrency !== toCurrency) {\n    if (conversionRate === null || conversionRate === undefined) {\n      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);\n    }\n    let rate = toBigNumber.dec(conversionRate);\n    if (invertConversionRate) {\n      rate = new BigNumber(1).div(conversionRate);\n    }\n    convertedValue = convertedValue.times(rate);\n  }\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n  if (roundDown) {\n    convertedValue = convertedValue.dp(roundDown, BigNumber.ROUND_DOWN);\n  }\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n  return convertedValue;\n};\nconst conversionUtil = (value, {\n  fromCurrency = null,\n  toCurrency = fromCurrency,\n  fromNumericBase,\n  toNumericBase,\n  fromDenomination,\n  toDenomination,\n  numberOfDecimals,\n  conversionRate,\n  invertConversionRate\n}) => {\n  if (fromCurrency !== toCurrency && !conversionRate) {\n    return 0;\n  }\n  return converter({\n    fromCurrency,\n    toCurrency,\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    conversionRate,\n    invertConversionRate,\n    value\n  });\n};\nconst getBigNumber = (value, base) => {\n  if (!isValidBase(base)) {\n    throw new Error(\"Must specificy valid base\");\n  }\n\n  // We don't include 'number' here, because BigNumber will throw if passed\n  // a number primitive it considers unsafe.\n  if (typeof value === \"string\" || value instanceof BigNumber) {\n    return new BigNumber(value, base);\n  }\n  return new BigNumber(String(value), base);\n};\nconst addCurrencies = (a, b, options = {}) => {\n  const {\n      aBase,\n      bBase\n    } = options,\n    conversionOptions = _objectWithoutProperties(options, _excluded$1);\n  if (!isValidBase(aBase) || !isValidBase(bBase)) {\n    throw new Error(\"Must specify valid aBase and bBase\");\n  }\n  const value = getBigNumber(a, aBase).plus(getBigNumber(b, bBase));\n  return converter(_objectSpread({\n    value\n  }, conversionOptions));\n};\nconst subtractCurrencies = (a, b, options = {}) => {\n  const {\n      aBase,\n      bBase\n    } = options,\n    conversionOptions = _objectWithoutProperties(options, _excluded2);\n  if (!isValidBase(aBase) || !isValidBase(bBase)) {\n    throw new Error(\"Must specify valid aBase and bBase\");\n  }\n  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));\n  return converter(_objectSpread({\n    value\n  }, conversionOptions));\n};\nconst multiplyCurrencies = (a, b, options = {}) => {\n  const {\n      multiplicandBase,\n      multiplierBase\n    } = options,\n    conversionOptions = _objectWithoutProperties(options, _excluded3);\n  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {\n    throw new Error(\"Must specify valid multiplicandBase and multiplierBase\");\n  }\n  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));\n  return converter(_objectSpread({\n    value\n  }, conversionOptions));\n};\nconst conversionGreaterThan = (_ref, _ref2) => {\n  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref2), _ref2));\n  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));\n  const firstValue = converter(_objectSpread({}, firstProps));\n  const secondValue = converter(_objectSpread({}, secondProps));\n  return firstValue.gt(secondValue);\n};\nconst conversionLessThan = (_ref3, _ref4) => {\n  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref4), _ref4));\n  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref3), _ref3));\n  const firstValue = converter(_objectSpread({}, firstProps));\n  const secondValue = converter(_objectSpread({}, secondProps));\n  return firstValue.lt(secondValue);\n};\nconst conversionMax = (_ref5, _ref6) => {\n  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref6), _ref6));\n  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref5), _ref5));\n  const firstIsGreater = conversionGreaterThan(_objectSpread({}, firstProps), _objectSpread({}, secondProps));\n  return firstIsGreater ? firstProps.value : secondProps.value;\n};\nconst conversionGTE = (_ref7, _ref8) => {\n  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref8), _ref8));\n  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref7), _ref7));\n  const firstValue = converter(_objectSpread({}, firstProps));\n  const secondValue = converter(_objectSpread({}, secondProps));\n  return firstValue.isGreaterThanOrEqualTo(secondValue);\n};\nconst conversionLTE = (_ref9, _ref10) => {\n  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref10), _ref10));\n  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref9), _ref9));\n  const firstValue = converter(_objectSpread({}, firstProps));\n  const secondValue = converter(_objectSpread({}, secondProps));\n  return firstValue.isLessThanOrEqualTo(secondValue);\n};\nconst toNegative = (n, options = {}) => multiplyCurrencies(n, -1, options);\nconst decGWEIToHexWEI = decGWEI => {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n};\nconst hexWEIToDecGWEI = decGWEI => {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n};\n\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(new BigNumber(n));\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\nasync function fetchGasEstimates(url) {\n  const estimates = await get(url);\n  const normalizedEstimates = {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee).toString(10),\n    low: _objectSpread(_objectSpread({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas).toString(10),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas).toString(10)\n    }),\n    medium: _objectSpread(_objectSpread({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas).toString(10),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas).toString(10)\n    }),\n    high: _objectSpread(_objectSpread({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas).toString(10),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas).toString(10)\n    })\n  };\n  return normalizedEstimates;\n}\nasync function fetchGasEstimatesViaEthFeeHistory(provider) {\n  const noOfBlocks = 10;\n  const newestBlock = \"latest\";\n  // get the 10, 50 and 95th percentile of the tip fees from the last 10 blocks\n  const percentileValues = [10, 50, 95];\n  const feeHistory = await provider.request({\n    method: \"eth_feeHistory\",\n    params: [noOfBlocks, newestBlock, percentileValues]\n  });\n  // this is in hex wei\n  const finalBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];\n  // this is in hex wei\n  const priorityFeeCalcs = feeHistory.reward.reduce((acc, curr) => {\n    return {\n      slow: acc.slow.plus(new BigNumber(curr[0], 16)),\n      average: acc.average.plus(new BigNumber(curr[1], 16)),\n      fast: acc.fast.plus(new BigNumber(curr[2], 16))\n    };\n  }, {\n    slow: new BigNumber(0),\n    average: new BigNumber(0),\n    fast: new BigNumber(0)\n  });\n  return {\n    estimatedBaseFee: hexWEIToDecGWEI(finalBaseFeePerGas).toString(10),\n    high: {\n      maxWaitTimeEstimate: 30000,\n      minWaitTimeEstimate: 15000,\n      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.plus(finalBaseFeePerGas).toString(16)).toString(),\n      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.toString(16)).toString()\n    },\n    medium: {\n      maxWaitTimeEstimate: 45000,\n      minWaitTimeEstimate: 15000,\n      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.plus(finalBaseFeePerGas).toString(16)).toString(),\n      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.toString(16)).toString()\n    },\n    low: {\n      maxWaitTimeEstimate: 60000,\n      minWaitTimeEstimate: 15000,\n      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.plus(finalBaseFeePerGas).toString(16)).toString(),\n      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.toString(16)).toString()\n    }\n  };\n}\n\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\"\n  });\n  // this returns decimal gwei\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\nasync function fetchEthGasPriceEstimate(provider) {\n  const gasPrice = await provider.request({\n    method: METHOD_TYPES.ETH_GET_GAS_PRICE\n  });\n  return {\n    gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n  };\n}\nfunction calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {\n  // all are in dec gwei\n  const {\n    low,\n    medium,\n    high,\n    estimatedBaseFee\n  } = gasFeeEstimates;\n  const maxPriorityFeePerGasInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(maxPriorityFeePerGas)), 16);\n  const maxFeePerGasInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(maxFeePerGas)), 16);\n  const estimatedBaseFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(estimatedBaseFee)), 16);\n  const effectiveMaxPriorityFee = BigNumber.min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.minus(estimatedBaseFeeInWEI));\n  const lowMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(low.suggestedMaxPriorityFeePerGas)), 16);\n  const mediumMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(medium.suggestedMaxPriorityFeePerGas)), 16);\n  const highMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(high.suggestedMaxPriorityFeePerGas)), 16);\n  let lowerTimeBound;\n  let upperTimeBound;\n  if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {\n    lowerTimeBound = null;\n    upperTimeBound = \"unknown\";\n  } else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {\n    lowerTimeBound = low.minWaitTimeEstimate;\n    upperTimeBound = low.maxWaitTimeEstimate;\n  } else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {\n    lowerTimeBound = medium.minWaitTimeEstimate;\n    upperTimeBound = medium.maxWaitTimeEstimate;\n  } else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {\n    lowerTimeBound = high.minWaitTimeEstimate;\n    upperTimeBound = high.maxWaitTimeEstimate;\n  } else {\n    lowerTimeBound = 0;\n    upperTimeBound = high.maxWaitTimeEstimate;\n  }\n  return {\n    lowerTimeBound,\n    upperTimeBound\n  };\n}\n\nconst GAS_FEE_API = \"https://mock-gas-server.herokuapp.com/\";\nconst LEGACY_GAS_PRICES_API_URL = \"https://api.metaswap.codefi.network/gasPrices\";\n/**\n * Returns gas prices in dec gwei\n */\nclass GasFeeController extends BaseController {\n  constructor({\n    config,\n    state,\n    getNetworkIdentifier,\n    getProvider,\n    fetchGasEstimates: fetchGasEstimates$1 = fetchGasEstimates,\n    fetchEthGasPriceEstimate: fetchEthGasPriceEstimate$1 = fetchEthGasPriceEstimate,\n    fetchLegacyGasPriceEstimates: fetchLegacyGasPriceEstimates$1 = fetchLegacyGasPriceEstimates,\n    fetchGasEstimatesViaEthFeeHistory: fetchGasEstimatesViaEthFeeHistory$1 = fetchGasEstimatesViaEthFeeHistory,\n    getCurrentNetworkLegacyGasAPICompatibility,\n    getCurrentNetworkEIP1559Compatibility,\n    getCurrentAccountEIP1559Compatibility,\n    onNetworkStateChange\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"name\", \"GasFeeController\");\n    // https://0x.org/docs/introduction/0x-cheat-sheet#swap-api-endpoints\n    _defineProperty(this, \"API_SUPPORTED_CHAINIDS\", new Set([\"0x1\", \"0x5\", \"0xa4b1\", \"0xa86a\", \"0x2105\", \"0x38\", \"0xfa\", \"0xa\", \"0x89\"]));\n    _defineProperty(this, \"intervalId\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"currentChainId\", void 0);\n    _defineProperty(this, \"getNetworkIdentifier\", void 0);\n    _defineProperty(this, \"getProvider\", void 0);\n    _defineProperty(this, \"fetchGasEstimates\", void 0);\n    _defineProperty(this, \"fetchGasEstimatesViaEthFeeHistory\", void 0);\n    _defineProperty(this, \"fetchEthGasPriceEstimate\", void 0);\n    _defineProperty(this, \"fetchLegacyGasPriceEstimates\", void 0);\n    _defineProperty(this, \"getCurrentNetworkEIP1559Compatibility\", void 0);\n    _defineProperty(this, \"getCurrentAccountEIP1559Compatibility\", void 0);\n    _defineProperty(this, \"getCurrentNetworkLegacyGasAPICompatibility\", void 0);\n    this.getNetworkIdentifier = getNetworkIdentifier;\n    this.getProvider = getProvider;\n    this.fetchGasEstimates = fetchGasEstimates$1;\n    this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate$1;\n    this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates$1;\n    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;\n    this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;\n    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;\n    this.fetchGasEstimatesViaEthFeeHistory = fetchGasEstimatesViaEthFeeHistory$1;\n    this.defaultConfig = {\n      interval: 30000,\n      legacyAPIEndpoint: LEGACY_GAS_PRICES_API_URL,\n      EIP1559APIEndpoint: GAS_FEE_API\n    };\n    this.defaultState = {\n      gasFeeEstimates: {},\n      estimatedGasFeeTimeBounds: {},\n      gasEstimateType: GAS_ESTIMATE_TYPES.NONE\n    };\n    // Initialize.\n    this.currentChainId = this.getNetworkIdentifier();\n    this.provider = this.getProvider();\n    this.initialize();\n    onNetworkStateChange(() => {\n      this.onNetworkStateChange();\n    });\n  }\n  async onNetworkStateChange() {\n    this.provider = this.getProvider();\n    const newChainId = this.getNetworkIdentifier();\n    if (this.currentChainId !== newChainId) {\n      this.currentChainId = newChainId;\n      await this.fetchGasFeeEstimates();\n    }\n  }\n  async resetPolling() {\n    this.stopPolling();\n    await this.getGasFeeEstimatesAndStartPolling();\n  }\n  async fetchGasFeeEstimates() {\n    return this._fetchGasFeeEstimateData();\n  }\n  async getGasFeeEstimatesAndStartPolling() {\n    await this._fetchGasFeeEstimateData();\n    this._startPolling();\n  }\n  disconnectPoller() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  destroy() {\n    this.stopPolling();\n  }\n  stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n    this.resetState();\n  }\n\n  /**\n   * Gets and sets gasFeeEstimates in state\n   *\n   * @returns GasFeeEstimates\n   */\n  async _fetchGasFeeEstimateData() {\n    let isEIP1559Compatible;\n    const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();\n    const chainId = this.getNetworkIdentifier();\n    if (chainId === \"loading\") return;\n    let chainIdInt;\n    if (typeof chainId === \"string\" && isHexString(addHexPrefix(chainId))) {\n      chainIdInt = Number.parseInt(chainId, 16);\n    }\n    try {\n      isEIP1559Compatible = await this.getEIP1559Compatibility();\n      log.info(\"eip1559 compatible\", isEIP1559Compatible);\n    } catch (error) {\n      log.warn(error);\n      isEIP1559Compatible = false;\n    }\n    let newState = cloneDeep(this.defaultState);\n    try {\n      if (isEIP1559Compatible) {\n        let estimates;\n        try {\n          if (this.API_SUPPORTED_CHAINIDS.has(chainId)) {\n            estimates = await this.fetchGasEstimates(this.config.EIP1559APIEndpoint.replace(\"<chain_id>\", `${chainIdInt}`));\n          } else {\n            throw new Error(\"ChainId not supported by api\");\n          }\n        } catch (error) {\n          estimates = await this.fetchGasEstimatesViaEthFeeHistory(this.provider);\n        }\n        const {\n          suggestedMaxPriorityFeePerGas,\n          suggestedMaxFeePerGas\n        } = estimates.medium;\n        const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);\n        newState = {\n          gasFeeEstimates: estimates,\n          estimatedGasFeeTimeBounds,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await this.fetchLegacyGasPriceEstimates(this.config.legacyAPIEndpoint.replace(\"<chain_id>\", `${chainIdInt}`));\n        newState = {\n          gasFeeEstimates: estimates,\n          estimatedGasFeeTimeBounds: {},\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate(this.provider);\n        newState = {\n          gasFeeEstimates: estimates,\n          estimatedGasFeeTimeBounds: {},\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);\n      }\n    }\n    this.update(newState);\n    return newState;\n  }\n  async _startPolling() {\n    this._poll();\n  }\n  async _poll() {\n    if (this.intervalId) {\n      window.clearInterval(this.intervalId);\n    }\n    this.intervalId = window.setInterval(async () => {\n      if (!idleTimeTracker.checkIfIdle()) {\n        await this._fetchGasFeeEstimateData();\n      }\n    }, this.config.interval);\n  }\n  resetState() {\n    this.update(cloneDeep(this.defaultState));\n  }\n  async getEIP1559Compatibility() {\n    var _this$getCurrentAccou, _this$getCurrentAccou2;\n    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility();\n    const currentAccountIsEIP1559Compatible = (_this$getCurrentAccou = (_this$getCurrentAccou2 = this.getCurrentAccountEIP1559Compatibility) === null || _this$getCurrentAccou2 === void 0 ? void 0 : _this$getCurrentAccou2.call(this)) !== null && _this$getCurrentAccou !== void 0 ? _this$getCurrentAccou : true;\n    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;\n  }\n  getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {\n    if (!this.state.gasFeeEstimates || this.state.gasEstimateType !== GAS_ESTIMATE_TYPES.FEE_MARKET) {\n      return {};\n    }\n    return calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);\n  }\n}\n\nclass KeyringController extends BaseKeyringController {\n  constructor({\n    config,\n    state\n  }) {\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      wallets: []\n    };\n    this.initialize();\n  }\n  async signTransaction(tx, address) {\n    const txPayload = tx;\n    const wallet = this._getWalletForAccount(address);\n    const privKey = this.getBufferPrivateKey(wallet.privateKey);\n    const signedTx = txPayload.sign(privKey);\n    // Newer versions of Ethereumjs-tx are immutable and return a new tx object\n    return signedTx === undefined ? tx : signedTx;\n  }\n  getAccounts() {\n    return this.state.wallets.map(w => w.publicKey);\n  }\n  importAccount(accountPrivateKey) {\n    const hexPrivateKey = accountPrivateKey.padStart(64, \"0\");\n    const bufferPrivKey = Buffer.from(hexPrivateKey, \"hex\");\n    const publicKey = bytesToHex(privateToPublic(bufferPrivKey));\n    const address = toChecksumAddress(bytesToHex(privateToAddress(bufferPrivKey)));\n    const existingWallet = this.state.wallets.find(w => w.address === address);\n    if (existingWallet) return existingWallet.address;\n    this.update({\n      wallets: [...this.state.wallets, {\n        publicKey,\n        privateKey: accountPrivateKey,\n        address\n      }]\n    });\n    return address;\n  }\n  removeAccount(address) {\n    const newWallets = [...this.state.wallets];\n    const idx = newWallets.findIndex(w => w.address === address);\n    if (idx !== -1) {\n      newWallets.splice(idx, 1);\n      this.update({\n        wallets: newWallets\n      });\n    }\n  }\n  getBufferPrivateKey(privateKey) {\n    const stripped = stripHexPrefix(privateKey);\n    return Buffer.from(stripped, \"hex\");\n  }\n\n  // For eth_sign, we need to sign arbitrary data:\n  async signMessage(data, address) {\n    const wallet = this._getWalletForAccount(address);\n    const privKey = this.getBufferPrivateKey(wallet.privateKey);\n    const messageSig = ecsign(Buffer.from(stripHexPrefix(data), \"hex\"), privKey);\n    const sig = concatSig(Buffer.from(bigIntToBytes(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));\n    return sig;\n  }\n\n  // For personal_sign, we need to prefix the message: ensure input is hashed and not buffer of utf-8\n  async signPersonalMessage(data, address) {\n    const wallet = this._getWalletForAccount(address);\n    const privKey = this.getBufferPrivateKey(wallet.privateKey);\n    const sig = personalSign({\n      privateKey: privKey,\n      data\n    });\n    return sig;\n  }\n\n  // personal_signTypedData, signs data along with the schema\n  async signTypedData(typedData, address, version) {\n    const wallet = this._getWalletForAccount(address);\n    const privKey = this.getBufferPrivateKey(wallet.privateKey);\n    return signTypedData({\n      privateKey: privKey,\n      data: typedData,\n      version\n    });\n  }\n  signEncryptionPublicKey(address) {\n    const wallet = this._getWalletForAccount(address);\n    return getEncryptionPublicKey(stripHexPrefix(wallet.privateKey));\n  }\n  decryptMessage(data, address) {\n    const wallet = this._getWalletForAccount(address);\n    return decrypt({\n      encryptedData: data,\n      privateKey: stripHexPrefix(wallet.privateKey)\n    });\n  }\n  _getWalletForAccount(account) {\n    const address = account.toLowerCase();\n    const wallet = this.state.wallets.find(w => w.address.toLowerCase() === address);\n    if (!wallet) throw new Error(\"Torus Keyring - Unable to find matching address.\");\n    return wallet;\n  }\n}\n\nclass AbstractMessageController extends BaseController {\n  /**\n   * Controller in charge of managing - storing, adding, removing, updating - Messages.\n   *\n   */\n  constructor({\n    config,\n    state,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"messages\", void 0);\n    _defineProperty(this, \"getNetworkIdentifier\", void 0);\n    this.defaultState = {\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0\n    };\n    this.messages = [];\n    this.defaultConfig = {};\n    this.getNetworkIdentifier = getNetworkIdentifier;\n    super.initialize();\n  }\n  getMessage(messageId) {\n    return this.messages.find(message => message.id === messageId);\n  }\n  getAllMessages() {\n    return this.messages;\n  }\n  setMetadata(messageId, metadata) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.metadata = metadata;\n    this.updateMessage(message);\n  }\n  getUnapprovedMessages() {\n    return this.messages.filter(message => message.status === MessageStatus.UNAPPROVED).reduce((result, message) => {\n      result[message.id] = message;\n      return result;\n    }, {});\n  }\n  async addMessage(message) {\n    this.messages.push(message);\n    this.saveMessageList();\n  }\n  approveMessage(messageId, messageParams) {\n    this.setMessageStatus(messageId, MessageStatus.APPROVED);\n    return this.prepMessageForSigning(messageParams);\n  }\n  setMessageStatus(messageId, status) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.status = status;\n    this.updateMessage(message);\n    this.emit(`${messageId}:${status}`, message);\n    if (status === MessageStatus.REJECTED || status === MessageStatus.SIGNED || status === MessageStatus.FAILED) {\n      this.emit(`${messageId}:finished`, message);\n    }\n  }\n  async waitForFinishStatus(msgParams, messageName) {\n    return new Promise((resolve, reject) => {\n      const handleFinished = msg => {\n        if (msg.status === MessageStatus.REJECTED) {\n          return reject(providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));\n        }\n        if (msg.status === MessageStatus.FAILED) {\n          return reject(rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));\n        }\n        if (msg.status === MessageStatus.SIGNED) {\n          return resolve(msg.rawSig);\n        }\n        return reject(rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));\n      };\n      this.once(`${msgParams.id}:finished`, handleFinished);\n    });\n  }\n  updateMessage(message) {\n    const index = this.messages.findIndex(msg => message.id === msg.id);\n    if (index !== -1) {\n      this.messages[index] = message;\n    }\n    this.saveMessageList();\n  }\n  saveMessageList() {\n    const unapprovedMessages = this.getUnapprovedMessages();\n    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;\n    this.update({\n      unapprovedMessages,\n      unapprovedMessagesCount\n    });\n  }\n}\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\nfunction validateAddress(address, propertyName) {\n  if (!address || typeof address !== \"string\" || !isValidAddress(address)) {\n    throw new Error(`Invalid \"${propertyName}\" address: ${address} must be a valid string.`);\n  }\n}\nfunction validateSignMessageData(messageData) {\n  const {\n    from,\n    data\n  } = messageData;\n  validateAddress(from, \"from\");\n  if (!data || typeof data !== \"string\") {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\nfunction normalizeMessageData(data) {\n  try {\n    const stripped = stripHexPrefix(data);\n    if (stripped.match(hexRe)) {\n      return addHexPrefix(stripped);\n    }\n  } catch (e) {}\n  return bytesToHex(Buffer.from(data, \"utf8\"));\n}\nfunction validateTypedSignMessageDataV1(messageData) {\n  validateAddress(messageData.from, \"from\");\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(`Invalid message \"data\": ${messageData.data} must be a valid array.`);\n  }\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    typedSignatureHash(messageData.data);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\nasync function validateTypedSignMessageDataV3V4(messageData, currentChainId) {\n  validateAddress(messageData.from, \"from\");\n  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== \"object\" && typeof messageData.data !== \"string\") {\n    throw new Error(`Invalid message \"data\": Must be a valid string or object.`);\n  }\n  let data;\n  if (typeof messageData.data === \"object\") {\n    data = messageData.data;\n  } else {\n    try {\n      data = JSON.parse(messageData.data);\n    } catch (e) {\n      throw new Error(\"Data must be passed as a valid JSON string.\");\n    }\n  }\n  const {\n    validate\n  } = await import('jsonschema');\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\"Data must conform to EIP-712 schema. See https://git.io/fNtcx.\");\n  }\n  if (!currentChainId) {\n    throw new Error(\"Current chainId cannot be null or undefined.\");\n  }\n  let {\n    chainId\n  } = data.domain;\n  if (chainId) {\n    if (typeof chainId === \"string\") {\n      chainId = parseInt(chainId, chainId.startsWith(\"0x\") ? 16 : 10);\n    }\n    const activeChainId = parseInt(currentChainId, 16);\n    if (Number.isNaN(activeChainId)) {\n      throw new Error(`Cannot sign messages for chainId \"${chainId}\", because MetaMask is switching networks.`);\n    }\n    if (chainId !== activeChainId) {\n      throw new Error(`Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`);\n    }\n  }\n}\nfunction validateEncryptionPublicKeyMessageData(messageData) {\n  const {\n    from\n  } = messageData;\n  validateAddress(from, \"from\");\n}\nfunction validateDecryptedMessageData(messageData) {\n  const {\n    from\n  } = messageData;\n  validateAddress(from, \"from\");\n}\nfunction parseDecryptMessageData(data) {\n  const stripped = stripHexPrefix(data);\n  const buffer = Buffer.from(stripped, \"hex\");\n  return JSON.parse(buffer.toString(\"utf8\"));\n}\nasync function validateAddChainData(data) {\n  const {\n    chainId,\n    rpcUrls,\n    nativeCurrency\n  } = data || {};\n  if (!chainId) {\n    throw new Error(\"Invalid add chain params: please pass chainId in params\");\n  }\n  if (!isHexString$1(chainId)) {\n    throw new Error(\"Invalid add chain params: please pass a valid hex chainId in params, for: ex: 0x1\");\n  }\n  if (!rpcUrls || rpcUrls.length === 0) throw new Error(\"params.rpcUrls not provided\");\n  if (!nativeCurrency) throw new Error(\"params.nativeCurrency not provided\");\n  const {\n    name,\n    symbol,\n    decimals\n  } = nativeCurrency;\n  if (!name) throw new Error(\"params.nativeCurrency.name not provided\");\n  if (!symbol) throw new Error(\"params.nativeCurrency.symbol not provided\");\n  if (decimals === undefined) throw new Error(\"params.nativeCurrency.decimals not provided\");\n  const _web3 = new JsonRpcProvider(rpcUrls[0], \"any\");\n  const {\n    chainId: networkChainID\n  } = await _web3.getNetwork();\n  if (Number.parseInt(networkChainID.toString()) !== Number.parseInt(chainId, 16)) {\n    throw new Error(`Provided rpc url's chainId version is not matching with provided chainId, expected: ${toQuantity(networkChainID)}, received: ${chainId}`);\n  }\n}\nfunction validateSwitchChainData(data) {\n  const {\n    chainId\n  } = data || {};\n  if (!chainId) {\n    throw new Error(\"Invalid switch chain params: please pass chainId in params\");\n  }\n  if (!isHexString$1(chainId)) {\n    throw new Error(\"Invalid switch chain params: please pass a valid hex chainId in params, for: ex: 0x1\");\n  }\n}\n\nclass AddChainController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    getNetworkIdentifier,\n    addChain\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"AddChainController\");\n    _defineProperty(this, \"addChain\", void 0);\n    this.addChain = addChain;\n    this.initialize();\n  }\n  async processAddChain(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(\"Message not found\");\n    }\n    try {\n      await this.approveMessage(messageId, msgObject.messageParams);\n      await this.addChain(msgObject.messageParams);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig: JSON.stringify(msgObject.messageParams)\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return null;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    // set message params origin first to satisfy the eslint rule (origin won't be checked by validateAddChainData)\n    // for \"Possible race condition: `messageParams.origin` might be assigned based on an outdated state of `messageParams`\"\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    await validateAddChainData(messageParams);\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.ADD_CHAIN\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(messageParams);\n  }\n}\n\nclass DecryptMessageController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    decryptMessage,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"DecryptMessageController\");\n    _defineProperty(this, \"decryptMessage\", void 0);\n    this.decryptMessage = decryptMessage;\n    this.initialize();\n  }\n  async processDecryptMessage(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(\"Message not found\");\n    }\n    try {\n      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);\n      const parsedData = parseDecryptMessageData(cleanMsgParams.data);\n      const rawSig = this.decryptMessage(parsedData, cleanMsgParams.from);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return rawSig;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    validateDecryptedMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.ETH_DECRYPT\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(_objectSpread({}, messageParams));\n  }\n}\n\nclass EncryptionPublicKeyController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    signEncryptionPublicKey,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"EncryptionPublicKeyController\");\n    _defineProperty(this, \"signEncryptionPublicKey\", void 0);\n    this.signEncryptionPublicKey = signEncryptionPublicKey;\n    this.initialize();\n  }\n  async processGetEncryptionPublicKey(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(`Message not found`);\n    }\n    try {\n      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);\n      const publicKey = this.signEncryptionPublicKey(cleanMsgParams.from);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig: publicKey\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return publicKey;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    validateEncryptionPublicKeyMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    // From should be the public key for the encryption\n    return Promise.resolve(_objectSpread(_objectSpread({}, messageParams), {}, {\n      from: messageParams.data\n    }));\n  }\n}\n\nclass MessageController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    signMessage,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"MessageController\");\n    _defineProperty(this, \"signMessage\", void 0);\n    this.signMessage = signMessage;\n    this.initialize();\n  }\n  async processSignMessage(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(`Message not found`);\n    }\n    try {\n      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);\n      const rawSig = await this.signMessage(cleanMsgParams.data, cleanMsgParams.from);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return rawSig;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    validateSignMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.ETH_SIGN\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(messageParams);\n  }\n}\n\nclass PersonalMessageController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    signPersonalMessage,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"PersonalMessageController\");\n    _defineProperty(this, \"signPersonalMessage\", void 0);\n    this.signPersonalMessage = signPersonalMessage;\n    this.initialize();\n  }\n  async processSignPersonalMessage(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(`Message not found`);\n    }\n    try {\n      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);\n      const rawSig = await this.signPersonalMessage(cleanMsgParams.data, cleanMsgParams.from);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return rawSig;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    validateSignMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.PERSONAL_SIGN\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(messageParams);\n  }\n}\n\nclass SwitchChainController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    getNetworkIdentifier,\n    switchChain\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"SwitchChainController\");\n    _defineProperty(this, \"switchChain\", void 0);\n    this.switchChain = switchChain;\n    this.initialize();\n  }\n  async processSwitchChain(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(`Message not found`);\n    }\n    try {\n      await this.approveMessage(messageId, msgObject.messageParams);\n      this.switchChain({\n        chainId: msgObject.messageParams.chainId\n      });\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig: JSON.stringify(msgObject.messageParams)\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return null;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req) {\n    await this.addUnapprovedMessage(messageParams, req);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req) {\n    validateSwitchChainData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: METHOD_TYPES.SWITCH_CHAIN\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(messageParams);\n  }\n}\n\nfunction getMessageType(version) {\n  switch (version) {\n    case SignTypedDataVersion.V1:\n      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;\n    case SignTypedDataVersion.V3:\n      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3;\n    case SignTypedDataVersion.V4:\n      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4;\n    default:\n      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;\n  }\n}\nclass TypedMessageController extends AbstractMessageController {\n  constructor({\n    config,\n    state,\n    signTypedData,\n    getNetworkIdentifier\n  }) {\n    super({\n      config,\n      state,\n      getNetworkIdentifier\n    });\n    _defineProperty(this, \"name\", \"TypedMessageController\");\n    _defineProperty(this, \"signTypedData\", void 0);\n    this.signTypedData = signTypedData;\n    this.initialize();\n  }\n  async processSignTypedMessage(messageId) {\n    const msgObject = this.getMessage(messageId);\n    if (!msgObject) {\n      throw new Error(`Message not found`);\n    }\n    try {\n      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);\n      const msgData = cleanMsgParams.version === SignTypedDataVersion.V1 ? cleanMsgParams.data : JSON.parse(cleanMsgParams.data);\n      const rawSig = await this.signTypedData(msgData, cleanMsgParams.from, cleanMsgParams.version);\n      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {\n        rawSig\n      }));\n      this.setMessageStatus(messageId, MessageStatus.SIGNED);\n      return rawSig;\n    } catch (error) {\n      log.error(error);\n      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());\n      this.setMessageStatus(messageId, MessageStatus.FAILED);\n    }\n  }\n  async addNewUnapprovedMessage(messageParams, req, version) {\n    await this.addUnapprovedMessage(messageParams, req, version);\n    return this.waitForFinishStatus(messageParams, this.name);\n  }\n  async addUnapprovedMessage(messageParams, req, version) {\n    if (version === SignTypedDataVersion.V1) {\n      validateTypedSignMessageDataV1(messageParams);\n    }\n    if (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4) {\n      const currentChainId = this.getNetworkIdentifier();\n      await validateTypedSignMessageDataV3V4(messageParams, currentChainId);\n    }\n    if (typeof messageParams.data !== \"string\" && (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4)) {\n      messageParams.data = JSON.stringify(messageParams.data);\n    }\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.version = version;\n    const messageId = messageParams.id || randomId();\n    const messageData = {\n      id: messageId,\n      messageParams,\n      status: MessageStatus.UNAPPROVED,\n      time: Date.now(),\n      type: getMessageType(version)\n    };\n    await this.addMessage(messageData);\n    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {\n      messageData,\n      req\n    });\n    return messageId;\n  }\n  prepMessageForSigning(messageParams) {\n    return Promise.resolve(messageParams);\n  }\n}\n\nfunction createGetAccountsMiddleware({\n  getAccounts\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.GET_ACCOUNTS) return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\");\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n  });\n}\nfunction createProcessTransactionMiddleware({\n  processTransaction\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_TRANSACTION) return next();\n    if (!processTransaction) throw new Error(\"WalletMiddleware - opts.processTransaction not provided\");\n    response.result = await processTransaction(request.params, request);\n  });\n}\nfunction createProcessEthSignMessage({\n  processEthSignMessage\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_SIGN) return next();\n    if (!processEthSignMessage) throw new Error(\"WalletMiddleware - opts.processEthSignMessage not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);\n      const params = request.params;\n      const address = params[0];\n      const message = params[1];\n      msgParams = {\n        from: address,\n        data: message\n      };\n    }\n    response.result = await processEthSignMessage(msgParams, request);\n  });\n}\nfunction createProcessTypedMessage({\n  processTypedMessage\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA) return next();\n    if (!processTypedMessage) throw new Error(\"WalletMiddleware - opts.processTypedMessage not  provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [typedData, address]`);\n      const params = request.params;\n      const message = typeof params[0] === \"string\" ? JSON.parse(params[0]) : params[0];\n      const address = params[1];\n      msgParams = {\n        from: address,\n        data: message,\n        version: SignTypedDataVersion.V1\n      };\n    }\n    response.result = await processTypedMessage(msgParams, request);\n  });\n}\nfunction createProcessTypedMessageV3({\n  processTypedMessageV3\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3) return next();\n    if (!processTypedMessageV3) throw new Error(\"WalletMiddleware - opts.processTypedMessageV3 is not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);\n      const params = request.params;\n      const address = params[0];\n      const message = params[1];\n      msgParams = {\n        from: address,\n        data: message,\n        version: SignTypedDataVersion.V3\n      };\n    }\n    response.result = await processTypedMessageV3(msgParams, request);\n  });\n}\nfunction createProcessTypedMessageV4({\n  processTypedMessageV4\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();\n    if (!processTypedMessageV4) throw new Error(\"WalletMiddleware - opts.processTypedMessageV4 is not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);\n      const params = request.params;\n      const address = params[0];\n      const message = params[1];\n      msgParams = {\n        from: address,\n        data: message,\n        version: SignTypedDataVersion.V4\n      };\n    }\n    response.result = await processTypedMessageV4(msgParams, request);\n  });\n}\nfunction createProcessPersonalMessage({\n  processPersonalMessage\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.PERSONAL_SIGN) return next();\n    if (!processPersonalMessage) throw new Error(\"WalletMiddleware - opts.processPersonalMessage is not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);\n      const params = request.params;\n      if (typeof params[0] === \"object\") {\n        const {\n          challenge,\n          address\n        } = params[0];\n        msgParams = {\n          from: address,\n          data: challenge\n        };\n      } else {\n        const message = params[0];\n        const address = params[1];\n        msgParams = {\n          from: address,\n          data: message\n        };\n      }\n    }\n    response.result = await processPersonalMessage(msgParams, request);\n  });\n}\nfunction createPendingNonceMiddleware({\n  getPendingNonce\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      params,\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();\n    const {\n      blockReference\n    } = params;\n    if (blockReference !== \"pending\") return next();\n    response.result = await getPendingNonce(params, request);\n  });\n}\nfunction formatTxMetaForRpcResult(txMeta) {\n  const {\n    r,\n    s,\n    v,\n    txReceipt,\n    transaction,\n    transactionHash,\n    accessList\n  } = txMeta;\n  const {\n    to,\n    data,\n    nonce,\n    gas,\n    from,\n    value,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  } = transaction;\n  const formattedTxMeta = {\n    v,\n    r,\n    s,\n    to,\n    gas,\n    from,\n    hash: transactionHash,\n    nonce,\n    input: data || \"0x\",\n    value: value || \"0x0\",\n    accessList: accessList || null,\n    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,\n    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,\n    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null,\n    type: null\n  };\n  if (maxFeePerGas && maxPriorityFeePerGas) {\n    formattedTxMeta.maxFeePerGas = maxFeePerGas;\n    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;\n    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;\n  } else {\n    formattedTxMeta.gasPrice = gasPrice;\n    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.LEGACY;\n  }\n  return formattedTxMeta;\n}\nfunction createPendingTxMiddleware({\n  getPendingTransactionByHash\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      params,\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();\n    if (!getPendingTransactionByHash) throw new Error(\"WalletMiddleware - opts.getPendingTransactionByHash not provided\");\n    const txMeta = await getPendingTransactionByHash(params, request);\n    if (!txMeta) {\n      return next();\n    }\n    response.result = formatTxMetaForRpcResult(txMeta);\n    return undefined;\n  });\n}\nfunction createProcessEncryptionPublicKeyMiddleware({\n  processEncryptionPublicKey\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY) return next();\n    if (!processEncryptionPublicKey) throw new Error(\"WalletMiddleware - opts.processEncryptionPublicKey not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address]`);\n      const [address] = request.params;\n      msgParams = {\n        data: address,\n        from: address\n      };\n    }\n    response.result = await processEncryptionPublicKey(msgParams, request);\n  });\n}\nfunction createProcessDecryptMessageMiddleware({\n  processDecryptMessage\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ETH_DECRYPT) return next();\n    if (!processDecryptMessage) throw new Error(\"WalletMiddleware - opts.processDecryptMessage not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);\n      const [message, address] = request.params;\n      msgParams = {\n        data: message,\n        from: address\n      };\n    }\n    response.result = await processDecryptMessage(msgParams, request);\n  });\n}\nfunction createProcessSwitchEthereumChain({\n  processSwitchEthereumChain\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.SWITCH_CHAIN) return next();\n    if (!processSwitchEthereumChain) throw new Error(\"WalletMiddleware - opts.processSwitchEthereumChain not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);\n      const [message] = request.params;\n      msgParams = message;\n    }\n    response.result = await processSwitchEthereumChain(msgParams, request);\n  });\n}\nfunction createProcessAddEthereumChain({\n  processAddEthereumChain\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== METHOD_TYPES.ADD_CHAIN) return next();\n    if (!processAddEthereumChain) throw new Error(\"WalletMiddleware - opts.processAddEthereumChain not provided\");\n    if (!(request !== null && request !== void 0 && request.params)) throw new Error(\"WalletMiddleware - missing params\");\n    let msgParams = request.params;\n    if (Array.isArray(request.params)) {\n      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);\n      const [message] = request.params;\n      msgParams = message;\n    }\n    response.result = await processAddEthereumChain(msgParams, request);\n  });\n}\nfunction createRequestAccountsMiddleware({\n  requestAccounts\n}) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"eth_requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\");\n    // This calls the UI login function\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createEthereumMiddleware(providerHandlers) {\n  const {\n    requestAccounts,\n    getAccounts,\n    processTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    getPendingNonce,\n    getPendingTransactionByHash,\n    processEncryptionPublicKey,\n    processDecryptMessage,\n    processSwitchEthereumChain,\n    processAddEthereumChain,\n    getProviderState,\n    version\n  } = providerHandlers;\n  return mergeMiddleware([createScaffoldMiddleware({\n    version,\n    [PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n  }), createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createProcessTransactionMiddleware({\n    processTransaction\n  }), createProcessEthSignMessage({\n    processEthSignMessage\n  }), createProcessTypedMessage({\n    processTypedMessage\n  }), createProcessTypedMessageV3({\n    processTypedMessageV3\n  }), createProcessTypedMessageV4({\n    processTypedMessageV4\n  }), createProcessPersonalMessage({\n    processPersonalMessage\n  }), createPendingNonceMiddleware({\n    getPendingNonce\n  }), createPendingTxMiddleware({\n    getPendingTransactionByHash\n  }), createProcessEncryptionPublicKeyMiddleware({\n    processEncryptionPublicKey\n  }), createProcessDecryptMessageMiddleware({\n    processDecryptMessage\n  }), createProcessSwitchEthereumChain({\n    processSwitchEthereumChain\n  }), createProcessAddEthereumChain({\n    processAddEthereumChain\n  })]);\n}\n\nlet CacheStrategy = /*#__PURE__*/function (CacheStrategy) {\n  CacheStrategy[\"Block\"] = \"block\";\n  CacheStrategy[\"Fork\"] = \"fork\";\n  CacheStrategy[\"Never\"] = \"never\";\n  CacheStrategy[\"Permanent\"] = \"perma\";\n  return CacheStrategy;\n}({});\nfunction blockTagParamIndex(method) {\n  switch (method) {\n    // blockTag is at index 2\n    case \"eth_getStorageAt\":\n      return 2;\n    // blockTag is at index 1\n    case \"eth_getBalance\":\n    case \"eth_getCode\":\n    case \"eth_getTransactionCount\":\n    case \"eth_call\":\n      return 1;\n    // blockTag is at index 0\n    case \"eth_getBlockByNumber\":\n      return 0;\n    // there is no blockTag\n    default:\n      return undefined;\n  }\n}\nfunction cacheTypeForMethod(method) {\n  switch (method) {\n    // cache permanently\n    case \"web3_clientVersion\":\n    case \"web3_sha3\":\n    case \"eth_protocolVersion\":\n    case \"eth_getBlockTransactionCountByHash\":\n    case \"eth_getUncleCountByBlockHash\":\n    case \"eth_getCode\":\n    case \"eth_getBlockByHash\":\n    case \"eth_getTransactionByHash\":\n    case \"eth_getTransactionByBlockHashAndIndex\":\n    case \"eth_getTransactionReceipt\":\n    case \"eth_getUncleByBlockHashAndIndex\":\n    case \"eth_getCompilers\":\n    case \"eth_compileLLL\":\n    case \"eth_compileSolidity\":\n    case \"eth_compileSerpent\":\n    case \"shh_version\":\n    case \"test_permaCache\":\n      return CacheStrategy.Permanent;\n\n    // cache until fork\n    case \"eth_getBlockByNumber\":\n    case \"eth_getBlockTransactionCountByNumber\":\n    case \"eth_getUncleCountByBlockNumber\":\n    case \"eth_getTransactionByBlockNumberAndIndex\":\n    case \"eth_getUncleByBlockNumberAndIndex\":\n    case \"test_forkCache\":\n      return CacheStrategy.Fork;\n\n    // cache for block\n    case \"eth_gasPrice\":\n    case \"eth_blockNumber\":\n    case \"eth_getBalance\":\n    case \"eth_getStorageAt\":\n    case \"eth_getTransactionCount\":\n    case \"eth_call\":\n    case \"eth_estimateGas\":\n    case \"eth_getFilterLogs\":\n    case \"eth_getLogs\":\n    case \"test_blockCache\":\n      return CacheStrategy.Block;\n\n    // never cache\n    default:\n      return CacheStrategy.Never;\n  }\n}\nfunction canCache(method) {\n  return cacheTypeForMethod(method) !== CacheStrategy.Never;\n}\nfunction paramsWithoutBlockTag(request) {\n  if (!request.params) {\n    return [];\n  }\n  const index = blockTagParamIndex(request.method);\n\n  // Block tag param not passed.\n  if (index === undefined || !Array.isArray(request.params) || index >= request.params.length) {\n    return request.params;\n  }\n\n  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param\n  if (request.method === \"eth_getBlockByNumber\") {\n    return request.params.slice(1);\n  }\n  return request.params.slice(0, index);\n}\nfunction cacheIdentifierForRequest(request, skipBlockRef) {\n  var _request$params;\n  const simpleParams = skipBlockRef ? paramsWithoutBlockTag(request) : (_request$params = request.params) !== null && _request$params !== void 0 ? _request$params : [];\n  if (canCache(request.method)) {\n    return `${request.method}:${stringify(simpleParams)}`;\n  }\n  return null;\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n    if (req.method === \"net_version\") {\n      // convert to decimal\n      res.result = Number.parseInt(chainId, 16).toString(10);\n      return end();\n    }\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig, networkConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const blockProvider = providerFromMiddleware(fetchMiddleware);\n  const blockTracker = new PollingBlockTracker({\n    config: _objectSpread(_objectSpread({}, networkConfig), {}, {\n      provider: blockProvider\n    }),\n    state: {}\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig),\n  // No need for the following middlewares for web because all browser sessions are quite short lived and each session is limited to scope of a window/tab\n  // createBlockRefRewriteMiddleware({ blockTracker }),\n  // createBlockCacheMiddleware({ blockTracker }),\n  createInflightCacheMiddleware({\n    cacheIdentifierForRequest\n  }),\n  // createBlockTrackerInspectorMiddleware({ blockTracker }),\n  fetchMiddleware]);\n  return {\n    networkMiddleware,\n    blockTracker\n  };\n}\n\nconst _excluded = [\"chainId\", \"rpcTarget\"];\nclass NetworkController extends BaseController {\n  constructor({\n    config,\n    state\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"name\", \"NetworkController\");\n    _defineProperty(this, \"providerProxy\", void 0);\n    _defineProperty(this, \"blockTrackerProxy\", void 0);\n    _defineProperty(this, \"mutex\", new Mutex());\n    _defineProperty(this, \"provider\", null);\n    _defineProperty(this, \"blockTracker\", null);\n    _defineProperty(this, \"baseProviderHandlers\", void 0);\n    this.defaultState = {\n      chainId: \"loading\",\n      properties: {\n        EIPS_1559: undefined\n      },\n      providerConfig: SUPPORTED_NETWORKS[MAINNET_CHAIN_ID]\n    };\n\n    // when a new network is set,\n    // we set to loading first and\n    // then when connection succeeds,\n    // we update the network\n    this.initialize();\n  }\n  getNetworkIdentifier() {\n    return this.state.chainId;\n  }\n  getNetworkRPCUrl() {\n    return this.state.providerConfig.rpcTarget;\n  }\n\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param providerHandlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n  initializeProvider(providerHandlers) {\n    this.baseProviderHandlers = providerHandlers;\n    this.configureProvider();\n    this.lookupNetwork(); // Not awaiting this, because we don't want to block the initialization\n    return this.providerProxy;\n  }\n  getProvider() {\n    return this.providerProxy;\n  }\n  getBlockTracker() {\n    return this.blockTrackerProxy;\n  }\n  getProviderConfig() {\n    return this.state.providerConfig;\n  }\n  setProviderConfig(config) {\n    this.update({\n      providerConfig: _objectSpread({}, config)\n    });\n    this.refreshNetwork();\n  }\n  async getEIP1559Compatibility() {\n    const {\n      EIPS_1559\n    } = this.state.properties;\n    // log.info('checking eip 1559 compatibility')\n    if (EIPS_1559 !== undefined) {\n      return EIPS_1559;\n    }\n    const latestBlock = await this.blockTracker.getLatestBlock();\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    this.update({\n      properties: {\n        EIPS_1559: supportsEIP1559\n      }\n    });\n    return supportsEIP1559;\n  }\n\n  /**\n   * Refreshes the current network code\n   */\n  async lookupNetwork() {\n    const {\n      chainId,\n      rpcTarget\n    } = this.getProviderConfig();\n    if (!chainId || !rpcTarget || !this.provider) {\n      this.update({\n        chainId: \"loading\",\n        properties: {}\n      });\n      return;\n    }\n    const releaseLock = await this.mutex.acquire();\n    try {\n      // use eth_chainId\n      const [networkChainId] = await Promise.all([this.provider.request({\n        method: \"eth_chainId\"\n      }), this.getEIP1559Compatibility()]);\n      log.info(\"network fetched chain id\", networkChainId);\n      // update chain ID\n      this.update({\n        chainId: networkChainId\n      });\n      this.emit(\"networkDidChange\");\n    } catch {\n      this.update({\n        chainId: \"loading\"\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n  configureProvider() {\n    const _this$getProviderConf = this.getProviderConfig(),\n      {\n        chainId,\n        rpcTarget\n      } = _this$getProviderConf,\n      rest = _objectWithoutProperties(_this$getProviderConf, _excluded);\n    if (!chainId || !rpcTarget) {\n      throw new Error(\"chainId and rpcTarget must be provider in providerConfig\");\n    }\n    this.configureStandardProvider(_objectSpread({\n      chainId,\n      rpcTarget\n    }, rest));\n  }\n  setNetworkClient({\n    networkMiddleware,\n    blockTracker\n  }) {\n    const ethereumMiddleware = createEthereumMiddleware(this.baseProviderHandlers);\n    const engine = new JRPCEngine();\n    engine.push(ethereumMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.setProvider({\n      provider,\n      blockTracker\n    });\n  }\n  setProvider({\n    provider,\n    blockTracker\n  }) {\n    if (this.providerProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.providerProxy.setTarget(provider);\n    } else {\n      this.providerProxy = createSwappableProxy(provider);\n    }\n    if (this.blockTrackerProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: \"skipInternal\"\n      });\n    }\n\n    // set new provider and blockTracker\n    this.provider = provider;\n    provider.setMaxListeners(10);\n    this.blockTracker = blockTracker;\n  }\n  configureStandardProvider(providerConfig) {\n    const networkClient = createJsonRpcClient(providerConfig, this.config);\n    log.info(\"networkClient\", networkClient);\n    this.setNetworkClient(networkClient);\n  }\n  refreshNetwork() {\n    this.update({\n      chainId: \"loading\",\n      properties: {}\n    });\n    this.configureProvider();\n    this.lookupNetwork();\n  }\n}\n\nclass NftHandler {\n  constructor({\n    chainId,\n    contractAddress,\n    contractImage,\n    contractName,\n    contractSymbol,\n    nftStandard,\n    provider,\n    contractDescription,\n    contractFallbackLogo,\n    contractSupply\n  }) {\n    _defineProperty(this, \"contractAddress\", void 0);\n    _defineProperty(this, \"contractName\", void 0);\n    _defineProperty(this, \"contractSymbol\", void 0);\n    _defineProperty(this, \"contractImage\", void 0);\n    _defineProperty(this, \"contractSupply\", void 0);\n    _defineProperty(this, \"contractFallbackLogo\", void 0);\n    _defineProperty(this, \"nftStandard\", void 0);\n    _defineProperty(this, \"contractDescription\", void 0);\n    _defineProperty(this, \"chainId\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"isSpecial\", void 0);\n    this.chainId = chainId;\n    this.contractAddress = contractAddress;\n    this.contractImage = contractImage;\n    this.contractName = contractName;\n    this.contractSymbol = contractSymbol;\n    this.nftStandard = nftStandard;\n    this.provider = provider;\n    this.contractDescription = contractDescription;\n    this.contractFallbackLogo = contractFallbackLogo;\n    this.contractSupply = contractSupply;\n  }\n  async getNftMetadata(userAddress, tokenInfo) {\n    const returnNftItem = _objectSpread({\n      description: \"\",\n      image: \"\",\n      name: \"\",\n      tokenBalance: \"\",\n      tokenId: \"\",\n      decimals: \"1\"\n    }, tokenInfo);\n    const [tokenURI, balance] = await Promise.all([this.getCollectibleTokenURI(returnNftItem.tokenId, this.nftStandard), !returnNftItem.tokenBalance ? this.fetchNftBalance(userAddress, returnNftItem.tokenId) : Promise.resolve(\"0\")]);\n    returnNftItem.tokenBalance = returnNftItem.tokenBalance || balance;\n    // some people put full json object in uri\n    try {\n      const object = JSON.parse(tokenURI);\n      returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);\n      returnNftItem.name = returnNftItem.name || object.name;\n      returnNftItem.description = returnNftItem.description || object.description;\n      returnNftItem.decimals = returnNftItem.decimals || object.decimals;\n    } catch (error) {\n      log.warn(\"Token uri is not a valid json object\", error);\n    }\n    const finalTokenMetaUri = sanitizeNftMetdataUrl(tokenURI);\n    try {\n      if (!returnNftItem.description || !returnNftItem.image || !returnNftItem.name) {\n        // this call might fail, if metadata url available in smart contract is not reachable\n        const object = await get(finalTokenMetaUri);\n        returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);\n        returnNftItem.name = returnNftItem.name || object.name;\n        returnNftItem.description = returnNftItem.description || object.description;\n        returnNftItem.decimals = returnNftItem.decimals || object.decimals;\n      }\n    } catch (error) {\n      log.error(\"Failed to fetch nft metadata\", error);\n    }\n    return returnNftItem;\n  }\n  async getContractMetadata() {\n    const returnNft = {\n      chainId: this.chainId,\n      contractAddress: this.contractAddress,\n      contractName: this.contractName,\n      contractSymbol: this.contractSymbol,\n      nftStandard: this.nftStandard,\n      contractImage: this.contractImage,\n      contractDescription: this.contractDescription,\n      contractFallbackLogo: this.contractFallbackLogo,\n      contractSupply: this.contractSupply\n    };\n    if (!this.nftStandard) {\n      const {\n        standard,\n        isSpecial\n      } = await this.checkNftStandard();\n      returnNft.nftStandard = standard;\n      this.nftStandard = standard;\n      this.isSpecial = isSpecial;\n    }\n    if (!this.contractName || !this.contractSymbol || !this.contractDescription) {\n      const abi = this.nftStandard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;\n      const contract = new Contract(this.contractAddress, abi, this.provider);\n      const [name, symbol] = await Promise.all([contract.name(), contract.symbol()]);\n      returnNft.contractName = name;\n      returnNft.contractSymbol = symbol;\n      if (!this.contractName) this.contractName = name;\n      if (!this.contractSymbol) this.contractSymbol = symbol;\n    }\n    return returnNft;\n  }\n  async fetchNftBalance(userAddress, tokenId) {\n    const {\n      standard\n    } = await this.checkNftStandard();\n    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;\n    const contract = new Contract(this.contractAddress, abi, this.provider);\n    if (standard === CONTRACT_TYPE_ERC1155) {\n      const balance = await contract.balanceOf(userAddress, tokenId);\n      return balance;\n    }\n    let owner = \"\";\n    try {\n      owner = await contract.ownerOf(tokenId);\n    } catch {\n      throw new Error(\"Token id doesn't exists\");\n    }\n    if (owner.toLowerCase() === userAddress.toLowerCase()) {\n      return \"1\";\n    }\n    return \"0\";\n  }\n  async checkNftStandard() {\n    // For Cryptokitties\n    if (this.nftStandard && this.isSpecial !== undefined) return;\n    if (Object.prototype.hasOwnProperty.call(OLD_ERC721_LIST, this.contractAddress.toLowerCase())) {\n      this.nftStandard = CONTRACT_TYPE_ERC721;\n      this.isSpecial = true;\n      return {\n        standard: CONTRACT_TYPE_ERC721,\n        isSpecial: true\n      };\n    }\n    const isErc721 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC721, ERC721_INTERFACE_ID);\n    if (isErc721) {\n      this.nftStandard = CONTRACT_TYPE_ERC721;\n      this.isSpecial = false;\n      return {\n        standard: CONTRACT_TYPE_ERC721,\n        isSpecial: false\n      };\n    }\n    const isErc1155 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC1155, ERC1155_INTERFACE_ID);\n    if (isErc1155) {\n      this.nftStandard = CONTRACT_TYPE_ERC1155;\n      this.isSpecial = false;\n      return {\n        standard: CONTRACT_TYPE_ERC1155,\n        isSpecial: false\n      };\n    }\n    throw new Error(\"Unsupported nft standard\");\n  }\n  async contractSupportsInterface(standard, interfaceId) {\n    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;\n    const contract = new Contract(this.contractAddress, abi, this.provider);\n    return contract.supportsInterface(interfaceId);\n  }\n  async getCollectibleTokenURI(tokenId, standard = CONTRACT_TYPE_ERC721) {\n    const method = standard === CONTRACT_TYPE_ERC721 ? \"tokenURI\" : \"uri\";\n    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;\n    const contract = new Contract(this.contractAddress, abi, this.provider);\n    return contract[method](tokenId);\n  }\n}\n\nconst DEFAULT_INTERVAL$1 = 180 * 1000;\nclass NftsController extends BaseController {\n  constructor({\n    config,\n    state,\n    provider,\n    getCustomNfts,\n    getSimpleHashNfts,\n    onPreferencesStateChange,\n    onNetworkStateChange\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"name\", \"NftsController\");\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"ethersProvider\", void 0);\n    _defineProperty(this, \"_timer\", void 0);\n    _defineProperty(this, \"getCustomNfts\", void 0);\n    _defineProperty(this, \"getSimpleHashNfts\", void 0);\n    this.provider = provider;\n    this.ethersProvider = new BrowserProvider(this.provider, \"any\");\n    this.getCustomNfts = getCustomNfts;\n    this.getSimpleHashNfts = getSimpleHashNfts;\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL$1,\n      selectedAddress: \"\",\n      chainId: \"\"\n    };\n    this.defaultState = {\n      nfts: {}\n    };\n    this.initialize();\n    onPreferencesStateChange(preferencesState => {\n      if (preferencesState.selectedAddress !== this.config.selectedAddress) {\n        this.configure({\n          selectedAddress: preferencesState.selectedAddress\n        });\n        this.restartNftDetection();\n      }\n    });\n    onNetworkStateChange(networkState => {\n      const {\n        chainId\n      } = networkState.providerConfig;\n      if (chainId !== this.config.chainId) {\n        this.configure({\n          chainId\n        });\n        this.restartNftDetection();\n      }\n    });\n  }\n  get userSelectedAddress() {\n    return this.config.selectedAddress;\n  }\n  get userNfts() {\n    var _this$state$nfts$this;\n    if (!this.userSelectedAddress) return [];\n    return (_this$state$nfts$this = this.state.nfts[this.userSelectedAddress]) !== null && _this$state$nfts$this !== void 0 ? _this$state$nfts$this : [];\n  }\n  get interval() {\n    return this.config.interval;\n  }\n  set interval(interval) {\n    if (this._timer) window.clearInterval(this._timer);\n    if (!interval) {\n      return;\n    }\n    this._timer = window.setInterval(() => {\n      if (!idleTimeTracker.checkIfIdle()) {\n        this.detectNewNfts();\n        this.refreshNftBalances();\n      }\n    }, interval);\n  }\n  startNftDetection(selectedAddress) {\n    this.configure({\n      selectedAddress\n    });\n    this.restartNftDetection();\n  }\n\n  /**\n   * Restart nft detection polling period and call detectNewNfts\n   * in case of address change or user session initialization.\n   *\n   */\n  restartNftDetection() {\n    if (!this.userSelectedAddress) {\n      return;\n    }\n    this.detectNewNfts();\n    this.refreshNftBalances();\n    this.config.interval = DEFAULT_INTERVAL$1;\n  }\n  detectNewNfts() {\n    const userAddress = this.userSelectedAddress;\n    if (!userAddress) return;\n    const currentChainId = this.config.chainId;\n    const nftsToDetect = []; // object[]\n    if (!currentChainId) {\n      this.update({\n        nfts: {\n          [userAddress]: [...nftsToDetect]\n        }\n      });\n      return;\n    }\n    if (this.getCustomNfts) {\n      const customNfts = this.getCustomNfts(userAddress);\n      const reducedNfts = customNfts.reduce((acc, x) => {\n        // first aggregate by contract address\n        if (x.network === currentChainId) {\n          const newAsset = {\n            description: \"\",\n            image: \"\",\n            name: \"\",\n            tokenBalance: \"\",\n            tokenId: x.nft_id,\n            customNftId: x.id.toString()\n          };\n          if (acc[x.nft_address]) {\n            acc[x.nft_address].assets.push(newAsset);\n          } else {\n            const objToPush = {\n              assets: [newAsset],\n              chainId: x.network,\n              contractAddress: x.nft_address,\n              contractName: \"\",\n              contractSymbol: \"\",\n              contractImage: \"\",\n              nftStandard: x.nft_contract_standard,\n              contractDescription: \"\"\n            };\n            acc[x.nft_address] = objToPush;\n          }\n        }\n        return acc;\n      }, {});\n      nftsToDetect.push(...Object.values(reducedNfts));\n    }\n    this.update({\n      nfts: {\n        [userAddress]: [...nftsToDetect]\n      }\n    });\n  }\n  async refreshNftBalances() {\n    const userAddress = this.userSelectedAddress;\n    if (userAddress === \"\") return;\n    const oldNfts = [...this.userNfts];\n    const nonZeroNfts = [];\n    try {\n      const currentChainId = this.config.chainId;\n      if (SIMPLEHASH_SUPPORTED_CHAINS.includes(currentChainId)) {\n        const simpleHashBalances = await this.getSimpleHashNfts(userAddress, currentChainId);\n        nonZeroNfts.push(...simpleHashBalances);\n        this.update({\n          nfts: {\n            [userAddress]: nonZeroNfts\n          }\n        });\n      }\n      if (oldNfts.length > 0) {\n        this.getNftBalancesUsingHandler(oldNfts);\n      }\n    } catch (error) {\n      log.error(error, \"unable to fetch nft balances\");\n    }\n  }\n  async getNftBalancesUsingHandler(customNfts) {\n    if (!this.userSelectedAddress) return;\n    const userAddress = this.userSelectedAddress;\n    const currentNetworkNfts = customNfts;\n    const promiseSettledResult = await Promise.allSettled(currentNetworkNfts.map(async x => {\n      try {\n        const tokenInstance = new NftHandler(_objectSpread(_objectSpread({}, x), {}, {\n          provider: this.ethersProvider\n        }));\n        const contractData = await tokenInstance.getContractMetadata();\n        const assetData = await Promise.allSettled(x.assets.map(y => tokenInstance.getNftMetadata(userAddress, y)));\n        return _objectSpread(_objectSpread({}, contractData), {}, {\n          assets: assetData.filter(z => z.status === \"fulfilled\").map(z => z.value)\n        });\n      } catch (error) {\n        log.warn(\"Invalid contract address while fetching\", error);\n        return undefined;\n      }\n    }));\n    const nonZeroTokens = promiseSettledResult.filter(x => x.status === \"fulfilled\").map(x => x.value);\n    this.update({\n      nfts: {\n        [userAddress]: deepmerge(this.userNfts, nonZeroTokens)\n      }\n    });\n  }\n}\n\nclass PreferencesController extends BasePreferencesController {\n  constructor({\n    config,\n    state,\n    provider,\n    signAuthMessage,\n    getProviderConfig,\n    setProviderConfig,\n    validateSignMessage\n  }) {\n    super({\n      config,\n      state,\n      defaultPreferences: {\n        formattedPastTransactions: [],\n        fetchedPastTx: [],\n        paymentTx: [],\n        etherscanTransactions: []\n      },\n      signAuthMessage,\n      validateSignMessage\n    });\n    _defineProperty(this, \"_handle\", void 0);\n    _defineProperty(this, \"_mutex\", new Mutex());\n    _defineProperty(this, \"getProviderConfig\", void 0);\n    _defineProperty(this, \"setProviderConfig\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    this.provider = provider;\n    this.getProviderConfig = getProviderConfig;\n    this.setProviderConfig = setProviderConfig;\n  }\n  async poll(interval) {\n    var _this$getAddressState;\n    const releaseLock = await this._mutex.acquire();\n    if (interval) this.configure({\n      pollInterval: interval\n    });\n    if (this._handle) window.clearTimeout(this._handle);\n    // call here\n    const storeSelectedAddress = this.state.selectedAddress;\n    if (!storeSelectedAddress) return;\n    if (!((_this$getAddressState = this.getAddressState(storeSelectedAddress)) !== null && _this$getAddressState !== void 0 && _this$getAddressState.jwtToken)) return;\n    // This should never throw\n    await this.sync(storeSelectedAddress);\n    releaseLock();\n    this._handle = window.setTimeout(() => {\n      this.poll(this.config.pollInterval);\n    }, this.config.pollInterval);\n  }\n  async initPreferences(params) {\n    const {\n      address,\n      jwtToken,\n      calledFromEmbed,\n      userInfo,\n      rehydrate,\n      locale = \"en\",\n      type,\n      signatures,\n      web3AuthClientId,\n      web3AuthNetwork,\n      loginMode,\n      sessionPubKey\n    } = params;\n    await super.init({\n      address,\n      userInfo,\n      idToken: jwtToken,\n      type,\n      metadata: {\n        email: userInfo.email,\n        signatures,\n        network: web3AuthNetwork\n      }\n    });\n    const {\n      aggregateVerifier,\n      verifier,\n      verifierId\n    } = userInfo || {};\n    const userExists = await this.sync(address);\n    if (!userExists) {\n      const accountState = this.getAddressState(address);\n      await this.createUser({\n        selectedCurrency: accountState.selectedCurrency,\n        theme: accountState.theme,\n        verifier: aggregateVerifier || verifier,\n        verifierId,\n        locale,\n        address,\n        type,\n        web3AuthNetwork\n      });\n    }\n    this.storeUserLogin({\n      verifier: aggregateVerifier || verifier,\n      verifierId,\n      options: {\n        calledFromEmbed,\n        rehydrate\n      },\n      address,\n      web3AuthClientId,\n      web3AuthNetwork,\n      sessionPubKey,\n      loginMode\n    });\n  }\n  getSelectedAddress() {\n    return this.state.selectedAddress;\n  }\n  async sync(address) {\n    try {\n      const user = await this.getUser(address);\n      if (user) {\n        const {\n          default_currency: defaultCurrency,\n          contacts,\n          theme,\n          locale,\n          public_address: userPublicAddress,\n          default_public_address: defaultPublicAddress,\n          customNetworks,\n          customTokens,\n          customNfts,\n          account_type: accountType\n        } = user || {};\n\n        // update latest data in state.\n        this.updateState({\n          contacts,\n          theme,\n          selectedCurrency: defaultCurrency,\n          locale,\n          defaultPublicAddress: defaultPublicAddress || userPublicAddress,\n          customTokens,\n          customNfts,\n          customNetworks,\n          accountType: accountType\n        }, address);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      if (isUnauthorizedError(error)) {\n        throw error;\n      }\n      log.error(error);\n      return false;\n    } finally {\n      this.getWalletOrders(address).then(walletTx => {\n        // eslint-disable-next-line promise/always-return\n        if (walletTx && walletTx.length > 0) {\n          this.updateState({\n            fetchedPastTx: [...walletTx]\n          }, address);\n          this.calculatePastTx(walletTx, address);\n        }\n      }).catch(error => log.error(error));\n    }\n  }\n  async patchNewTx(tx, address) {\n    var _this$getAddressState2;\n    const formattedTx = formatPastTx({\n      transaction: tx,\n      blockExplorerUrl: this.getBlockExplorerUrl()\n    });\n    const storePastTx = ((_this$getAddressState2 = this.getAddressState(address)) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.formattedPastTransactions) || [];\n    const duplicateIndex = storePastTx.findIndex(x => x.transaction_hash === tx.transaction_hash && x.chainId === tx.chain_id);\n    if (tx.status === TransactionStatus.submitted || tx.status === TransactionStatus.confirmed) {\n      if (duplicateIndex === -1) {\n        var _tx$to;\n        // No duplicate found\n\n        const finalTx = this.cancelTxCalculate([...storePastTx, formattedTx]);\n        tx.is_cancel = formattedTx.is_cancel;\n        tx.to = (_tx$to = tx.to) === null || _tx$to === void 0 ? void 0 : _tx$to.toLowerCase();\n        tx.from = tx.from.toLowerCase();\n        this.updateState({\n          formattedPastTransactions: finalTx\n        }, address);\n        this.postPastTx(tx, address);\n      } else {\n        // avoid overriding is_cancel\n        formattedTx.is_cancel = storePastTx[duplicateIndex].is_cancel;\n        storePastTx[duplicateIndex] = formattedTx;\n        this.updateState({\n          formattedPastTransactions: this.cancelTxCalculate([...storePastTx])\n        }, address);\n      }\n    }\n  }\n  recalculatePastTx(address) {\n    // This triggers store update which calculates past Tx status for that network\n    const selectedAddress = address || this.state.selectedAddress;\n    const state = this.getAddressState(selectedAddress);\n    if (!(state !== null && state !== void 0 && state.fetchedPastTx)) return;\n    this.calculatePastTx(state.fetchedPastTx, selectedAddress);\n  }\n  async refetchEtherscanTx(address) {\n    var _this$getAddressState3;\n    const selectedAddress = address || this.state.selectedAddress;\n    if (!selectedAddress) return [];\n    const lowerCaseSelectedAddress = selectedAddress === null || selectedAddress === void 0 ? void 0 : selectedAddress.toLowerCase();\n    if ((_this$getAddressState3 = this.getAddressState(selectedAddress)) !== null && _this$getAddressState3 !== void 0 && _this$getAddressState3.jwtToken) {\n      const {\n        chainId\n      } = this.getProviderConfig();\n      if (ETHERSCAN_SUPPORTED_CHAINS.includes(chainId)) {\n        const etherscanTxn = await this.fetchEtherscanTx({\n          selectedAddress,\n          chainId: this.getProviderConfig().chainId\n        });\n        const finalEthScanTxn = await addEtherscanTransactions({\n          txn: etherscanTxn,\n          lowerCaseSelectedAddress,\n          provider: this.provider,\n          chainId,\n          blockExplorerUrl: this.getBlockExplorerUrl()\n        });\n        log.info(\"Formatted Etherscan Response\", finalEthScanTxn);\n        this.updateState({\n          etherscanTransactions: finalEthScanTxn\n        });\n        return etherscanTxn;\n      }\n    }\n  }\n  async fetchEtherscanTx(parameters) {\n    try {\n      const response = await this.wsApiClient.authGet(`etherscan?chainId=${parameters.chainId}`, this.authCredentials(parameters.selectedAddress));\n      log.info(\"Etherscan Response API\", response);\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to fetch etherscan tx\", error);\n      return [];\n    }\n  }\n  async getEtherScanTokens(address, chainId) {\n    const selectedAddress = address;\n    const result = await this.wsApiClient.authGet(`tokens?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());\n    return result.data;\n  }\n  async getSimpleHashNfts(address, chainId) {\n    const selectedAddress = address;\n    const result = await this.wsApiClient.authGet(`nfts?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());\n    return result.data;\n  }\n  getCustomTokens(address) {\n    var _this$getAddressState4, _this$getAddressState5;\n    return (_this$getAddressState4 = (_this$getAddressState5 = this.getAddressState(address)) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.customTokens) !== null && _this$getAddressState4 !== void 0 ? _this$getAddressState4 : [];\n  }\n  getCustomNfts(address) {\n    var _this$getAddressState6, _this$getAddressState7;\n    return (_this$getAddressState6 = (_this$getAddressState7 = this.getAddressState(address)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.customNfts) !== null && _this$getAddressState6 !== void 0 ? _this$getAddressState6 : [];\n  }\n  isChainIdSupported(address, chainId) {\n    const approveChainOptions = this.getChainOptions(address);\n    const providerConfig = approveChainOptions.find(x => stripHexPrefix(x.chainId) === chainId);\n    return !!providerConfig;\n  }\n  async addChain(network) {\n    const approveChainOptions = this.getChainOptions();\n    const providerConfig = approveChainOptions.find(x => x.chainId === network.chainId);\n    if (providerConfig) return;\n    const newNetwork = {\n      displayName: network.chainName,\n      rpcTarget: network.rpcUrls[0],\n      ticker: network.nativeCurrency.symbol,\n      chainId: network.chainId,\n      blockExplorerUrl: network.blockExplorerUrls[0],\n      tickerName: network.nativeCurrency.name,\n      logo: network.nativeCurrency.symbol\n    };\n    const isSuccess = await this.addCustomNetwork({\n      network: newNetwork\n    });\n    if (!isSuccess) throw new Error(\"unable to add custom network\");\n  }\n  switchChain(data) {\n    const chainOptions = this.getChainOptions();\n    const providerConfig = chainOptions.find(x => x.chainId === data.chainId);\n    if (providerConfig) {\n      this.setProviderConfig(providerConfig);\n    } else {\n      throw new Error(`chainId ${data.chainId} is not supported`);\n    }\n  }\n\n  // Custom Network methods\n  async addCustomNetwork({\n    network\n  }) {\n    try {\n      const {\n        selectedAddress\n      } = this.state;\n      const payload = {\n        network_name: network.displayName,\n        rpc_url: network.rpcTarget,\n        chain_id: network.chainId,\n        symbol: network.ticker,\n        block_explorer_url: network.blockExplorerUrl || undefined,\n        is_testnet: network.isTestnet || false,\n        logo: network.logo,\n        symbol_name: network.tickerName\n      };\n      const res = await this.wsApiClient.authPost(\"customnetwork\", payload, this.authCredentials(selectedAddress), {\n        useAPIKey: true\n      });\n      await this.sync(selectedAddress);\n      return res.data.id;\n    } catch {\n      log.error(\"error adding custom network\");\n      return null;\n    }\n  }\n  async deleteCustomNetwork(id) {\n    try {\n      const {\n        selectedAddress\n      } = this.state;\n      await this.wsApiClient.authRemove(`customnetwork/${id}`, {}, this.authCredentials(selectedAddress), {\n        useAPIKey: true\n      });\n      await this.sync(selectedAddress);\n      return true;\n    } catch {\n      log.error(\"error deleting custom network\");\n      return false;\n    }\n  }\n  async editCustomNetwork({\n    network,\n    id\n  }) {\n    try {\n      const {\n        selectedAddress\n      } = this.state;\n      const payload = {\n        network_name: network.displayName,\n        rpc_url: network.rpcTarget,\n        chain_id: network.chainId,\n        symbol: network.ticker || undefined,\n        block_explorer_url: network.blockExplorerUrl || undefined,\n        is_testnet: network.isTestnet || false\n      };\n      await this.wsApiClient.authPatch(`customnetwork/${id}`, payload, this.authCredentials(selectedAddress), {\n        useAPIKey: true\n      });\n      await this.sync(selectedAddress);\n      return true;\n    } catch {\n      log.error(\"error editing custom network\");\n      return false;\n    }\n  }\n  getChainOptions(address = this.state.selectedAddress) {\n    var _identities$address$c, _identities$address;\n    const {\n      identities\n    } = this.state;\n    const customNetworks = (_identities$address$c = (_identities$address = identities[address]) === null || _identities$address === void 0 ? void 0 : _identities$address.customNetworks) !== null && _identities$address$c !== void 0 ? _identities$address$c : [];\n    const custom = Object.values(customNetworks).reduce((chains, network) => {\n      const networkItem = {\n        blockExplorerUrl: network.block_explorer_url,\n        chainId: network.chain_id,\n        displayName: network.network_name,\n        logo: \"eth.svg\",\n        rpcTarget: network.rpc_url,\n        ticker: network.symbol,\n        tickerName: network.symbol.toUpperCase(),\n        isCustom: true,\n        id: network.id\n      };\n      if (Object.keys(SUPPORTED_NETWORKS).includes(networkItem.chainId)) return chains;\n      chains.push(networkItem);\n      return chains;\n    }, []);\n    const supported = Object.values(SUPPORTED_NETWORKS).reduce((chains, network) => {\n      chains.push(network);\n      return chains;\n    }, []);\n    return [...supported, ...custom];\n  }\n  getBlockExplorerUrl() {\n    const supportedNetworks = this.getChainOptions();\n    const network = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);\n    if (!network) return \"\";\n    return `${network.blockExplorerUrl}`;\n  }\n  async calculatePastTx(txs, address) {\n    const pastTx = [];\n    const pendingTx = [];\n    const lowerCaseSelectedAddress = address.toLowerCase();\n    const supportedNetworks = this.getChainOptions(address);\n    const supportedNetwork = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);\n    for (const x of txs) {\n      var _x$to;\n      if ((supportedNetwork === null || supportedNetwork === void 0 ? void 0 : supportedNetwork.chainId) === x.chain_id && x.to && x.from && (lowerCaseSelectedAddress === x.from.toLowerCase() || lowerCaseSelectedAddress === ((_x$to = x.to) === null || _x$to === void 0 ? void 0 : _x$to.toLowerCase()))) {\n        if (x.status !== \"confirmed\") {\n          pendingTx.push(x);\n        } else {\n          const finalObject = formatPastTx({\n            transaction: x,\n            lowerCaseSelectedAddress,\n            blockExplorerUrl: this.getBlockExplorerUrl()\n          });\n          pastTx.push(finalObject);\n        }\n      }\n    }\n    const pendingTxPromises = pendingTx.map(x => getEthTxStatus(x.transaction_hash, this.provider).catch(error => log.error(error)));\n    const resolvedTxStatuses = await Promise.all(pendingTxPromises);\n    for (const [index, element] of pendingTx.entries()) {\n      const finalObject = formatPastTx({\n        transaction: element,\n        lowerCaseSelectedAddress,\n        blockExplorerUrl: this.getBlockExplorerUrl()\n      });\n      finalObject.status = resolvedTxStatuses[index] || TransactionStatus.submitted;\n      pastTx.push(finalObject);\n      if (lowerCaseSelectedAddress === element.from.toLowerCase() && finalObject.status && finalObject.status !== element.status) this.patchPastTx({\n        id: element.id,\n        status: finalObject.status\n      }, address);\n    }\n    const finalTx = this.cancelTxCalculate(pastTx);\n    this.updateState({\n      formattedPastTransactions: [...finalTx]\n    }, address);\n  }\n  cancelTxCalculate(pastTx) {\n    const nonceMap = {};\n    for (const x of pastTx) {\n      if (!nonceMap[x.nonce]) nonceMap[x.nonce] = [x];else {\n        nonceMap[x.nonce].push(x);\n      }\n    }\n    for (const [, value] of Object.entries(nonceMap)) {\n      // has duplicate\n      if (value.length > 1) {\n        // get latest and mark it as is_cancel\n        const latestTxs = value.sort((a, b) => {\n          const aDate = new Date(a.date).getTime();\n          const bDate = new Date(b.date).getTime();\n          return bDate - aDate;\n        });\n        const latestCancelTx = latestTxs[0];\n        latestCancelTx.is_cancel = true;\n        latestTxs.slice(1).forEach(x => {\n          x.hasCancel = true;\n          x.status = latestCancelTx.status === \"confirmed\" ? TransactionStatus.cancelled : TransactionStatus.cancelling;\n          x.cancelDateInitiated = `${formatTime(new Date(latestCancelTx.date).getTime())} - ${formatDate(latestCancelTx.date)}`;\n          x.etherscanLink = latestCancelTx.etherscanLink;\n          x.cancelGas = latestCancelTx.gas;\n          x.cancelGasPrice = latestCancelTx.gasPrice;\n        });\n      }\n    }\n    return pastTx;\n  }\n}\n\nclass TokenHandler {\n  constructor({\n    address,\n    symbol,\n    decimals,\n    name,\n    provider\n  }) {\n    _defineProperty(this, \"address\", void 0);\n    _defineProperty(this, \"symbol\", void 0);\n    _defineProperty(this, \"decimals\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"contract\", void 0);\n    this.address = address;\n    this.contract = new Contract(address, erc20Abi, provider);\n    this.symbol = symbol;\n    this.decimals = decimals;\n    this.name = name;\n  }\n  async getSymbol() {\n    if (!this.symbol || this.symbol === \"ERC20\") this.symbol = await this.contract.symbol();\n    return this.symbol;\n  }\n  async getDecimals() {\n    try {\n      if (!this.decimals) this.decimals = await this.contract.decimals();\n      return this.decimals;\n    } catch (error) {\n      log.warn(`Could not get decimals for token ${this.address}`, error);\n      return 0;\n    }\n  }\n  async getName() {\n    if (!this.name) this.name = await this.contract.name();\n    return this.name;\n  }\n  async getUserBalance(userAddress) {\n    if (!this.decimals) await this.getDecimals();\n    const balance = await this.contract.balanceOf(userAddress);\n    return balance.toString(16);\n  }\n}\n\nconst DEFAULT_CURRENCY = \"eth\";\nclass TokenRatesController extends BaseController {\n  constructor({\n    config,\n    state,\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    onTokensStateChange\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"conversionInterval\", void 0);\n    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {\n      contractExchangeRates: {}\n    });\n    this.initialize();\n    onPreferencesStateChange(preferencesState => {\n      const {\n        selectedAddress\n      } = preferencesState;\n      this.configure({\n        selectedAddress\n      });\n    });\n    onNetworkStateChange(networkState => {\n      const {\n        chainId,\n        ticker\n      } = networkState.providerConfig;\n      this.configure({\n        chainId,\n        nativeCurrency: ticker\n      });\n    });\n    onTokensStateChange(tokensState => {\n      const {\n        tokens\n      } = tokensState;\n      const currentUserTokens = tokens[this.config.selectedAddress];\n      if ((currentUserTokens === null || currentUserTokens === void 0 ? void 0 : currentUserTokens.length) > 0 && this.config.tokens !== tokens[this.config.selectedAddress]) {\n        this.configure({\n          tokens: tokens[this.config.selectedAddress]\n        });\n        this.updateExchangeRates();\n      }\n    });\n  }\n\n  /**\n   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is\n   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the\n   * previous interval is clear and a new one is created.\n   */\n  scheduleConversionInterval() {\n    if (this.conversionInterval) {\n      window.clearInterval(this.conversionInterval);\n    }\n    this.conversionInterval = window.setInterval(() => {\n      if (!idleTimeTracker.checkIfIdle()) {\n        this.updateExchangeRates();\n      }\n    }, this.config.pollInterval);\n  }\n  async updateExchangeRates() {\n    const chainCodes = COINGECKO_PLATFORMS_CHAIN_CODE_MAP[this.config.chainId];\n    let newContractExchangeRates = {};\n    if (!chainCodes) {\n      log.info(`ChainId ${this.config.chainId} not supported by coingecko`);\n      this.config.tokens.forEach(token => {\n        newContractExchangeRates[token.tokenAddress] = undefined;\n      });\n    } else {\n      newContractExchangeRates = await this.fetchExchangeRates(this.config.nativeCurrency, chainCodes);\n    }\n    this.update({\n      contractExchangeRates: newContractExchangeRates\n    });\n  }\n  async fetchExchangeRates(nativeCurrency, chainCodes) {\n    const contractAddresses = this.config.tokens.map(token => token.tokenAddress);\n    const isNativeCurrencySupported = COINGECKO_SUPPORTED_CURRENCIES.has(nativeCurrency.toLowerCase());\n    if (isNativeCurrencySupported) {\n      const response = await get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(\",\")}&vs_currencies=${nativeCurrency.toLowerCase()}`);\n      const newContractExchangeRates = {};\n      Object.keys(response).forEach(contractAddress => {\n        newContractExchangeRates[contractAddress] = response[contractAddress][nativeCurrency.toLowerCase()] || 0;\n      });\n      return newContractExchangeRates;\n    }\n    const [response, currencyResponse] = await Promise.all([get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(\",\")}&vs_currencies=${DEFAULT_CURRENCY}`), get(`${this.config.currencyApi}/currency?fsym=${nativeCurrency.toUpperCase()}&tsyms=${DEFAULT_CURRENCY.toUpperCase()}`)]);\n    const newContractExchangeRates = {};\n    Object.keys(response).forEach(contractAddress => {\n      newContractExchangeRates[contractAddress] = response[contractAddress][DEFAULT_CURRENCY] * Number.parseFloat(currencyResponse[DEFAULT_CURRENCY]) || 0;\n    });\n    return newContractExchangeRates;\n  }\n}\n\nfunction getObjectFromArrayBasedonKey(oldArray, key) {\n  return oldArray.reduce((acc, x) => {\n    const xkey = x[key];\n    if (typeof xkey === \"boolean\") return acc;\n    acc[xkey] = x;\n    return acc;\n  }, {});\n}\nconst mergeTokenArrays = (oldArray, newArray) => {\n  const oldMap = getObjectFromArrayBasedonKey(oldArray || [], \"tokenAddress\");\n  const newMap = getObjectFromArrayBasedonKey(newArray || [], \"tokenAddress\");\n  const finalArr = newArray;\n  Object.keys(oldMap).forEach(x => {\n    if (!newMap[x] && oldMap[x].isEtherScan) finalArr.push(oldMap[x]);\n  });\n  return finalArr;\n};\nconst DEFAULT_INTERVAL = 180 * 1000;\nclass TokensController extends BaseController {\n  constructor({\n    config,\n    state,\n    provider,\n    getCustomTokens,\n    getEtherScanTokens,\n    getProviderConfig,\n    onPreferencesStateChange,\n    onNetworkStateChange\n  }) {\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"name\", \"TokensController\");\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"ethersProvider\", void 0);\n    _defineProperty(this, \"_timer\", void 0);\n    _defineProperty(this, \"getProviderConfig\", void 0);\n    _defineProperty(this, \"getCustomTokens\", void 0);\n    _defineProperty(this, \"getEtherScanTokens\", void 0);\n    this.provider = provider;\n    this.ethersProvider = new BrowserProvider(this.provider, \"any\");\n    this.getCustomTokens = getCustomTokens;\n    this.getEtherScanTokens = getEtherScanTokens;\n    this.getProviderConfig = getProviderConfig;\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      selectedAddress: \"\",\n      chainId: \"\"\n    };\n    this.defaultState = {\n      tokens: {}\n    };\n    this.initialize();\n    onPreferencesStateChange(preferencesState => {\n      if (preferencesState.selectedAddress !== this.config.selectedAddress) {\n        this.configure({\n          selectedAddress: preferencesState.selectedAddress\n        });\n        this.restartTokenDetection();\n      }\n    });\n    onNetworkStateChange(networkState => {\n      const {\n        chainId\n      } = networkState.providerConfig;\n      if (chainId !== this.config.chainId) {\n        this.configure({\n          chainId\n        });\n        this.restartTokenDetection();\n      }\n    });\n  }\n  get userSelectedAddress() {\n    return this.config.selectedAddress;\n  }\n  get userTokens() {\n    var _this$state$tokens$th;\n    if (!this.userSelectedAddress) return [];\n    return (_this$state$tokens$th = this.state.tokens[this.userSelectedAddress]) !== null && _this$state$tokens$th !== void 0 ? _this$state$tokens$th : [];\n  }\n  get interval() {\n    return this.config.interval;\n  }\n  set interval(interval) {\n    if (this._timer) window.clearInterval(this._timer);\n    if (!interval) {\n      return;\n    }\n    this._timer = window.setInterval(() => {\n      if (!idleTimeTracker.checkIfIdle()) {\n        this.detectNewTokens();\n        this.refreshTokenBalances();\n      }\n    }, interval);\n  }\n  startTokenDetection(selectedAddress) {\n    this.configure({\n      selectedAddress\n    });\n    this.restartTokenDetection();\n  }\n\n  /**\n   * Restart token detection polling period and call detectNewTokens\n   * in case of address change or user session initialization.\n   *\n   */\n  restartTokenDetection() {\n    if (!this.userSelectedAddress) {\n      return;\n    }\n    this.detectNewTokens();\n    this.refreshTokenBalances();\n    this.config.interval = DEFAULT_INTERVAL;\n  }\n  detectNewTokens() {\n    const userAddress = this.userSelectedAddress;\n    if (!userAddress) return;\n    const currentChainId = this.config.chainId;\n    const tokens = []; // object[]\n    if (!currentChainId) {\n      this.update({\n        tokens: {\n          [userAddress]: [...tokens]\n        }\n      });\n      return;\n    }\n    const networkConfig = this.getProviderConfig();\n    if (networkConfig !== null && networkConfig !== void 0 && networkConfig.isErc20 && networkConfig !== null && networkConfig !== void 0 && networkConfig.tokenAddress) {\n      tokens.push({\n        tokenAddress: networkConfig.tokenAddress,\n        name: networkConfig.tickerName,\n        logo: networkConfig.logo,\n        erc20: true,\n        symbol: networkConfig.ticker,\n        decimals: \"18\",\n        chainId: currentChainId\n      });\n    }\n    if (this.getCustomTokens) {\n      const customTokens = this.getCustomTokens(userAddress);\n      tokens.push(...customTokens.reduce((acc, x) => {\n        if (x.network === currentChainId) acc.push({\n          tokenAddress: x.token_address,\n          name: x.token_name,\n          logo: \"eth.svg\",\n          erc20: true,\n          symbol: x.token_symbol,\n          decimals: x.decimals,\n          balance: \"\",\n          customTokenId: x.id.toString(),\n          chainId: x.network\n        });\n        return acc;\n      }, []));\n    }\n    this.update({\n      tokens: {\n        [userAddress]: [...tokens]\n      }\n    });\n  }\n  async refreshTokenBalances() {\n    const userAddress = this.userSelectedAddress;\n    if (userAddress === \"\") return;\n    const oldTokens = [...this.userTokens];\n    const tokenAddresses = oldTokens.map(x => x.tokenAddress);\n    const nonZeroTokens = [];\n    try {\n      const currentChainId = this.config.chainId;\n      if (ETHERSCAN_SUPPORTED_CHAINS.includes(currentChainId)) {\n        const etherscanBalances = await this.getEtherScanTokens(userAddress, currentChainId);\n        nonZeroTokens.push(...etherscanBalances);\n      }\n      if (tokenAddresses.length > 0) {\n        const currentSingleCallAddress = SINGLE_CALL_BALANCES_ADDRESSES[currentChainId];\n        if (currentSingleCallAddress) {\n          const ethContract = new Contract(currentSingleCallAddress, singleBalanceCheckerAbi, this.ethersProvider);\n          const result = await ethContract.balances([userAddress], tokenAddresses);\n          tokenAddresses.forEach((_, index) => {\n            const balance = toQuantity(result[index]);\n            if (balance && balance !== \"0x0\") {\n              nonZeroTokens.push(_objectSpread(_objectSpread({}, oldTokens[index]), {}, {\n                balance,\n                chainId: currentChainId\n              }));\n            }\n          });\n        } else {\n          this.getTokenBalancesUsingHandler(oldTokens);\n        }\n      }\n    } catch (error) {\n      log.error(error, \"unable to fetch token balances using single call balance address\");\n      this.getTokenBalancesUsingHandler(oldTokens);\n    } finally {\n      this.update({\n        tokens: {\n          [userAddress]: nonZeroTokens\n        }\n      });\n    }\n  }\n  async getTokenBalancesUsingHandler(customTokens) {\n    if (!this.userSelectedAddress) return;\n    const currentNetworkTokens = customTokens;\n    const promiseSettledResult = await Promise.allSettled(currentNetworkTokens.map(async x => {\n      try {\n        const tokenInstance = new TokenHandler({\n          address: x.tokenAddress,\n          decimals: Number.parseInt(x.decimals),\n          name: x.name,\n          symbol: x.symbol,\n          provider: this.ethersProvider\n        });\n        const balance = await tokenInstance.getUserBalance(this.userSelectedAddress);\n        return {\n          decimals: tokenInstance.decimals.toString(),\n          erc20: true,\n          logo: x.logo || \"eth.svg\",\n          name: tokenInstance.name,\n          symbol: tokenInstance.symbol,\n          tokenAddress: toChecksumAddressByChainId(tokenInstance.address, x.chainId),\n          balance: `0x${balance}`,\n          customTokenId: x.customTokenId,\n          network: x.chainId,\n          chainId: x.chainId\n        };\n      } catch (error) {\n        log.warn(\"Invalid contract address while fetching\", error);\n        return undefined;\n      }\n    }));\n    const nonZeroTokens = promiseSettledResult.filter(x => x.status === \"fulfilled\").map(x => x.value);\n    this.update({\n      tokens: {\n        [this.userSelectedAddress]: mergeTokenArrays(this.userTokens, nonZeroTokens)\n      }\n    });\n  }\n}\n\nclass NonceTracker {\n  constructor({\n    provider,\n    blockTracker,\n    getPendingTransactions,\n    getConfirmedTransactions\n  }) {\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"blockTracker\", void 0);\n    _defineProperty(this, \"getPendingTransactions\", void 0);\n    _defineProperty(this, \"getConfirmedTransactions\", void 0);\n    _defineProperty(this, \"lockMap\", void 0);\n    this.provider = provider;\n    this.blockTracker = blockTracker;\n    this.getPendingTransactions = getPendingTransactions;\n    this.getConfirmedTransactions = getConfirmedTransactions;\n    this.lockMap = {};\n  }\n  async getGlobalLock() {\n    const globalMutex = this._lookupMutex(\"global\");\n    // await global mutex free\n    const releaseLock = await globalMutex.acquire();\n    return {\n      releaseLock\n    };\n  }\n\n  /**\n    this will return an object with the `nextNonce` \n    `nonceDetails`, and the releaseLock.\n    Note: releaseLock must be called after adding a signed tx \n    to pending transactions (or discarding).\n  */\n  async getNonceLock(address) {\n    // await global mutex free\n    await this._globalMutexFree();\n    // await lock free, then take lock\n    const releaseLock = await this._takeMutex(address);\n    try {\n      // evaluate multiple nextNonce strategies\n      const nonceDetails = {};\n      const networkNonceResult = await this._getNetworkNextNonce(address);\n      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address);\n      const nextNetworkNonce = networkNonceResult.nonce;\n      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed);\n      const pendingTxs = this.getPendingTransactions(address);\n      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested);\n      nonceDetails.params = {\n        highestLocallyConfirmed,\n        highestSuggested,\n        nextNetworkNonce\n      };\n      nonceDetails.local = localNonceResult;\n      nonceDetails.network = networkNonceResult;\n      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce);\n\n      // return nonce and release cb\n      return {\n        nextNonce,\n        nonceDetails,\n        releaseLock\n      };\n    } catch (error) {\n      // release lock if we encounter an error\n      releaseLock();\n      throw error;\n    }\n  }\n  async _globalMutexFree() {\n    const globalMutex = this._lookupMutex(\"global\");\n    const releaseLock = await globalMutex.acquire();\n    releaseLock();\n  }\n  async _takeMutex(lockId) {\n    const mutex = this._lookupMutex(lockId);\n    const releaseLock = await mutex.acquire();\n    return releaseLock;\n  }\n  _lookupMutex(lockId) {\n    let mutex = this.lockMap[lockId];\n    if (!mutex) {\n      mutex = new Mutex();\n      this.lockMap[lockId] = mutex;\n    }\n    return mutex;\n  }\n  async _getNetworkNextNonce(address) {\n    // calculate next nonce\n    // we need to make sure our base count\n    // and pending count are from the same block\n    const block = await this.blockTracker.getLatestBlock();\n    const baseCountStr = await this.provider.request({\n      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,\n      params: [address, block.idempotencyKey]\n    });\n    const baseCount = Number.parseInt(baseCountStr, 16);\n    const nonceDetails = {\n      block,\n      baseCount\n    };\n    return {\n      name: \"network\",\n      nonce: baseCount,\n      details: nonceDetails\n    };\n  }\n  _getHighestLocallyConfirmed(address) {\n    const confirmedTransactions = this.getConfirmedTransactions(address);\n    const highest = this._getHighestNonce(confirmedTransactions);\n    return Number.isInteger(highest) ? highest + 1 : 0;\n  }\n  _getHighestNonce(txList) {\n    const nonces = txList.map(txMeta => {\n      const {\n        nonce\n      } = txMeta.transaction;\n      return Number.parseInt(nonce, 16);\n    });\n    const highestNonce = Math.max.apply(null, nonces);\n    return highestNonce;\n  }\n  _getHighestContinuousFrom(txList, startPoint) {\n    const nonces = new Set(txList.map(txMeta => {\n      const {\n        nonce\n      } = txMeta.transaction;\n      return Number.parseInt(nonce, 16);\n    }));\n    let highest = startPoint;\n    while (nonces.has(highest)) {\n      highest += 1;\n    }\n    return {\n      name: \"local\",\n      nonce: highest,\n      details: {\n        startPoint,\n        highest\n      }\n    };\n  }\n}\n\nclass PendingTransactionTracker extends SafeEventEmitter {\n  constructor({\n    provider,\n    nonceTracker,\n    approveTransaction,\n    publishTransaction,\n    getPendingTransactions,\n    getConfirmedTransactions\n  }) {\n    super();\n    _defineProperty(this, \"DROPPED_BUFFER_COUNT\", 3);\n    _defineProperty(this, \"nonceTracker\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"approveTransaction\", void 0);\n    _defineProperty(this, \"droppedBlocksBufferByHash\", void 0);\n    _defineProperty(this, \"getConfirmedTransactions\", void 0);\n    _defineProperty(this, \"getPendingTransactions\", void 0);\n    _defineProperty(this, \"publishTransaction\", void 0);\n    this.provider = provider;\n    this.nonceTracker = nonceTracker;\n    this.approveTransaction = approveTransaction;\n    this.publishTransaction = publishTransaction;\n    this.getPendingTransactions = getPendingTransactions;\n    this.getConfirmedTransactions = getConfirmedTransactions;\n    this.droppedBlocksBufferByHash = new Map();\n  }\n\n  /**\n    checks the network for signed txs and releases the nonce global lock if it is\n  */\n  async updatePendingTxs() {\n    // in order to keep the nonceTracker accurate we block it while updating pending transactions\n    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();\n    try {\n      const pendingTxs = this.getPendingTransactions();\n      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));\n    } catch (error) {\n      log.error(\"PendingTransactionTracker - Error updating pending transactions\");\n      log.error(error);\n    }\n    nonceGlobalLock.releaseLock();\n  }\n  async resubmitPendingTxs(block) {\n    const pending = this.getPendingTransactions();\n    // only try resubmitting if their are transactions to resubmit\n    if (pending.length === 0) return;\n    // Keep this as a for loop because we want to wait for each item to be submitted\n    for (const txMeta of pending) {\n      try {\n        await this._resubmitTx(txMeta, block.idempotencyKey);\n      } catch (error) {\n        var _value;\n        /*\n        Dont marked as failed if the error is a \"known\" transaction warning\n        \"there is already a transaction with the same sender-nonce\n        but higher/same gas price\"\n        Also don't mark as failed if it has ever been broadcast successfully.\n        A successful broadcast means it may still be mined.\n        */\n        const errorMessage = ((_value = error.value) === null || _value === void 0 || (_value = _value.message) === null || _value === void 0 ? void 0 : _value.toLowerCase()) || error.message.toLowerCase();\n        const isKnownTx =\n        // geth\n        errorMessage.includes(\"replacement transaction underpriced\") || errorMessage.includes(\"known transaction\") ||\n        // parity\n        errorMessage.includes(\"gas price too low to replace\") || errorMessage.includes(\"transaction with the same hash was already imported\") ||\n        // other\n        errorMessage.includes(\"gateway timeout\") || errorMessage.includes(\"nonce too low\");\n        // ignore resubmit warnings, return early\n        if (isKnownTx) return;\n        // encountered real error - transition to error state\n        txMeta.warning = {\n          error: errorMessage,\n          message: \"There was an error when resubmitting this transaction.\"\n        };\n        this.emit(TX_EVENTS.TX_WARNING, {\n          txMeta,\n          error,\n          txId: txMeta.id\n        });\n      }\n    }\n  }\n  async _resubmitTx(txMeta, latestBlockNumber) {\n    if (!txMeta.firstRetryBlockNumber) {\n      this.emit(TX_EVENTS.TX_BLOCK_UPDATE, {\n        txMeta,\n        latestBlockNumber,\n        txId: txMeta.id\n      });\n    }\n    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;\n    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);\n    const retryCount = txMeta.retryCount || 0;\n\n    // Exponential backoff to limit retries at publishing (capped at last 15 mins)\n    if (txBlockDistance <= Math.min(50, 2 ** retryCount)) return undefined;\n\n    // Only auto-submit already-signed txs:\n    if (!(\"rawTransaction\" in txMeta)) return this.approveTransaction(txMeta.id);\n    const {\n      rawTransaction\n    } = txMeta;\n    const txHash = await this.publishTransaction(rawTransaction);\n\n    // Increment successful tries:\n    this.emit(TX_EVENTS.TX_RETRY, {\n      txMeta,\n      txId: txMeta.id\n    });\n    return txHash;\n  }\n  async _checkPendingTx(foundTx) {\n    const txMeta = foundTx;\n    const txHash = txMeta.transactionHash;\n    const txId = txMeta.id;\n\n    // Only check submitted txs\n    if (txMeta.status !== TransactionStatus.submitted) return;\n\n    // extra check in case there was an uncaught error during the\n    // signature and submission process\n    if (!txHash) {\n      const noTxHashError = new Error(\"We had an error while submitting this transaction, please try again.\");\n      noTxHashError.name = \"NoTxHashError\";\n      this.emit(TX_EVENTS.TX_FAILED, {\n        txId,\n        error: noTxHashError\n      });\n      return;\n    }\n\n    // If another tx with the same nonce is mined, set as failed.\n    if (this._checkIfNonceIsTaken(txMeta)) {\n      this.emit(TX_EVENTS.TX_DROPPED, {\n        txId\n      });\n      return;\n    }\n    try {\n      const transactionReceipt = await this.provider.request({\n        method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,\n        params: [txHash]\n      });\n      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {\n        const {\n          baseFeePerGas,\n          timestamp\n        } = await this.provider.request({\n          method: METHOD_TYPES.ETH_GET_BLOCK_BY_HASH,\n          params: [transactionReceipt.blockHash, false]\n        });\n        this.emit(TX_EVENTS.TX_CONFIRMED, {\n          txId,\n          txReceipt: transactionReceipt,\n          baseFeePerGas,\n          blockTimestamp: timestamp\n        });\n        return;\n      }\n    } catch (error) {\n      log.error(\"error while loading tx\", error);\n      txMeta.warning = {\n        error: error.message,\n        message: \"There was a problem loading this transaction.\"\n      };\n      this.emit(TX_EVENTS.TX_WARNING, {\n        txMeta\n      });\n    }\n    if (await this._checkIfTxWasDropped(txMeta)) {\n      this.emit(TX_EVENTS.TX_DROPPED, {\n        txId\n      });\n    }\n  }\n  async _checkIfTxWasDropped(txMeta) {\n    const {\n      transactionHash: txHash,\n      transaction: {\n        nonce,\n        from\n      }\n    } = txMeta;\n    const networkNextNonce = await this.provider.request({\n      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,\n      params: [from, \"latest\"]\n    });\n    if (Number.parseInt(nonce, 16) >= Number.parseInt(networkNextNonce, 16)) {\n      return false;\n    }\n    if (!this.droppedBlocksBufferByHash.has(txHash)) {\n      this.droppedBlocksBufferByHash.set(txHash, 0);\n    }\n    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);\n    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {\n      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);\n      return false;\n    }\n    this.droppedBlocksBufferByHash.delete(txHash);\n    return true;\n  }\n  _checkIfNonceIsTaken(txMeta) {\n    const address = txMeta.transaction.from;\n    const completed = this.getConfirmedTransactions(address);\n    return completed.some(otherMeta => {\n      if (otherMeta.id === txMeta.id) {\n        return false;\n      }\n      return otherMeta.transaction.nonce === txMeta.transaction.nonce;\n    });\n  }\n}\n\nclass TransactionGasUtil {\n  constructor(provider, blockTracker) {\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"blockTracker\", void 0);\n    this.provider = provider;\n    this.blockTracker = blockTracker;\n  }\n  async analyzeGasUsage(txMeta) {\n    const block = await this.blockTracker.getLatestBlock();\n    // fallback to block gasLimit\n    const blockGasLimitBN = new BN$1(stripHexPrefix(block.gasLimit), 16);\n    const saferGasLimitBN = blockGasLimitBN.mul(new BN$1(19)).div(new BN$1(20));\n    let estimatedGasHex = addHexPrefix(saferGasLimitBN.toString(\"hex\"));\n    let simulationFails;\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n      simulationFails = {\n        reason: error.message,\n        errorKey: error.errorKey,\n        debug: {\n          blockNumber: block.idempotencyKey,\n          blockGasLimit: block.gasLimit\n        }\n      };\n    }\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex,\n      simulationFails\n    };\n  }\n\n  /**\n    Adds a gas buffer with out exceeding the block gas limit\n  */\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {\n    const initialGasLimitBn = new BN$1(stripHexPrefix(initialGasLimitHex), 16);\n    const blockGasLimitBn = new BN$1(stripHexPrefix(blockGasLimitHex), 16);\n    const upperGasLimitBn = blockGasLimitBn.muln(0.9);\n    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);\n\n    // if initialGasLimit is above blockGasLimit, dont modify it\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return addHexPrefix(initialGasLimitBn.toString(\"hex\"));\n    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return addHexPrefix(bufferedGasLimitBn.toString(\"hex\"));\n    // otherwise use blockGasLimit\n    return addHexPrefix(upperGasLimitBn.toString(\"hex\"));\n  }\n\n  /**\n    Estimates the tx's gas usage\n  */\n  async estimateTxGas(txMeta) {\n    const txParams = cloneDeep(txMeta.transaction);\n\n    // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    return this.provider.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n  }\n}\n\nfunction sortBy(arr, key) {\n  return arr.slice().sort((a, b) => {\n    if (a[key] < b[key]) return -1;\n    if (a[key] > b[key]) return 1;\n    return 0;\n  });\n}\nfunction keyBy(arr, key) {\n  return arr.reduce((acc, item) => {\n    const keyValue = item[key];\n    if (typeof keyValue === \"string\" || typeof keyValue === \"number\") {\n      acc[keyValue.toString()] = item;\n    }\n    return acc;\n  }, {});\n}\nfunction mapValues(obj, iteratee) {\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, iteratee(value, key)]));\n}\n\n/**\n  Generates an array of history objects sense the previous state.\n  The object has the keys\n    op (the operation performed),\n    path (the key and if a nested object then each key will be seperated with a `/`)\n    value\n  with the first entry having the note and a timestamp when the change took place\n*/\nfunction generateHistoryEntry(previousState, newState, note) {\n  const entry = jsonDiffer.compare(previousState, newState);\n  // Add a note to the first op, since it breaks if we append it to the entry\n  if (entry[0]) {\n    if (note) {\n      entry[0].note = note;\n    }\n    entry[0].timestamp = Date.now();\n  }\n  return entry;\n}\n\n/**\n  Recovers previous txMeta state obj\n*/\nfunction replayHistory(_shortHistory) {\n  const shortHistory = cloneDeep(_shortHistory);\n  return shortHistory.reduce((val, entry) => jsonDiffer.applyPatch(val, entry).newDocument);\n}\nfunction snapshotFromTxMeta(txMeta) {\n  const shallow = _objectSpread({}, txMeta);\n  delete shallow.history;\n  return cloneDeep(shallow);\n}\n\nclass TransactionStateManager extends BaseTransactionStateManager {\n  constructor({\n    config,\n    state,\n    getCurrentChainId\n  }) {\n    super({\n      config,\n      state,\n      getCurrentChainId\n    });\n  }\n  generateTxMeta(opts = {}) {\n    var _opts$transaction;\n    const chainId = this.getCurrentChainId();\n    if (chainId === \"loading\") throw new Error(\"Torus is having trouble connecting to the network\");\n    let dappSuggestedGasFees = null;\n\n    // If we are dealing with a transaction suggested by a dapp and not\n    // an internally created transaction, we need to keep record of\n    // the originally submitted gasParams.\n    if (opts.transaction && typeof opts.origin === \"string\" && opts.origin !== \"torus\") {\n      if (typeof opts.transaction.gasPrice !== \"undefined\") {\n        dappSuggestedGasFees = {\n          gasPrice: opts.transaction.gasPrice\n        };\n      } else if (typeof opts.transaction.maxFeePerGas !== \"undefined\" || typeof opts.transaction.maxPriorityFeePerGas !== \"undefined\") {\n        dappSuggestedGasFees = {\n          maxPriorityFeePerGas: opts.transaction.maxPriorityFeePerGas,\n          maxFeePerGas: opts.transaction.maxFeePerGas\n        };\n      }\n      if (typeof opts.transaction.gas !== \"undefined\") {\n        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {\n          gas: opts.transaction.gas\n        });\n      }\n    }\n    return _objectSpread({\n      id: ((_opts$transaction = opts.transaction) === null || _opts$transaction === void 0 ? void 0 : _opts$transaction.id) || randomId(),\n      time: Date.now(),\n      status: TransactionStatus.unapproved,\n      loadingDefaults: true,\n      chainId,\n      dappSuggestedGasFees\n    }, opts);\n  }\n  addTransactionToState(txMeta) {\n    if (txMeta.transaction) {\n      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);\n    }\n    this.once(`${txMeta.id}:signed`, () => {\n      this.removeAllListeners(`${txMeta.id}:rejected`);\n    });\n    this.once(`${txMeta.id}:rejected`, () => {\n      this.removeAllListeners(`${txMeta.id}:signed`);\n    });\n    // initialize history\n    txMeta.history = [];\n    // capture initial snapshot of txMeta for history\n    const snapshot = snapshotFromTxMeta(txMeta);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    txMeta.history.push(snapshot);\n    const transactions = this.getTransactions({\n      filterToCurrentNetwork: false\n    });\n    const {\n      txHistoryLimit\n    } = this.config;\n\n    // checks if the length of the tx history is longer then desired persistence\n    // limit and then if it is removes the oldest confirmed or rejected tx.\n    // Pending or unapproved transactions will not be removed by this\n    // operation. For safety of presenting a fully functional transaction UI\n    // representation, this function will not break apart transactions with the\n    // same nonce, per network. Not accounting for transactions of the same\n    // nonce and network combo can result in confusing or broken experiences\n    // in the UI.\n    //\n    // we will send UI only collected groups of transactions *per page* so at\n    // some point in the future, this persistence limit can be adjusted. When\n    // we do that I think we should figure out a better storage solution for\n    // transaction history entries.\n    const nonceNetworkSet = new Set();\n    const txsToDelete = transactions.reverse().filter(tx => {\n      const {\n        nonce\n      } = tx.transaction;\n      const {\n        chainId,\n        status\n      } = tx;\n      const key = `${nonce}-${chainId}`;\n      if (nonceNetworkSet.has(key)) {\n        return false;\n      }\n      if (nonceNetworkSet.size < txHistoryLimit - 1 || getFinalStates().includes(status) === false) {\n        nonceNetworkSet.add(key);\n        return false;\n      }\n      return true;\n    }).map(tx => tx.id);\n    this._deleteTransactions(txsToDelete);\n    this._addTransactionsToState([txMeta]);\n    return txMeta;\n  }\n\n  /**\n    Removes transaction from the given address for the current network\n    from the txList\n  */\n  wipeTransactions(address) {\n    const {\n      transactions\n    } = this.state;\n    const chainId = this.getCurrentChainId();\n    this.update({\n      transactions: omitBy(transactions, txMeta => {\n        const transactionMatch = transactionMatchesNetwork$1(txMeta, chainId);\n        return txMeta.transaction.from === address && transactionMatch;\n      })\n    });\n  }\n  getTransactions({\n    searchCriteria = {},\n    initialList = undefined,\n    filterToCurrentNetwork = true,\n    limit = undefined\n  } = {}) {\n    const chainId = this.getCurrentChainId();\n    // searchCriteria is an object that might have values that aren't predicate\n    // methods. When providing any other value type (string, number, etc), we\n    // consider this shorthand for \"check the value at key for strict equality\n    // with the provided value\". To conform this object to be only methods, we\n    // mapValues (lodash) such that every value on the object is a method that\n    // returns a boolean.\n    const predicateMethods = mapValues(searchCriteria, predicate => typeof predicate === \"function\" ? predicate : v => v === predicate);\n\n    // If an initial list is provided we need to change it back into an object\n    // first, so that it matches the shape of our state. This is done by the\n    // lodash keyBy method. This is the edge case for this method, typically\n    // initialList will be undefined.\n    const transactionsToFilter = initialList ? keyBy(initialList, \"id\") : this.state.transactions;\n\n    // Combine sortBy and pickBy to transform our state object into an array of\n    // matching transactions that are sorted by time.\n    const filteredTransactions = sortBy(Object.values(pickBy(transactionsToFilter, txMeta => {\n      // default matchesCriteria to the value of transactionMatchesNetwork\n      // when filterToCurrentNetwork is true.\n      const transactionMatches = transactionMatchesNetwork$1(txMeta, chainId);\n      if (filterToCurrentNetwork && !transactionMatches) {\n        return false;\n      }\n      // iterate over the predicateMethods keys to check if the transaction\n      // matches the searchCriteria\n      for (const [key, predicate] of Object.entries(predicateMethods)) {\n        // We return false early as soon as we know that one of the specified\n        // search criteria do not match the transaction. This prevents\n        // needlessly checking all criteria when we already know the criteria\n        // are not fully satisfied. We check both txParams and the base\n        // object as predicate keys can be either.\n        if (key in txMeta.transaction) {\n          if (predicate(txMeta.transaction[key]) === false) {\n            return false;\n          }\n        } else if (predicate(txMeta[key]) === false) {\n          return false;\n        }\n      }\n      return true;\n    })), \"time\");\n    if (limit !== undefined) {\n      // We need to have all transactions of a given nonce in order to display\n      // necessary details in the UI. We use the size of this set to determine\n      // whether we have reached the limit provided, thus ensuring that all\n      // transactions of nonces we include will be sent to the UI.\n      const nonces = new Set();\n      const txs = [];\n      // By default, the transaction list we filter from is sorted by time ASC.\n      // To ensure that filtered results prefers the newest transactions we\n      // iterate from right to left, inserting transactions into front of a new\n      // array. The original order is preserved, but we ensure that newest txs\n      // are preferred.\n      for (let i = filteredTransactions.length - 1; i > -1; i -= 1) {\n        const txMeta = filteredTransactions[i];\n        const {\n          nonce\n        } = txMeta.transaction;\n        if (!nonces.has(nonce)) {\n          if (nonces.size < limit) {\n            nonces.add(nonce);\n          } else {\n            continue;\n          }\n        }\n        // Push transaction into the beginning of our array to ensure the\n        // original order is preserved.\n        txs.unshift(txMeta);\n      }\n      return txs;\n    }\n    return filteredTransactions;\n  }\n  getApprovedTransactions(address) {\n    const searchCriteria = {\n      status: TransactionStatus.approved\n    };\n    if (address) {\n      searchCriteria.from = address;\n    }\n    return this.getTransactions({\n      searchCriteria\n    });\n  }\n  getSubmittedTransactions(address) {\n    const searchCriteria = {\n      status: TransactionStatus.submitted\n    };\n    if (address) {\n      searchCriteria.from = address;\n    }\n    return this.getTransactions({\n      searchCriteria\n    });\n  }\n  getPendingTransactions(address) {\n    const submitted = this.getSubmittedTransactions(address);\n    const approved = this.getApprovedTransactions(address);\n    return [...submitted, ...approved];\n  }\n  getConfirmedTransactions(address) {\n    const searchCriteria = {\n      status: TransactionStatus.confirmed\n    };\n    if (address) {\n      searchCriteria.from = address;\n    }\n    return this.getTransactions({\n      searchCriteria\n    });\n  }\n  getUnapprovedTxList() {\n    const chainId = this.getCurrentChainId();\n    return pickBy(this.state.transactions, transaction => {\n      const transactionMatches = transactionMatchesNetwork$1(transaction, chainId);\n      return transaction.status === TransactionStatus.unapproved && transactionMatches;\n    });\n  }\n  updateTransactionInState(txMeta, note) {\n    // validate txParams\n    if (txMeta.transaction) {\n      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);\n    }\n\n    // create txMeta snapshot for history\n    const currentState = snapshotFromTxMeta(txMeta);\n    // recover previous tx state obj\n    const previousState = replayHistory(txMeta.history);\n    // generate history entry and add to history\n    const entry = generateHistoryEntry(previousState, currentState, note);\n    if (entry.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      txMeta.history.push(entry);\n    }\n\n    // commit txMeta to state\n    this.updateTransaction(txMeta);\n  }\n  _setTransactionStatus(txId, status, isFinalStep) {\n    const txMeta = this.getTransaction(txId);\n    if (!txMeta) {\n      return;\n    }\n    txMeta.status = status;\n    this.updateTransactionInState(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n      txId,\n      status\n    });\n    if (this.isFinalState(status) || isFinalStep) {\n      this.emit(`${txMeta.id}:finished`, txMeta);\n    } else {\n      this.emit(`${txMeta.id}:${status}`, txId);\n    }\n  }\n}\n\nclass TransactionController extends TransactionStateManager {\n  constructor({\n    config,\n    state,\n    provider,\n    blockTracker,\n    signEthTx,\n    getCurrentChainId,\n    getCurrentNetworkEIP1559Compatibility,\n    getProviderConfig,\n    getCurrentAccountEIP1559Compatibility,\n    getSelectedAddress,\n    getEIP1559GasFeeEstimates\n  }) {\n    super({\n      config,\n      state,\n      getCurrentChainId\n    });\n    _defineProperty(this, \"getSelectedAddress\", void 0);\n    _defineProperty(this, \"getEIP1559GasFeeEstimates\", void 0);\n    _defineProperty(this, \"nonceTracker\", void 0);\n    _defineProperty(this, \"pendingTxTracker\", void 0);\n    _defineProperty(this, \"txGasUtil\", void 0);\n    _defineProperty(this, \"_getCurrentNetworkEIP1559Compatibility\", void 0);\n    _defineProperty(this, \"_getCurrentAccountEIP1559Compatibility\", void 0);\n    _defineProperty(this, \"getProviderConfig\", void 0);\n    _defineProperty(this, \"signEthTx\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"blockTracker\", void 0);\n    _defineProperty(this, \"inProcessOfSigning\", new Set());\n    _defineProperty(this, \"getUnapprovedTxCount\", () => Object.keys(this.getUnapprovedTxList()).length);\n    _defineProperty(this, \"getPendingTxCount\", account => this.getPendingTransactions(account).length);\n    this.blockTracker = blockTracker;\n    this.getProviderConfig = getProviderConfig;\n    this._getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;\n    this._getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;\n    this.getSelectedAddress = getSelectedAddress;\n    this.getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;\n    this.signEthTx = signEthTx;\n    this.provider = provider;\n    this.txGasUtil = new TransactionGasUtil(this.provider, this.blockTracker);\n    this.nonceTracker = new NonceTracker({\n      provider,\n      blockTracker,\n      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),\n      getPendingTransactions: this.getSubmittedTransactions.bind(this) // nonce tracker should only care about submitted transactions\n    });\n    this.pendingTxTracker = new PendingTransactionTracker({\n      provider,\n      nonceTracker: this.nonceTracker,\n      getPendingTransactions: this.getPendingTransactions.bind(this),\n      // pending tx tracker should only care about submitted and approved transactions\n      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),\n      approveTransaction: this.approveTransaction.bind(this),\n      publishTransaction: rawTx => this.provider.request({\n        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,\n        params: [rawTx]\n      })\n    });\n    this._setupListeners();\n  }\n  addTransactionUnapproved(txMeta) {\n    this.addTransactionToState(txMeta);\n    this.emit(`${txMeta.id}:unapproved`, txMeta);\n  }\n  async addNewUnapprovedTransaction(txParams, req) {\n    const txMeta = await this.createTransaction(txParams, req);\n    return this.processApproval(txMeta);\n  }\n  async processApproval(txMeta) {\n    return new Promise((resolve, reject) => {\n      const handleFinished = msg => {\n        if (msg.status === TransactionStatus.rejected) {\n          return reject(providerErrors.userRejectedRequest(`Transaction Signature: User denied message signature`));\n        }\n        if (msg.status === TransactionStatus.failed) {\n          return reject(rpcErrors.internal(`Transaction Signature: failed to sign message ${msg.error}`));\n        }\n        if (msg.status === TransactionStatus.submitted) {\n          return resolve(msg.transactionHash);\n        }\n        return reject(rpcErrors.internal(`Transaction Signature: Unknown problem: ${JSON.stringify(txMeta.transaction)}`));\n      };\n      this.once(`${txMeta.id}:finished`, handleFinished);\n    });\n  }\n  async approveTransaction(transactionID) {\n    const txMeta = this.getTransaction(transactionID);\n    if (this.inProcessOfSigning.has(transactionID)) {\n      return;\n    }\n    this.inProcessOfSigning.add(transactionID);\n    let nonceLock;\n    try {\n      this.setTxStatusApproved(transactionID);\n      const fromAddress = txMeta.transaction.from;\n      const {\n        customNonceValue\n      } = txMeta.transaction;\n      const customNonceValueNumber = Number(customNonceValue);\n      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);\n      // add nonce to txParams\n      // if txMeta has previousGasParams then it is a retry at same nonce with\n      // higher gas settings and therefor the nonce should not be recalculated\n      const nonce = nonceLock.nextNonce;\n      const customOrNonce = customNonceValueNumber === 0 ? customNonceValue : customNonceValue || nonce;\n      txMeta.transaction.nonce = addHexPrefix(customOrNonce.toString(16));\n      // add nonce debugging information to txMeta\n      txMeta.nonceDetails = nonceLock.nonceDetails;\n      this.updateTransactionInState(txMeta, \"transactions#approveTransaction\");\n      // sign transaction\n      const rawTx = await this.signTransaction(transactionID);\n      await this.publishTransaction(transactionID, rawTx);\n      nonceLock.releaseLock();\n    } catch (err) {\n      try {\n        this.setTxStatusFailed(transactionID, err);\n      } catch (err2) {\n        log.error(err2);\n      }\n      // must set transaction to submitted/failed before releasing lock\n      if (nonceLock) {\n        nonceLock.releaseLock();\n      }\n      // continue with error chain\n      throw err;\n    } finally {\n      this.inProcessOfSigning.delete(transactionID);\n    }\n  }\n  async signTransaction(txId) {\n    const txMeta = this.getTransaction(txId);\n    const chainId = this.getCurrentChainId();\n    const type = isEIP1559Transaction(txMeta) ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    const txParams = _objectSpread(_objectSpread({}, txMeta.transaction), {}, {\n      type,\n      chainId,\n      gasLimit: txMeta.transaction.gas\n    });\n    const fromAddress = txParams.from;\n    const common = await this.getCommonConfiguration(fromAddress);\n    const {\n      TransactionFactory\n    } = await import('@ethereumjs/tx');\n    const unsignedEthTx = TransactionFactory.fromTxData(txParams, {\n      common\n    });\n    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);\n    txMeta.r = addHexPrefix(signedEthTx.r.toString(16));\n    txMeta.s = addHexPrefix(signedEthTx.s.toString(16));\n    txMeta.v = addHexPrefix(signedEthTx.v.toString(16));\n    this.updateTransactionInState(txMeta, \"transactions#signTransaction: add r, s, v values\");\n    this.setTxStatusSigned(txId);\n    const rawTx = addHexPrefix(Buffer.from(signedEthTx.serialize()).toString(\"hex\"));\n    return rawTx;\n  }\n  async publishTransaction(txId, rawTx) {\n    const txMeta = this.getTransaction(txId);\n    txMeta.rawTransaction = rawTx;\n    this.updateTransactionInState(txMeta, \"transactions#publishTransaction\");\n    let txHash;\n    try {\n      txHash = await this.provider.request({\n        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,\n        params: [rawTx]\n      });\n    } catch (error) {\n      if (error.message.toLowerCase().includes(\"known transaction\")) {\n        txHash = keccak256(addHexPrefix(rawTx));\n        txHash = addHexPrefix(txHash);\n      } else {\n        throw error;\n      }\n    }\n    this.setTxHash(txId, txHash);\n    this.setTxStatusSubmitted(txId);\n  }\n  async confirmTransaction(params) {\n    const {\n      txId,\n      txReceipt\n    } = params;\n    log.info(params, \"confirm params\");\n    const txMeta = this.getTransaction(txId);\n    if (!txMeta) return;\n    try {\n      txMeta.txReceipt = _objectSpread({}, txReceipt);\n      this.setTxStatusConfirmed(txId);\n      this.markNonceDuplicatesDropped(txId);\n      this.updateTransactionInState(txMeta, \"transactions#confirmTransaction - add txReceipt\");\n    } catch (error) {\n      log.error(error);\n    }\n  }\n  cancelTransaction(transactionID) {\n    throw new Error(`Method not implemented. ${transactionID}`);\n  }\n  async getEIP1559Compatibility(fromAddress) {\n    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();\n    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);\n    return currentNetworkIsCompatible && fromAccountIsCompatible;\n  }\n  async addTransactionGasDefaults(txMeta) {\n    let updateTxMeta = txMeta;\n    try {\n      updateTxMeta = await this.addTxGasDefaults(txMeta);\n    } catch (error) {\n      log.warn(error);\n      updateTxMeta = this.getTransaction(txMeta.id);\n      updateTxMeta.loadingDefaults = false;\n      this.updateTransactionInState(txMeta, \"Failed to calculate gas defaults.\");\n      throw error;\n    }\n    updateTxMeta.loadingDefaults = false;\n    this.updateTransactionInState(updateTxMeta, \"Added new unapproved transaction.\");\n    return updateTxMeta;\n  }\n  async addTxGasDefaults(txMeta) {\n    const eip1559Compatibility = txMeta.transaction.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(txMeta, eip1559Compatibility);\n    const {\n      gasLimit: defaultGasLimit,\n      simulationFails\n    } = await this.getDefaultGasLimit(txMeta);\n    txMeta = this.getTransaction(txMeta.id);\n    if (simulationFails) {\n      txMeta.simulationFails = simulationFails;\n    }\n    if (eip1559Compatibility) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (txMeta.transaction.gasPrice && !txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {\n        txMeta.transaction.maxFeePerGas = txMeta.transaction.gasPrice;\n        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n        // then we set maxFeePerGas to the suggested gasPrice.\n\n        txMeta.transaction.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof txMeta.transaction.gasPrice === \"string\" ? stripHexPrefix(txMeta.transaction.gasPrice) : txMeta.transaction.gasPrice) ? defaultMaxPriorityFeePerGas : txMeta.transaction.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !txMeta.transaction.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          txMeta.transaction.maxFeePerGas = defaultMaxFeePerGas;\n        }\n        if (defaultMaxPriorityFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          txMeta.transaction.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n        if (defaultGasPrice && !txMeta.transaction.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          txMeta.transaction.maxFeePerGas = defaultGasPrice;\n        }\n        if (txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available from the gasFeeController, then we set maxPriorityFeePerGas to\n          // txMeta.transaction.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          txMeta.transaction.maxPriorityFeePerGas = txMeta.transaction.maxFeePerGas;\n        }\n      }\n\n      // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n      delete txMeta.transaction.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n\n      delete txMeta.transaction.maxPriorityFeePerGas;\n      delete txMeta.transaction.maxFeePerGas;\n    }\n\n    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on transaction, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n    if (defaultGasPrice && !txMeta.transaction.gasPrice && !txMeta.transaction.maxPriorityFeePerGas && !txMeta.transaction.maxFeePerGas) {\n      txMeta.transaction.gasPrice = defaultGasPrice;\n    }\n    if (defaultGasLimit && !txMeta.transaction.gas) {\n      txMeta.transaction.gas = defaultGasLimit;\n    }\n    return txMeta;\n  }\n  setTxHash(txId, txHash) {\n    // Add the tx hash to the persisted meta-tx object\n    const txMeta = this.getTransaction(txId);\n    txMeta.transactionHash = txHash;\n    this.updateTransactionInState(txMeta, \"transactions#setTxHash\");\n  }\n  async getDefaultGasFees(txMeta, eip1559Compatibility) {\n    if (!eip1559Compatibility && txMeta.transaction.gasPrice || eip1559Compatibility && txMeta.transaction.maxFeePerGas && txMeta.transaction.maxPriorityFeePerGas) {\n      return {};\n    }\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.getEIP1559GasFeeEstimates();\n      if (eip1559Compatibility && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        // this is in dec gwei\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            // send to controller in hex wei\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxFeePerGas)).toString(16)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxPriorityFeePerGas)).toString(16))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        const {\n          medium\n        } = gasFeeEstimates;\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(medium)).toString(16))\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        const {\n          gasPrice\n        } = gasFeeEstimates;\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(gasPrice)).toString(16))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n    const gasPrice = await this.provider.request({\n      method: METHOD_TYPES.ETH_GET_GAS_PRICE\n    });\n    return {\n      gasPrice: gasPrice && addHexPrefix(gasPrice)\n    };\n  }\n  async getDefaultGasLimit(txMeta) {\n    const chainId = this.getCurrentChainId();\n    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];\n    const chainType = getChainType(chainId);\n    if (txMeta.transaction.gas) {\n      return {};\n    }\n    if (txMeta.transaction.to && txMeta.transactionCategory === TRANSACTION_TYPES.SENT_ETHER && chainType !== \"custom\" && !txMeta.transaction.data) {\n      // This is a standard ether simple send, gas requirement is exactly 21k\n      return {\n        gasLimit: GAS_LIMITS.SIMPLE\n      };\n    }\n    const {\n      blockGasLimit,\n      estimatedGasHex,\n      simulationFails\n    } = await this.txGasUtil.analyzeGasUsage(txMeta);\n\n    // add additional gas buffer to our estimation for safety\n    const gasLimit = this.txGasUtil.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);\n    return {\n      gasLimit,\n      simulationFails\n    };\n  }\n  async createTransaction(txParameters, req) {\n    const normalizedTxParameters = normalizeTxParameters(txParameters);\n    const eip1559Compatibility = await this.getEIP1559Compatibility(txParameters.from);\n    validateTxParameters(normalizedTxParameters, eip1559Compatibility);\n    let txMeta = this.generateTxMeta({\n      transaction: normalizedTxParameters,\n      origin: req.origin\n    });\n    const {\n      type,\n      category,\n      methodParams\n    } = await determineTransactionType(txParameters, this.provider);\n    txMeta.contractType = type;\n    txMeta.transactionCategory = category;\n    txMeta.methodParams = methodParams;\n    txMeta.transaction.value = txMeta.transaction.value ? addHexPrefix(txMeta.transaction.value) : \"0x0\";\n    this.emit(`${txMeta.id}:unapproved`, txMeta);\n    txMeta = this.addTransactionToState(txMeta);\n    txMeta = await this.addTransactionGasDefaults(txMeta);\n    this.emit(TX_EVENTS.TX_UNAPPROVED, {\n      txMeta,\n      req\n    });\n    return txMeta;\n  }\n  _setupListeners() {\n    this.setupBlockTrackerListener();\n    this.pendingTxTracker.on(TX_EVENTS.TX_WARNING, data => {\n      this.updateTransactionInState(data.txMeta);\n    });\n    this.pendingTxTracker.on(TX_EVENTS.TX_DROPPED, data => this.setTxStatusDropped(data.txId));\n    this.pendingTxTracker.on(TX_EVENTS.TX_BLOCK_UPDATE, ({\n      txMeta,\n      latestBlockNumber\n    }) => {\n      if (!txMeta.firstRetryBlockNumber) {\n        txMeta.firstRetryBlockNumber = latestBlockNumber;\n        this.updateTransactionInState(txMeta);\n      }\n    });\n    this.pendingTxTracker.on(TX_EVENTS.TX_RETRY, txMeta => {\n      if (!(\"retryCount\" in txMeta)) {\n        txMeta.retryCount = 0;\n      }\n      txMeta.retryCount += 1;\n      this.updateTransactionInState(txMeta);\n    });\n    this.pendingTxTracker.on(TX_EVENTS.TX_FAILED, data => {\n      this.setTxStatusFailed(data.txId, data.error);\n    });\n    this.pendingTxTracker.on(TX_EVENTS.TX_CONFIRMED, data => this.confirmTransaction(data));\n  }\n  setupBlockTrackerListener() {\n    let listenersAreActive = false;\n    const latestBlockHandler = this.onLatestBlock.bind(this);\n    this.on(TX_EVENTS.TX_STATUS_UPDATE, () => {\n      const pendingTxs = this.getPendingTransactions();\n      if (!listenersAreActive && pendingTxs.length > 0) {\n        this.blockTracker.on(\"latest\", latestBlockHandler);\n        listenersAreActive = true;\n      } else if (listenersAreActive && !pendingTxs.length) {\n        this.blockTracker.removeListener(\"latest\", latestBlockHandler);\n        listenersAreActive = false;\n      }\n    });\n  }\n  async onLatestBlock(blockNumber) {\n    try {\n      await this.pendingTxTracker.updatePendingTxs();\n    } catch (error) {\n      log.error(error);\n    }\n    try {\n      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n  async getCommonConfiguration(fromAddress) {\n    const {\n      chainId,\n      displayName\n    } = this.getProviderConfig();\n    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress);\n    const {\n      Common,\n      Hardfork\n    } = await import('@ethereumjs/common');\n    const hardfork = supportsEIP1559 ? Hardfork.Paris : Hardfork.Berlin;\n    return Common.custom({\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork,\n      name: displayName,\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16)\n    });\n  }\n  markNonceDuplicatesDropped(txId) {\n    const txMeta = this.getTransaction(txId);\n    const {\n      nonce,\n      from\n    } = txMeta.transaction;\n    const sameNonceTxs = this.getTransactions({\n      searchCriteria: {\n        from,\n        nonce\n      }\n    });\n    if (!sameNonceTxs.length) return;\n    sameNonceTxs.forEach(tx => {\n      if (tx.id === txId) return;\n      this.updateTransactionInState(txMeta, \"transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce\");\n      if (tx.status !== TransactionStatus.failed) this.setTxStatusDropped(tx.id);\n    });\n  }\n}\n\nexport { ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, AccountTrackerController, AddChainController, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID, BNToHex, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, CELO_MAINNET_CHAIN_ID, CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP, COINGECKO_PLATFORMS_CHAIN_CODE_MAP, COINGECKO_SUPPORTED_CURRENCIES, CONTRACT_TYPE_ERC1155, CONTRACT_TYPE_ERC20, CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ETH, CurrencyController, DEFAULT_CURRENCY, DecryptMessageController, ERC1155_INTERFACE_ID, ERC721_ENUMERABLE_INTERFACE_ID, ERC721_INTERFACE_ID, ERC721_METADATA_INTERFACE_ID, ETHERSCAN_SUPPORTED_CHAINS, EncryptionPublicKeyController, GAS_ESTIMATE_TYPES, GAS_LIMITS, GasFeeController, KeyringController, LOCALHOST, MAINNET_CHAIN_ID, MESSAGE_EVENTS, METHOD_TYPES, MessageController, MessageStatus, NetworkController, NftHandler, NftsController, NonceTracker, OLD_ERC721_LIST, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, POLYGON_CHAIN_ID, PendingTransactionTracker, PersonalMessageController, PollingBlockTracker, PreferencesController, SEPOLIA_CHAIN_ID, SIMPLEHASH_SUPPORTED_CHAINS, SUPPORTED_NETWORKS, SwitchChainController, TEST_CHAINS, TRANSACTION_ENVELOPE_TYPES, TokenHandler, TokenRatesController, TokensController, TransactionController, TransactionGasUtil, TransactionStateManager, TypedMessageController, XDAI_CHAIN_ID, addCurrencies, addEtherscanTransactions, bnLessThan, conversionGTE, conversionGreaterThan, conversionLTE, conversionLessThan, conversionMax, conversionUtil, createChainIdMiddleware, createEthereumMiddleware, createGetAccountsMiddleware, createJsonRpcClient, createPendingNonceMiddleware, createPendingTxMiddleware, createProcessAddEthereumChain, createProcessDecryptMessageMiddleware, createProcessEncryptionPublicKeyMiddleware, createProcessEthSignMessage, createProcessPersonalMessage, createProcessSwitchEthereumChain, createProcessTransactionMiddleware, createProcessTypedMessage, createProcessTypedMessageV3, createProcessTypedMessageV4, createProviderConfigMiddleware, createRequestAccountsMiddleware, decGWEIToHexWEI, determineTransactionType, ensureFieldIsString, ensureMutuallyExclusiveFieldsNotProvided, erc1155Abi, erc20Abi, erc721Abi, formatDate, formatPastTx, formatTime, formatTxMetaForRpcResult, generateHistoryEntry, getBigNumber, getChainType, getEthTxStatus, getEtherScanHashLink, getFinalStates, getIpfsEndpoint, hexToBn, hexWEIToDecGWEI, idleTimeTracker, isAddressByChainId, isEIP1559Transaction, isLegacyTransaction, multiplyCurrencies, normalizeAndValidateTxParams, normalizeMessageData, normalizeTxParameters, parseDecryptMessageData, parseStandardTokenTransactionData, readAddressAsContract, replayHistory, sanitizeNftMetdataUrl, singleBalanceCheckerAbi, snapshotFromTxMeta, subtractCurrencies, toChecksumAddressByChainId, toNegative, transactionMatchesNetwork, validateAddChainData, validateAddress, validateDecryptedMessageData, validateEncryptionPublicKeyMessageData, validateFrom, validateRecipient, validateSignMessageData, validateSwitchChainData, validateTxParameters, validateTypedSignMessageDataV1, validateTypedSignMessageDataV3V4 };\n", "import { PatchError, _deepClone, isInteger, unescapePathComponent, hasUndefined } from './helpers.mjs';\nexport var JsonPatchError = PatchError;\nexport var deepClone = _deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nvar objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed: removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        var removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = _deepClone(removed);\n        }\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\n        return { newDocument: document, removed: removed };\n    },\n    copy: function (obj, key, document) {\n        var valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, { op: \"add\", path: this.path, value: _deepClone(valueToCopy) });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    }\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if (isInteger(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else { // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nexport function getValueByPointer(document, pointer) {\n    if (pointer == '') {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nexport function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {\n    if (validateOperation === void 0) { validateOperation = false; }\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (index === void 0) { index = 0; }\n    if (validateOperation) {\n        if (typeof validateOperation == 'function') {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        var returnValue = { newDocument: document };\n        if (operation.op === 'add') {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === 'replace') {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === 'move') { // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === 'test') {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === 'remove') { // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === '_get') {\n            operation.value = document;\n            return returnValue;\n        }\n        else { /* bad operation */\n            if (validateOperation) {\n                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = _deepClone(document);\n        }\n        var path = operation.path || \"\";\n        var keys = path.split('/');\n        var obj = document;\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        var len = keys.length;\n        var existingPathFragment = undefined;\n        var key = void 0;\n        var validateFunction = void 0;\n        if (typeof validateOperation == 'function') {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf('~') != -1) {\n                key = unescapePathComponent(key);\n            }\n            if (banPrototypeModifications &&\n                (key == '__proto__' ||\n                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {\n                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join('/');\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === '-') {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !isInteger(key)) {\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if (isInteger(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nexport function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n    }\n    if (!mutateDocument) {\n        document = _deepClone(document);\n    }\n    var results = new Array(patch.length);\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nexport function applyReducer(document, operation, index) {\n    var operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) { // failed test\n        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nexport function validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\n        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n    }\n    else if (typeof operation.path !== 'string') {\n        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\n        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined(operation.value)) {\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\n            }\n        }\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\n            if (operation.path !== existingPathFragment) {\n                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') {\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\n            var error = validate([existingValue], document);\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\n                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nexport function validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nexport function _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n;\n", "/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nexport function _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        var keys_1 = new Array(obj.length);\n        for (var k = 0; k < keys_1.length; k++) {\n            keys_1[k] = \"\" + k;\n        }\n        return keys_1;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n;\n/**\n* Deeply clone the object.\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n* @param  {any} obj value to clone\n* @return {any} cloned obj\n*/\nexport function _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nexport function isInteger(str) {\n    var i = 0;\n    var len = str.length;\n    var charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n* Escapes a json pointer path\n* @param path The raw pointer\n* @return the Escaped path\n*/\nexport function escapePathComponent(path) {\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\n        return path;\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nexport function unescapePathComponent(path) {\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexport function _getPathRecursive(root, obj) {\n    var found;\n    for (var key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + '/';\n            }\n            else if (typeof root[key] === 'object') {\n                found = _getPathRecursive(root[key], obj);\n                if (found != '') {\n                    return escapePathComponent(key) + '/' + found;\n                }\n            }\n        }\n    }\n    return '';\n}\nexport function getPath(root, obj) {\n    if (root === obj) {\n        return '/';\n    }\n    var path = _getPathRecursive(root, obj);\n    if (path === '') {\n        throw new Error(\"Object not found in root\");\n    }\n    return \"/\" + path;\n}\n/**\n* Recursively checks whether an object has any undefined values inside.\n*/\nexport function hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {\n                if (hasUndefined(obj[i_1])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            var objKeys = _objectKeys(obj);\n            var objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    var messageParts = [message];\n    for (var key in args) {\n        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print\n        if (typeof value !== 'undefined') {\n            messageParts.push(key + \": \" + value);\n        }\n    }\n    return messageParts.join('\\n');\n}\nvar PatchError = /** @class */ (function (_super) {\n    __extends(PatchError, _super);\n    function PatchError(message, name, index, operation, tree) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;\n        _this.name = name;\n        _this.index = index;\n        _this.operation = operation;\n        _this.tree = tree;\n        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });\n        return _this;\n    }\n    return PatchError;\n}(Error));\nexport { PatchError };\n", "/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2021 Joachim Wester\n * MIT license\n */\nimport { _deepClone, _objectKeys, escapePathComponent, hasOwnProperty } from './helpers.mjs';\nimport { applyPatch } from './core.mjs';\nvar beforeDict = new WeakMap();\nvar Mirror = /** @class */ (function () {\n    function Mirror(obj) {\n        this.observers = new Map();\n        this.obj = obj;\n    }\n    return Mirror;\n}());\nvar ObserverInfo = /** @class */ (function () {\n    function ObserverInfo(callback, observer) {\n        this.callback = callback;\n        this.observer = observer;\n    }\n    return ObserverInfo;\n}());\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nexport function unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nexport function observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        var observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = _deepClone(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = function () {\n            generate(observer);\n        };\n        var fastCheck = function () {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== 'undefined') { //not Node\n            window.addEventListener('mouseup', fastCheck);\n            window.addEventListener('keyup', fastCheck);\n            window.addEventListener('mousedown', fastCheck);\n            window.addEventListener('keydown', fastCheck);\n            window.addEventListener('change', fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = function () {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('mouseup', fastCheck);\n            window.removeEventListener('keyup', fastCheck);\n            window.removeEventListener('mousedown', fastCheck);\n            window.removeEventListener('keydown', fastCheck);\n            window.removeEventListener('change', fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nexport function generate(observer, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        applyPatch(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = _objectKeys(obj);\n    var oldKeys = _objectKeys(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if (hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + escapePathComponent(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({ op: \"test\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(oldVal) });\n                    }\n                    patches.push({ op: \"replace\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(newVal) });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(oldVal) });\n            }\n            patches.push({ op: \"remove\", path: path + \"/\" + escapePathComponent(key) });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path: path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n            patches.push({ op: \"add\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(obj[key]) });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nexport function compare(tree1, tree2, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var patches = [];\n    _generate(tree1, tree2, patches, '', invertible);\n    return patches;\n}\n", "export * from './module/core.mjs';\nexport * from './module/duplex.mjs';\nexport {\n    PatchError as JsonPatchError,\n    _deepClone as deepClone,\n    escapePathComponent,\n    unescapePathComponent\n} from './module/helpers.mjs';\n\n\n/**\n * Default export for backwards compat\n */\n\nimport * as core from './module/core.mjs';\nimport * as duplex from './module/duplex.mjs';\nimport {\n    PatchError as JsonPatchError,\n    _deepClone as deepClone,\n    escapePathComponent,\n    unescapePathComponent\n} from './module/helpers.mjs';\n\nexport default Object.assign({}, core, duplex, {\n    JsonPatchError,\n    deepClone,\n    escapePathComponent,\n    unescapePathComponent\n});", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport base64urlLib from 'base64url';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport { TORUS_SAPPHIRE_NETWORK, TORUS_LEGACY_NETWORK } from '@toruslabs/constants';\nexport { TORUS_LEGACY_NETWORK, TORUS_SAPPHIRE_NETWORK } from '@toruslabs/constants';\nimport Color from 'color';\n\nconst base64url = base64urlLib;\nfunction safebtoa(str) {\n  return base64url.encode(str);\n}\nfunction safeatob(str) {\n  // Going backwards: from bytestream, to percent-encoding, to original string.\n  return base64url.decode(str);\n}\nfunction base64toJSON(b64str) {\n  return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n  return base64url.encode(JSON.stringify(json));\n}\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (err) {\n    const error = err;\n    return error && (\n    // everything except Firefox\n    error.code === 22 ||\n    // Firefox\n    error.code === 1014 ||\n    // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededError\" ||\n    // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\n    // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\n\nclass MemoryStore {\n  constructor() {\n    _defineProperty(this, \"store\", new Map());\n  }\n  getItem(key) {\n    return this.store.get(key) || null;\n  }\n  setItem(key, value) {\n    this.store.set(key, value);\n  }\n  removeItem(key) {\n    this.store.delete(key);\n  }\n}\nclass BrowserStorage {\n  constructor(storeKey, storage) {\n    _defineProperty(this, \"storage\", void 0);\n    _defineProperty(this, \"_storeKey\", void 0);\n    this.storage = storage;\n    this._storeKey = storeKey;\n    try {\n      if (!storage.getItem(storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {\n      // Storage is not available\n    }\n  }\n  static getInstance(key) {\n    let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n    if (!this.instanceMap.has(key)) {\n      let storage;\n      if (storageKey === \"local\" && storageAvailable(\"localStorage\")) {\n        storage = window.localStorage;\n      } else if (storageKey === \"session\" && storageAvailable(\"sessionStorage\")) {\n        storage = window.sessionStorage;\n      } else {\n        storage = new MemoryStore();\n      }\n      this.instanceMap.set(key, new this(key, storage));\n    }\n    return this.instanceMap.get(key);\n  }\n  toJSON() {\n    return this.storage.getItem(this._storeKey);\n  }\n  resetStore() {\n    const currStore = this.getStore();\n    this.storage.removeItem(this._storeKey);\n    return currStore;\n  }\n  getStore() {\n    return JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n  }\n  get(key) {\n    const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    return store[key];\n  }\n  set(key, value) {\n    const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    store[key] = value;\n    this.storage.setItem(this._storeKey, JSON.stringify(store));\n  }\n}\n_defineProperty(BrowserStorage, \"instanceMap\", new Map());\n\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_NETWORK = _objectSpread(_objectSpread({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);\nconst SUPPORTED_KEY_CURVES = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  FARCASTER: \"farcaster\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  SMS_PASSWORDLESS: \"sms_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\",\n  NONE: \"none\"\n};\nconst OPENLOGIN_ACTIONS = {\n  LOGIN: \"login\",\n  ENABLE_MFA: \"enable_mfa\",\n  MANAGE_MFA: \"manage_mfa\",\n  MODIFY_SOCIAL_FACTOR: \"modify_social_factor\"\n};\nconst BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  STAGING: \"staging\",\n  TESTING: \"testing\"\n};\n\n/**\n * {@label loginProviderType}\n */\n\n// autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729\n\nconst LANGUAGES = {\n  en: \"en\",\n  ja: \"ja\",\n  ko: \"ko\",\n  de: \"de\",\n  zh: \"zh\",\n  es: \"es\",\n  fr: \"fr\",\n  pt: \"pt\",\n  nl: \"nl\",\n  tr: \"tr\"\n};\nconst LANGUAGE_MAP = {\n  en: \"english\",\n  ja: \"japanese\",\n  ko: \"korean\",\n  de: \"german\",\n  zh: \"mandarin\",\n  es: \"spanish\",\n  fr: \"french\",\n  pt: \"portuguese\",\n  nl: \"dutch\",\n  tr: \"turkish\"\n};\nconst THEME_MODES = {\n  light: \"light\",\n  dark: \"dark\",\n  auto: \"auto\"\n};\nconst MFA_FACTOR = {\n  DEVICE: \"deviceShareFactor\",\n  BACKUP_SHARE: \"backUpShareFactor\",\n  SOCIAL_BACKUP: \"socialBackupFactor\",\n  PASSWORD: \"passwordFactor\",\n  PASSKEYS: \"passkeysFactor\",\n  AUTHENTICATOR: \"authenticatorFactor\"\n};\n\nfunction getColorsList() {\n  let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n  let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n  let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"black\";\n  let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;\n  let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"#0346ff\";\n  const colorsList = [];\n  let step;\n  for (step = 0; step < colorsAmount; step += 1) {\n    colorsList.push(Color(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix(Color(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());\n  }\n  return colorsList;\n}\nfunction generateWhiteLabelTheme(primary) {\n  const darkSet = getColorsList(3, 50, \"black\", 0, 20, primary);\n  const lightSet = getColorsList(6, 85, \"white\", 0, 20, primary);\n  return [...darkSet.reverse(), primary, ...lightSet];\n}\nfunction applyWhiteLabelTheme(rootElement, theme) {\n  if (theme.primary) {\n    const themeSet = generateWhiteLabelTheme(theme.primary);\n    rootElement.style.setProperty(\"--app-primary-900\", themeSet[0]);\n    rootElement.style.setProperty(\"--app-primary-800\", themeSet[1]);\n    rootElement.style.setProperty(\"--app-primary-700\", themeSet[2]);\n    rootElement.style.setProperty(\"--app-primary-600\", themeSet[3]);\n    rootElement.style.setProperty(\"--app-primary-500\", themeSet[4]);\n    rootElement.style.setProperty(\"--app-primary-400\", themeSet[5]);\n    rootElement.style.setProperty(\"--app-primary-300\", themeSet[6]);\n    rootElement.style.setProperty(\"--app-primary-200\", themeSet[7]);\n    rootElement.style.setProperty(\"--app-primary-100\", themeSet[8]);\n    rootElement.style.setProperty(\"--app-primary-50\", themeSet[9]);\n  }\n  if (theme.onPrimary) {\n    rootElement.style.setProperty(\"--app-on-primary\", theme.onPrimary);\n  }\n}\n\nexport { BUILD_ENV, BrowserStorage, LANGUAGES, LANGUAGE_MAP, LOGIN_PROVIDER, MFA_FACTOR, MFA_LEVELS, MemoryStore, OPENLOGIN_ACTIONS, OPENLOGIN_NETWORK, SUPPORTED_KEY_CURVES, THEME_MODES, UX_MODE, applyWhiteLabelTheme, base64toJSON, base64url, generateWhiteLabelTheme, getColorsList, jsonToBase64, safeatob, safebtoa, storageAvailable, storeKey };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createLoggerMiddleware, getPopupFeatures, FEATURES_DEFAULT_POPUP_WINDOW, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, randomId, SETUP_COMPLETE, CONFIRMATION_STRATEGY, FEATURES_CONFIRM_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW } from '@toruslabs/base-controllers';\nexport { CONFIRMATION_STRATEGY } from '@toruslabs/base-controllers';\nimport { METHOD_TYPES } from '@toruslabs/ethereum-controllers';\nimport { rpcErrors, SafeEventEmitter, ObjectMultiplex, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback, EthereumProviderError, BasePostMessageStream } from '@toruslabs/openlogin-jrpc';\nimport { THEME_MODES } from '@toruslabs/openlogin-utils';\nimport pump from 'pump';\nimport loglevel from 'loglevel';\nimport dequal from 'fast-deep-equal';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction isStream(stream) {\n  return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\n}\nfunction isWritableStream(stream) {\n  return isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\n}\nfunction isReadableStream(stream) {\n  return isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\n}\nfunction isDuplexStream(stream) {\n  return isWritableStream(stream) && isReadableStream(stream);\n}\n\nvar messages = {\n  errors: {\n    disconnected: () => \"Web3Auth: Lost connection to Web3Auth.\",\n    permanentlyDisconnected: () => \"Web3Auth: Disconnected from iframe. Page reload required.\",\n    unsupportedSync: method => `Web3Auth: The Web3Auth Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\n    invalidOptions: maxEventListeners => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,\n    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,\n    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,\n    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,\n    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,\n    invalidLoggerMethod: method => `'args.logger' must include required method '${method}'.`\n  },\n  info: {\n    connected: chainId => `Web3Auth: Connected to chain with ID \"${chainId}\".`\n  },\n  warnings: {}\n};\n\nvar log = loglevel.getLogger(\"ws-embed\");\n\n// utility functions\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\nfunction createErrorMiddleware() {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== \"string\" || !req.method) {\n      res.error = rpcErrors.invalidRequest({\n        message: `The request 'method' must be a non-empty string.`,\n        data: _objectSpread(_objectSpread({}, req || {}), {}, {\n          cause: `The request 'method' must be a non-empty string.`\n        })\n      });\n    }\n    next(done => {\n      const {\n        error\n      } = res;\n      if (!error) {\n        return done();\n      }\n      log.error(`Ws-Embed - RPC Error: ${error.message}`, error);\n      return done();\n    });\n  };\n}\n\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\n  let warningMsg = `Web3Auth: Lost connection to \"${remoteLabel}\".`;\n  if (error !== null && error !== void 0 && error.stack) {\n    warningMsg += `\\n${error.stack}`;\n  }\n  log.warn(warningMsg);\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\n    emitter.emit(\"error\", warningMsg);\n  }\n}\nconst EMITTED_NOTIFICATIONS = [\"eth_subscription\" // per eth-json-rpc-filters/subscriptionManager\n];\n\n/**\n * @param connectionStream - A Node.js duplex stream\n * @param opts - An options bag\n */\nclass BaseProvider extends SafeEventEmitter {\n  constructor(connectionStream, {\n    maxEventListeners = 100,\n    jsonRpcStreamName = \"provider\"\n  }) {\n    super();\n    _defineProperty(this, \"rpcEngine\", void 0);\n    _defineProperty(this, \"jsonRpcConnectionEvents\", void 0);\n    /**\n     * Indicating that this provider is a Web3Auth provider.\n     */\n    _defineProperty(this, \"isWeb3Auth\", void 0);\n    _defineProperty(this, \"state\", void 0);\n    if (!isDuplexStream(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n    this.isWeb3Auth = true;\n    this.setMaxListeners(maxEventListeners);\n    this.handleConnect = this.handleConnect.bind(this);\n    this.handleDisconnect = this.handleDisconnect.bind(this);\n    this.handleStreamDisconnect = this.handleStreamDisconnect.bind(this);\n    this.rpcRequest = this.rpcRequest.bind(this);\n    this.initializeState = this.initializeState.bind(this);\n    this.request = this.request.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    this.send = this.send.bind(this);\n    // this.enable = this.enable.bind(this);\n\n    // setup connectionStream multiplexing\n    const mux = new ObjectMultiplex();\n    pump(connectionStream, mux, connectionStream, this.handleStreamDisconnect.bind(this, \"Web3Auth\"));\n\n    // ignore phishing warning message (handled elsewhere)\n    mux.ignoreStream(\"phishing\");\n\n    // setup own event listeners\n    // connect to async provider\n\n    const jsonRpcConnection = createStreamMiddleware();\n    pump(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this.handleStreamDisconnect.bind(this, \"Web3Auth RpcProvider\"));\n\n    // handle RPC requests via dapp-side rpc engine\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(createErrorMiddleware());\n    rpcEngine.push(createLoggerMiddleware({\n      origin: location.origin\n    }));\n    rpcEngine.push(jsonRpcConnection.middleware);\n    this.rpcEngine = rpcEngine;\n    this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n  }\n\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   *\n   * @param args - The RPC request arguments.\n   * @returns A Promise that resolves with the result of the RPC method,\n   * or rejects if an error is encountered.\n   */\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    const {\n      method,\n      params\n    } = args;\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @param payload - The RPC request object.\n   * @param cb - The callback function.\n   */\n  send(payload, callback) {\n    this.rpcRequest(payload, callback);\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @param payload - The RPC request object.\n   * @param cb - The callback function.\n   */\n  sendAsync(payload) {\n    return new Promise((resolve, reject) => {\n      this.rpcRequest(payload, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits InpageProvider#disconnect\n   */\n  handleStreamDisconnect(streamName, error) {\n    logStreamDisconnectWarning(streamName, error, this);\n    this.handleDisconnect(false, error ? error.message : undefined);\n  }\n\n  // Private Methods\n  //= ===================\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits InPageProvider#connect\n   */\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits InpageProvider#disconnect\n   */\n}\n\nconst WS_EMBED_BUILD_ENV = {\n  PRODUCTION: \"production\",\n  STAGING: \"staging\",\n  DEVELOPMENT: \"development\",\n  TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n  BOTTOM_LEFT: \"bottom-left\",\n  TOP_LEFT: \"top-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_RIGHT: \"top-right\"\n};\n\nclass PopupHandler extends SafeEventEmitter {\n  constructor({\n    url,\n    target,\n    features,\n    timeout = 30000\n  }) {\n    super();\n    _defineProperty(this, \"url\", void 0);\n    _defineProperty(this, \"target\", void 0);\n    _defineProperty(this, \"features\", void 0);\n    _defineProperty(this, \"window\", void 0);\n    _defineProperty(this, \"windowTimer\", void 0);\n    _defineProperty(this, \"iClosedWindow\", void 0);\n    _defineProperty(this, \"timeout\", void 0);\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n    this.timeout = timeout;\n    this._setupTimer();\n  }\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n        setTimeout(() => {\n          if (!this.iClosedWindow) {\n            this.emit(\"close\");\n          }\n          this.iClosedWindow = false;\n          this.window = undefined;\n        }, this.timeout);\n      }\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n  open() {\n    var _this$window;\n    this.window = window.open(this.url.href, this.target, this.features);\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n  }\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url.href);\n    } else {\n      window.location.href = this.url.href;\n    }\n  }\n}\n\n/**\n * @param connectionStream - A Node.js duplex stream\n * @param  opts - An options bag\n */\nclass CommunicationProvider extends BaseProvider {\n  constructor(connectionStream, {\n    maxEventListeners = 100,\n    jsonRpcStreamName = \"provider\"\n  }, state) {\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    });\n\n    // private state\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n    _defineProperty(this, \"windowRefs\", void 0);\n    _defineProperty(this, \"iframeUrl\", void 0);\n    _defineProperty(this, \"iframeId\", void 0);\n    this.state = _objectSpread(_objectSpread({}, CommunicationProvider.defaultState), state);\n\n    // public state\n    this.iframeUrl = \"\";\n    this.iframeId = \"\";\n    this.windowRefs = new Map();\n\n    // setup own event listeners\n\n    // EIP-1193 connect\n    this.on(\"connect\", () => {\n      this.state.isConnected = true;\n    });\n    const notificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n      // create_window should never come here..\n      // we either pre-open from embed.\n      // if it's blocked, we communicate down that it's blocked and we show full screen iframe and open from iframe\n      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n        const {\n          isFullScreen,\n          rid\n        } = params;\n        this.displayIframe({\n          isFull: isFullScreen,\n          rid: rid\n        });\n      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n        this.handleCloseWindow(params);\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n        const {\n          currentLoginProvider\n        } = params;\n        this.state.isLoggedIn = true;\n        this.state.currentLoginProvider = currentLoginProvider;\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n        this.state.isLoggedIn = false;\n        this.state.currentLoginProvider = null;\n        this.displayIframe();\n      }\n    };\n    this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n  }\n  get isLoggedIn() {\n    return this.state.isLoggedIn;\n  }\n  get isIFrameFullScreen() {\n    return this.state.isIFrameFullScreen;\n  }\n\n  /**\n   * Returns whether the inPage provider is connected to Torus.\n   */\n  isConnected() {\n    return this.state.isConnected;\n  }\n  async initializeState(params) {\n    try {\n      const {\n        torusUrl,\n        torusIframeId\n      } = params;\n      this.iframeUrl = torusUrl;\n      this.iframeId = torusIframeId;\n      const {\n        currentLoginProvider,\n        isLoggedIn\n      } = await this.request({\n        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      });\n\n      // indicate that we've connected, for EIP-1193 compliance\n      if (isLoggedIn) this.handleConnect(currentLoginProvider, isLoggedIn);\n    } catch (error) {\n      log.error(\"Web3Auth: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized communication state\");\n      this.state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n  hideTorusButton() {\n    this.state.widgetVisibility = false;\n    this.displayIframe();\n  }\n  showTorusButton() {\n    this.state.widgetVisibility = true;\n    this.displayIframe();\n  }\n  displayIframe({\n    isFull = false,\n    rid = \"\"\n  } = {}) {\n    const style = {};\n    // set phase\n    if (!isFull) {\n      style.display = this.state.widgetVisibility ? \"block\" : \"none\";\n      style.height = \"70px\";\n      style.width = \"70px\";\n      switch (this.state.buttonPosition) {\n        case BUTTON_POSITION.TOP_LEFT:\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.right = \"auto\";\n          style.bottom = \"auto\";\n          break;\n        case BUTTON_POSITION.TOP_RIGHT:\n          style.top = \"0px\";\n          style.right = \"0px\";\n          style.left = \"auto\";\n          style.bottom = \"auto\";\n          break;\n        case BUTTON_POSITION.BOTTOM_RIGHT:\n          style.bottom = \"0px\";\n          style.right = \"0px\";\n          style.top = \"auto\";\n          style.left = \"auto\";\n          break;\n        case BUTTON_POSITION.BOTTOM_LEFT:\n        default:\n          style.bottom = \"0px\";\n          style.left = \"0px\";\n          style.top = \"auto\";\n          style.right = \"auto\";\n          break;\n      }\n    } else {\n      style.display = \"block\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n    }\n    const iframe = document.getElementById(this.iframeId);\n    Object.assign(iframe.style, style);\n    this.state.isIFrameFullScreen = isFull;\n    this.request({\n      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n      params: {\n        isIFrameFullScreen: isFull,\n        rid\n      }\n    });\n  }\n\n  /**\n   * Scenarios:\n   * - Login request or pre-open confirmation windows\n   * We try to open here or send a rpc request to iframe that window is blocked.\n   */\n  async handleWindow(windowId, {\n    url,\n    target,\n    features,\n    timeout\n  } = {}) {\n    const finalUrl = new URL(url || `${this.iframeUrl}/redirect?windowId=${windowId}&sessionNamespace=${window.location.hostname}`);\n    const handledWindow = new PopupHandler({\n      url: finalUrl,\n      target,\n      features,\n      timeout\n    });\n    handledWindow.open();\n    if (!handledWindow.window) {\n      this.displayIframe({\n        isFull: true\n      });\n      this.request({\n        method: COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED,\n        params: {\n          windowId,\n          finalUrl: finalUrl.href\n        }\n      });\n      return;\n    }\n    // Add to collection only if window is opened\n    this.windowRefs.set(windowId, handledWindow);\n    handledWindow.once(\"close\", () => {\n      // user closed the window\n      this.windowRefs.delete(windowId);\n      this.request({\n        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n        params: {\n          windowId\n        }\n      });\n    });\n  }\n\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n  rpcRequest(payload, callback) {\n    const cb = callback;\n    const _payload = payload;\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n    }\n    this.rpcEngine.handle(_payload, cb);\n  }\n\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */\n  handleConnect(currentLoginProvider, isLoggedIn) {\n    if (!this.state.isConnected) {\n      this.state.isConnected = true;\n      this.emit(\"connect\", {\n        currentLoginProvider,\n        isLoggedIn\n      });\n      log.debug(messages.info.connected(currentLoginProvider));\n    }\n  }\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n  handleDisconnect(isRecoverable, errorMessage) {\n    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {\n      this.state.isConnected = false;\n      let error;\n      if (isRecoverable) {\n        error = new EthereumProviderError(1013,\n        // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumProviderError(1011,\n        // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.state.currentLoginProvider = null;\n        this.state.isLoggedIn = false;\n        this.state.widgetVisibility = false;\n        this.state.isIFrameFullScreen = false;\n        this.state.isPermanentlyDisconnected = true;\n      }\n      this.emit(\"disconnect\", error);\n    }\n  }\n  handleCloseWindow(params) {\n    const {\n      windowId\n    } = params;\n    if (this.windowRefs.has(windowId)) {\n      this.windowRefs.get(windowId).close();\n      this.windowRefs.delete(windowId);\n    }\n  }\n}\n_defineProperty(CommunicationProvider, \"defaultState\", {\n  buttonPosition: \"bottom-left\",\n  currentLoginProvider: null,\n  isIFrameFullScreen: false,\n  widgetVisibility: false,\n  initialized: false,\n  isLoggedIn: false,\n  isPermanentlyDisconnected: false,\n  isConnected: false,\n  hasEmittedConnection: false\n});\n\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\n\n/**\n * @param connectionStream - A Node.js duplex stream\n * @param opts - An options bag\n */\nclass TorusInPageProvider extends BaseProvider {\n  constructor(connectionStream, {\n    maxEventListeners = 100,\n    jsonRpcStreamName = \"provider\"\n  }) {\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    });\n\n    // private state\n    /**\n     * The chain ID of the currently connected EVM chain.\n     * See [chainId.network]{@link https://chainid.network} for more information.\n     */\n    _defineProperty(this, \"chainId\", void 0);\n    /**\n     * The user's currently selected EVM address.\n     * If null, Torus is either locked or the user has not permitted any\n     * addresses to be viewed.\n     */\n    _defineProperty(this, \"selectedAddress\", void 0);\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n    this.state = _objectSpread({}, TorusInPageProvider.defaultState);\n\n    // public state\n    this.selectedAddress = null;\n    this.chainId = null;\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this);\n    this.handleChainChanged = this.handleChainChanged.bind(this);\n    this.handleUnlockStateChanged = this.handleUnlockStateChanged.bind(this);\n\n    // setup own event listeners\n\n    // EIP-1193 connect\n    this.on(\"connect\", () => {\n      this.state.isConnected = true;\n    });\n    const jsonRpcNotificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n        this.handleAccountsChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n        this.handleUnlockStateChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n        this.handleChainChanged(params);\n      } else if (EMITTED_NOTIFICATIONS.includes(method)) {\n        this.emit(\"data\", payload);\n        this.emit(\"notification\", params.result);\n        this.emit(\"message\", {\n          type: method,\n          data: params\n        });\n      }\n    };\n\n    // json rpc notification listener\n    this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n  }\n\n  /**\n   * Returns whether the inpage provider is connected to Torus.\n   */\n  isConnected() {\n    return this.state.isConnected;\n  }\n\n  // Private Methods\n  //= ===================\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n  async initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked\n      } = await this.request({\n        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      });\n\n      // indicate that we've connected, for EIP-1193 compliance\n      this.emit(\"connect\", {\n        chainId\n      });\n      this.handleChainChanged({\n        chainId\n      });\n      this.handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n      this.handleAccountsChanged(accounts);\n    } catch (error) {\n      log.error(\"WsEmbed: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized provider state\");\n      this.state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n  rpcRequest(payload, callback, isInternal = false) {\n    let cb = callback;\n    const _payload = payload;\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n      if (_payload.method === \"eth_accounts\" || _payload.method === \"eth_requestAccounts\") {\n        // handle accounts changing\n        cb = (err, res) => {\n          this.handleAccountsChanged(res.result || [], _payload.method === \"eth_accounts\", isInternal);\n          callback(err, res);\n        };\n      } else if (_payload.method === \"wallet_getProviderState\") {\n        this.rpcEngine.handle(payload, cb);\n        return;\n      }\n    }\n    this.tryWindowHandle(_payload, cb);\n  }\n\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */\n  handleConnect(chainId) {\n    if (!this.state.isConnected) {\n      this.state.isConnected = true;\n      this.emit(\"connect\", {\n        chainId\n      });\n      log.debug(messages.info.connected(chainId));\n    }\n  }\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n  handleDisconnect(isRecoverable, errorMessage) {\n    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {\n      this.state.isConnected = false;\n      let error;\n      if (isRecoverable) {\n        error = new EthereumProviderError(1013,\n        // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumProviderError(1011,\n        // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.chainId = null;\n        this.state.accounts = null;\n        this.selectedAddress = null;\n        this.state.isUnlocked = false;\n        this.state.isPermanentlyDisconnected = true;\n      }\n      this.emit(\"disconnect\", error);\n    }\n  }\n\n  /**\n   * Called when accounts may have changed.\n   */\n  handleAccountsChanged(accounts, isEthAccounts = false, isInternal = false) {\n    // defensive programming\n    let finalAccounts = accounts;\n    if (!Array.isArray(finalAccounts)) {\n      log.error(\"WsEmbed: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n      finalAccounts = [];\n    }\n    for (const account of accounts) {\n      if (typeof account !== \"string\") {\n        log.error(\"WsEmbed: Received non-string account. Please report this bug.\", accounts);\n        finalAccounts = [];\n        break;\n      }\n    }\n\n    // emit accountsChanged if anything about the accounts array has changed\n    if (!dequal(this.state.accounts, finalAccounts)) {\n      // we should always have the correct accounts even before eth_accounts\n      // returns, except in cases where isInternal is true\n      if (isEthAccounts && Array.isArray(this.state.accounts) && this.state.accounts.length > 0 && !isInternal) {\n        log.error('WsEmbed: \"eth_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n      }\n      this.state.accounts = finalAccounts;\n      this.emit(\"accountsChanged\", finalAccounts);\n    }\n\n    // handle selectedAddress\n    if (this.selectedAddress !== finalAccounts[0]) {\n      this.selectedAddress = finalAccounts[0] || null;\n    }\n  }\n\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */\n  handleChainChanged({\n    chainId\n  } = {}) {\n    if (!chainId) {\n      log.error(\"WsEmbed: Received invalid network parameters. Please report this bug.\", {\n        chainId\n      });\n      return;\n    }\n    if (chainId === \"loading\") {\n      this.handleDisconnect(true);\n    } else {\n      this.handleConnect(chainId);\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n        if (this.state.initialized) {\n          this.emit(\"chainChanged\", this.chainId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */\n  handleUnlockStateChanged({\n    accounts,\n    isUnlocked\n  } = {}) {\n    if (typeof isUnlocked !== \"boolean\") {\n      log.error(\"WsEmbed: Received invalid isUnlocked parameter. Please report this bug.\", {\n        isUnlocked\n      });\n      return;\n    }\n    if (isUnlocked !== this.state.isUnlocked) {\n      this.state.isUnlocked = isUnlocked;\n      this.handleAccountsChanged(accounts || []);\n    }\n  }\n}\n_defineProperty(TorusInPageProvider, \"defaultState\", {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false,\n  hasEmittedConnection: false\n});\n\n/**\n * Returns whether the given image URL exists\n * @param url - the url of the image\n * @returns whether the image exists\n */\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n/**\n * Extracts a name for the site from the DOM\n */\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n  if (siteName) {\n    return siteName.content;\n  }\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n  return window.location.hostname;\n};\n\n/**\n * Extracts an icon for the site from the DOM\n */\nasync function getSiteIcon(window) {\n  try {\n    const {\n      document\n    } = window;\n\n    // Use the site's favicon if it exists\n    let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    }\n\n    // Search through available icons in no particular order\n    icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    }\n    return \"\";\n  } catch (error) {\n    return \"\";\n  }\n}\n\n/**\n * Gets site metadata and returns it\n *\n */\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\n\n// don't use destructuring for process.env cause it messes up webpack env plugin\nconst version = \"2.0.23\";\nconst addedVersion = `v${version.split(\".\")[0]}` ;\nconst WALLET_URLS_DEFAULT = {\n  [WS_EMBED_BUILD_ENV.TESTING]: {\n    url: \"https://develop-wallet.web3auth.io\",\n    logLevel: \"debug\"\n  },\n  [WS_EMBED_BUILD_ENV.DEVELOPMENT]: {\n    url: \"http://localhost:4050\",\n    logLevel: \"debug\"\n  },\n  [WS_EMBED_BUILD_ENV.STAGING]: {\n    url: `https://staging-wallet.web3auth.io/${addedVersion}`,\n    logLevel: \"debug\"\n  },\n  [WS_EMBED_BUILD_ENV.PRODUCTION]: {\n    url: `https://wallet.web3auth.io/${addedVersion}`,\n    logLevel: \"error\"\n  }\n};\n\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n  try {\n    if (typeof document === \"undefined\") return;\n    const torusIframeHtml = document.createElement(\"link\");\n    const {\n      url: torusUrl\n    } = WALLET_URLS_DEFAULT.production;\n    torusIframeHtml.href = `${torusUrl}/frame`;\n    torusIframeHtml.crossOrigin = \"anonymous\";\n    torusIframeHtml.type = \"text/html\";\n    torusIframeHtml.rel = \"prefetch\";\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(torusIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.warn(error);\n  }\n})();\nnew Set([COMMUNICATION_JRPC_METHODS.SET_PROVIDER]);\nconst PROVIDER_UNSAFE_METHODS = new Set([METHOD_TYPES.ETH_DECRYPT, METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY, METHOD_TYPES.ETH_SIGN, METHOD_TYPES.ETH_SIGN_TYPED_DATA, METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3, METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, METHOD_TYPES.PERSONAL_SIGN, METHOD_TYPES.ETH_TRANSACTION, METHOD_TYPES.ADD_CHAIN, METHOD_TYPES.SWITCH_CHAIN]);\nclass WsEmbed {\n  constructor({\n    modalZIndex = 99999,\n    web3AuthClientId,\n    web3AuthNetwork\n  }) {\n    _defineProperty(this, \"isInitialized\", void 0);\n    _defineProperty(this, \"modalZIndex\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"widgetVisibility\", void 0);\n    _defineProperty(this, \"communicationProvider\", void 0);\n    _defineProperty(this, \"buttonPosition\", void 0);\n    _defineProperty(this, \"web3AuthClientId\", void 0);\n    _defineProperty(this, \"web3AuthNetwork\", void 0);\n    _defineProperty(this, \"isPluginMode\", void 0);\n    _defineProperty(this, \"confirmationStrategy\", void 0);\n    _defineProperty(this, \"buildEnv\", void 0);\n    _defineProperty(this, \"embedNonce\", randomId());\n    this.isInitialized = false; // init done\n    this.modalZIndex = modalZIndex;\n    this.web3AuthClientId = web3AuthClientId;\n    this.web3AuthNetwork = web3AuthNetwork;\n  }\n  get isLoggedIn() {\n    var _this$communicationPr;\n    return ((_this$communicationPr = this.communicationProvider) === null || _this$communicationPr === void 0 ? void 0 : _this$communicationPr.isLoggedIn) || false;\n  }\n  get getBuildEnv() {\n    return this.buildEnv;\n  }\n  async init({\n    buildEnv = WS_EMBED_BUILD_ENV.PRODUCTION,\n    enableLogging = false,\n    chainConfig,\n    walletUrls,\n    whiteLabel,\n    confirmationStrategy = CONFIRMATION_STRATEGY.DEFAULT\n  } = {}) {\n    if (this.isInitialized) throw new Error(\"Already initialized\");\n    this.buildEnv = buildEnv;\n    this.confirmationStrategy = confirmationStrategy;\n    const {\n      url: torusUrl,\n      logLevel\n    } = walletUrls && walletUrls[buildEnv] ? _objectSpread(_objectSpread({}, WALLET_URLS_DEFAULT[buildEnv]), walletUrls[buildEnv]) : WALLET_URLS_DEFAULT[buildEnv];\n    log.info(torusUrl, \"url loaded\");\n    log.setDefaultLevel(logLevel);\n    if (enableLogging) log.enableAll();else log.disableAll();\n    const torusIframeUrl = new URL(torusUrl);\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";else torusIframeUrl.pathname += \"/frame\";\n    const hashParams = new URLSearchParams();\n    hashParams.append(\"origin\", window.location.origin);\n    torusIframeUrl.hash = hashParams.toString();\n    const colorScheme = this.getTheme((whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.mode) || THEME_MODES.light);\n\n    // sandbox=\"allow-popups allow-scripts allow-same-origin\"\n    // Iframe code\n    const walletIframe = htmlToElement(`<iframe\n        id=\"walletIframe-${this.embedNonce}\"\n        class=\"walletIframe-${this.embedNonce}\"\n        sandbox=\"allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()};\n        color-scheme: ${colorScheme}\"\n        allow=\"clipboard-write\"\n      ></iframe>`);\n    this.buttonPosition = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.buttonPosition) || BUTTON_POSITION.BOTTOM_LEFT;\n    const dappMetadata = await getSiteMetadata();\n    return new Promise((resolve, reject) => {\n      try {\n        window.document.body.appendChild(walletIframe);\n        // Wait for iframe to send ready\n        const handleMessage = async ev => {\n          if (ev.origin !== torusIframeUrl.origin) return;\n          if (ev.data === SETUP_COMPLETE) {\n            window.removeEventListener(\"message\", handleMessage);\n            // send init params here\n            walletIframe.contentWindow.postMessage({\n              chainConfig,\n              dappMetadata,\n              enableLogging,\n              web3AuthClientId: this.web3AuthClientId,\n              web3AuthNetwork: this.web3AuthNetwork,\n              whiteLabel,\n              confirmationStrategy\n            }, torusIframeUrl.origin);\n            await this.setupWeb3({\n              torusUrl,\n              walletIframe\n            });\n            // if (showTorusButton) this.showTorusButton();\n            // else this.hideTorusButton();\n            this.widgetVisibility = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.showWidgetButton) || false;\n            this.isInitialized = true;\n            resolve();\n          }\n        };\n        window.addEventListener(\"message\", handleMessage);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  async login(params = {}) {\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    try {\n      if (!params.loginProvider) {\n        this.communicationProvider.displayIframe({\n          isFull: true\n        });\n      }\n\n      // If user is already logged in, we assume they have given access to the website\n      const res = await new Promise((resolve, reject) => {\n        // We use this method because we want to update inPage provider state with account info\n        this.provider.rpcRequest({\n          method: \"eth_requestAccounts\",\n          params: [params.loginProvider, params.login_hint]\n        }, getRpcPromiseCallback(resolve, reject));\n      });\n      log.info(\"check: res\", res);\n      if (Array.isArray(res) && res.length > 0) {\n        if (this.widgetVisibility) this.showTorusButton();\n        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.AUTO_APPROVE) log.warn(\"Confirmation strategy auto approve is not allowed on Embed Mode, using Default instead.\");\n        return res;\n      }\n      // This would never happen, but just in case\n      throw new Error(\"Login failed\");\n    } catch (error) {\n      log.error(\"login failed\", error);\n      throw error;\n    } finally {\n      this.communicationProvider.displayIframe({\n        isFull: false\n      });\n    }\n  }\n  async loginWithSessionId(params) {\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    if (!params.sessionId) throw new Error(\"sessionId is required\");\n    try {\n      const res = await this.communicationProvider.request({\n        method: COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID,\n        params: [params.sessionId, params.sessionNamespace || \"\"]\n      });\n      log.info(\"check: res\", res);\n      if (res.success) {\n        this.isPluginMode = true;\n        if (this.widgetVisibility) this.showTorusButton();\n        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.POPUP) log.warn(\"Confirmation strategy popup is not allowed on Plugin Mode, using Default instead.\");\n        return res.success;\n      }\n      // This should never happen, but just in case\n      throw new Error(\"Login failed\");\n    } catch (error) {\n      log.error(\"login with session id failed\", error);\n      throw error;\n    }\n  }\n  async logout() {\n    if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.LOGOUT,\n      params: []\n    });\n    this.hideTorusButton();\n  }\n  async cleanUp() {\n    var _this$communicationPr2;\n    if ((_this$communicationPr2 = this.communicationProvider) !== null && _this$communicationPr2 !== void 0 && _this$communicationPr2.isLoggedIn) {\n      await this.logout();\n    }\n    this.clearInit();\n  }\n  clearInit() {\n    function isElement(element) {\n      return element instanceof Element || element instanceof Document;\n    }\n    const walletIframe = window.document.getElementById(`walletIframe-${this.embedNonce}`);\n    if (isElement(walletIframe)) {\n      walletIframe.remove();\n    }\n    this.isInitialized = false;\n  }\n  hideTorusButton() {\n    this.communicationProvider.hideTorusButton();\n  }\n  showTorusButton() {\n    this.communicationProvider.showTorusButton();\n  }\n  async getUserInfo() {\n    const userInfoResponse = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.USER_INFO,\n      params: []\n    });\n    return userInfoResponse;\n  }\n  async showWalletConnectScanner() {\n    this.communicationProvider.displayIframe({\n      isFull: true\n    });\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT,\n      params: []\n    });\n  }\n  async showWalletUi() {\n    this.communicationProvider.displayIframe({\n      isFull: true\n    });\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI,\n      params: []\n    });\n  }\n  async showCheckout() {\n    this.communicationProvider.displayIframe({\n      isFull: true\n    });\n    try {\n      await this.communicationProvider.request({\n        method: COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT,\n        params: []\n      });\n    } catch (_) {\n      this.communicationProvider.displayIframe({\n        isFull: false\n      });\n    }\n  }\n  getConfirmationStrategyFinal(payload) {\n    let confirmationStrategyFinal = this.confirmationStrategy;\n    if (!Array.isArray(payload) && PROVIDER_UNSAFE_METHODS.has(payload.method) && this.confirmationStrategy !== CONFIRMATION_STRATEGY.MODAL && !this.isPluginMode) {\n      confirmationStrategyFinal = CONFIRMATION_STRATEGY.POPUP;\n    }\n    return confirmationStrategyFinal;\n  }\n  getTheme(theme) {\n    if (theme === THEME_MODES.light) return \"light\";\n    if (theme === THEME_MODES.dark) return \"dark\";\n    return window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n  }\n  async setupWeb3(providerParams) {\n    log.info(\"setupWeb3 running\");\n    // setup background connection\n    const providerStream = new BasePostMessageStream({\n      name: \"embed_torus\",\n      target: \"iframe_torus\",\n      targetWindow: providerParams.walletIframe.contentWindow,\n      targetOrigin: new URL(providerParams.torusUrl).origin\n    });\n\n    // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n    const communicationStream = new BasePostMessageStream({\n      name: \"embed_communication\",\n      target: \"iframe_communication\",\n      targetWindow: providerParams.walletIframe.contentWindow,\n      targetOrigin: new URL(providerParams.torusUrl).origin\n    });\n\n    // compose the inPage provider\n    const inPageProvider = new TorusInPageProvider(providerStream, {});\n    const communicationProvider = new CommunicationProvider(communicationStream, {}, {\n      buttonPosition: this.buttonPosition\n    });\n    inPageProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);\n      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP) {\n        const windowId = randomId();\n        communicationProvider.handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW),\n          timeout: 500\n        });\n        // for inPageProvider methods sending windowId in request instead of params\n        // as params might be positional.\n        _payload.windowId = windowId;\n      }\n      inPageProvider.rpcEngine.handle(_payload, cb);\n    };\n    communicationProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);\n      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP) {\n        const windowId = randomId();\n        communicationProvider.handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW),\n          // todo: are these features generic for all\n          timeout: 500\n        });\n        // for communication methods sending window id in jrpc req params\n        _payload.params.windowId = windowId;\n      }\n      communicationProvider.rpcEngine.handle(_payload, cb);\n    };\n\n    // detect eth_requestAccounts and pipe to enable for now\n    const detectAccountRequestPrototypeModifier = m => {\n      const originalMethod = inPageProvider[m];\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const self = this;\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      inPageProvider[m] = function providerFunc(request, cb) {\n        const {\n          method,\n          params = []\n        } = request;\n        if (method === \"eth_requestAccounts\") {\n          if (!cb) return self.login({\n            loginProvider: params[0]\n          });\n          self.login({\n            loginProvider: params[0]\n          })\n          // eslint-disable-next-line promise/no-callback-in-promise\n          .then(res => cb(null, res))\n          // eslint-disable-next-line promise/no-callback-in-promise\n          .catch(err => cb(err));\n        }\n        return originalMethod.apply(this, [request, cb]);\n      };\n    };\n\n    // Detects call to eth_requestAccounts in request & sendAsync and passes to login\n    detectAccountRequestPrototypeModifier(\"request\");\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\n    detectAccountRequestPrototypeModifier(\"send\");\n    const proxiedInPageProvider = new Proxy(inPageProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    this.provider = proxiedInPageProvider;\n    this.communicationProvider = proxiedCommunicationProvider;\n    log.info(\"test setupWeb3 \");\n    await Promise.all([inPageProvider.initializeState(), communicationProvider.initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {\n      torusIframeId: providerParams.walletIframe.id\n    }))]);\n    log.debug(\"WsEmbed - injected provider\");\n  }\n}\n\nexport { BUTTON_POSITION, TorusInPageProvider, WS_EMBED_BUILD_ENV, WsEmbed as default };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { EVM_PLUGINS, PLUGIN_STATUS, WALLET_ADAPTERS, PLUGIN_NAMESPACES, WalletServicesPluginError, PLUGIN_EVENTS, ADAPTER_STATUS, ADAPTER_EVENTS } from '@web3auth/base';\nimport WsEmbed from '@web3auth/ws-embed';\nimport log from 'loglevel';\n\nclass WalletServicesPlugin extends SafeEventEmitter {\n  constructor(options = {}) {\n    super();\n    _defineProperty(this, \"name\", EVM_PLUGINS.WALLET_SERVICES);\n    _defineProperty(this, \"status\", PLUGIN_STATUS.DISCONNECTED);\n    _defineProperty(this, \"SUPPORTED_ADAPTERS\", [WALLET_ADAPTERS.OPENLOGIN, WALLET_ADAPTERS.SFA]);\n    _defineProperty(this, \"pluginNamespace\", PLUGIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"wsEmbedInstance\", void 0);\n    _defineProperty(this, \"provider\", null);\n    _defineProperty(this, \"web3auth\", null);\n    _defineProperty(this, \"isInitialized\", false);\n    _defineProperty(this, \"walletInitOptions\", null);\n    const {\n      wsEmbedOpts,\n      walletInitOptions\n    } = options;\n    // we fake these checks here and get them from web3auth instance\n    this.wsEmbedInstance = new WsEmbed(wsEmbedOpts || {});\n    this.walletInitOptions = walletInitOptions || {};\n  }\n  get proxyProvider() {\n    return this.wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;\n  }\n  async initWithWeb3Auth(web3auth, whiteLabel) {\n    var _this$web3auth$coreOp;\n    if (this.isInitialized) return;\n    if (!web3auth) throw WalletServicesPluginError.web3authRequired();\n    if (web3auth.provider && !this.SUPPORTED_ADAPTERS.includes(web3auth.connectedAdapterName)) throw WalletServicesPluginError.notInitialized();\n    if (web3auth.coreOptions.chainConfig.chainNamespace !== this.pluginNamespace) throw WalletServicesPluginError.unsupportedChainNamespace();\n    // Not connected yet to openlogin\n    if (web3auth.provider) {\n      this.provider = web3auth.provider;\n    }\n    this.web3auth = web3auth;\n    const mergedWhitelabelSettings = _objectSpread(_objectSpread({}, whiteLabel), this.walletInitOptions.whiteLabel || {});\n    const {\n      logoDark,\n      logoLight\n    } = mergedWhitelabelSettings || {};\n    if (!logoDark || !logoLight) throw WalletServicesPluginError.invalidParams(\"logoDark and logoLight are required in whiteLabel config\");\n    this.wsEmbedInstance.web3AuthClientId = this.web3auth.coreOptions.clientId;\n    this.wsEmbedInstance.web3AuthNetwork = this.web3auth.coreOptions.web3AuthNetwork;\n    this.subscribeToWeb3AuthEvents(web3auth);\n    const connectedChainConfig = web3auth.coreOptions.chainConfig;\n    if (!connectedChainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams(\"blockExplorerUrl is required in chainConfig\");\n    if (!connectedChainConfig.displayName) throw WalletServicesPluginError.invalidParams(\"displayName is required in chainConfig\");\n    if (!connectedChainConfig.logo) throw WalletServicesPluginError.invalidParams(\"logo is required in chainConfig\");\n    if (!connectedChainConfig.ticker) throw WalletServicesPluginError.invalidParams(\"ticker is required in chainConfig\");\n    if (!connectedChainConfig.tickerName) throw WalletServicesPluginError.invalidParams(\"tickerName is required in chainConfig\");\n    const finalInitOptions = _objectSpread(_objectSpread({}, this.walletInitOptions), {}, {\n      chainConfig: connectedChainConfig,\n      enableLogging: (_this$web3auth$coreOp = this.web3auth.coreOptions) === null || _this$web3auth$coreOp === void 0 ? void 0 : _this$web3auth$coreOp.enableLogging,\n      whiteLabel: mergedWhitelabelSettings\n    });\n    await this.wsEmbedInstance.init(finalInitOptions);\n    this.isInitialized = true;\n    this.status = PLUGIN_STATUS.READY;\n    this.emit(PLUGIN_EVENTS.READY);\n  }\n  initWithProvider() {\n    throw new Error(\"Method not implemented.\");\n  }\n  async connect({\n    sessionId,\n    sessionNamespace\n  }) {\n    // if web3auth is being used and connected to unsupported adapter throw error\n    if (!this.isInitialized) throw WalletServicesPluginError.notInitialized();\n    this.emit(PLUGIN_EVENTS.CONNECTING);\n    this.status = PLUGIN_STATUS.CONNECTING;\n    if (!this.provider) {\n      var _this$web3auth;\n      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {\n        this.provider = this.web3auth.provider;\n      }\n    }\n    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) {\n      throw WalletServicesPluginError.web3AuthNotConnected();\n    } else if (!this.web3auth.provider) {\n      throw WalletServicesPluginError.providerRequired();\n    }\n    if (!sessionId) {\n      throw WalletServicesPluginError.web3AuthNotConnected();\n    }\n    try {\n      var _this$walletInitOptio;\n      await this.wsEmbedInstance.loginWithSessionId({\n        sessionId,\n        sessionNamespace\n      });\n      if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && (_this$walletInitOptio = _this$walletInitOptio.whiteLabel) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.showWidgetButton) this.wsEmbedInstance.showTorusButton();\n      this.subscribeToProviderEvents(this.provider);\n      this.subscribeToWalletEvents();\n      this.emit(PLUGIN_EVENTS.CONNECTED);\n      this.status = PLUGIN_STATUS.CONNECTED;\n    } catch (error) {\n      log.error(error);\n      this.status = PLUGIN_STATUS.ERRORED;\n      this.emit(PLUGIN_EVENTS.ERRORED, {\n        error: error.message || \"Something went wrong\"\n      });\n    }\n  }\n  async showWalletConnectScanner() {\n    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();\n    await this.wsEmbedInstance.showWalletConnectScanner();\n  }\n  async showCheckout() {\n    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();\n    await this.wsEmbedInstance.showCheckout();\n  }\n  async showWalletUi() {\n    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();\n    await this.wsEmbedInstance.showWalletUi();\n  }\n  async disconnect() {\n    // if web3auth is being used and connected to unsupported adapter throw error\n    if (this.wsEmbedInstance.isLoggedIn) {\n      await this.wsEmbedInstance.logout();\n      this.emit(PLUGIN_EVENTS.DISCONNECTED);\n      this.status = PLUGIN_STATUS.DISCONNECTED;\n    } else {\n      throw WalletServicesPluginError.invalidSession(\"Wallet Services plugin is not connected\");\n    }\n  }\n  subscribeToWalletEvents() {\n    var _this$wsEmbedInstance;\n    (_this$wsEmbedInstance = this.wsEmbedInstance) === null || _this$wsEmbedInstance === void 0 || _this$wsEmbedInstance.provider.on(\"accountsChanged\", (accounts = []) => {\n      if (accounts.length === 0) {\n        var _this$web3auth2, _this$web3auth3;\n        this.wsEmbedInstance.hideTorusButton();\n        if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.status) === ADAPTER_STATUS.CONNECTED) (_this$web3auth3 = this.web3auth) === null || _this$web3auth3 === void 0 || _this$web3auth3.logout();\n      }\n    });\n  }\n  subscribeToProviderEvents(provider) {\n    provider.on(\"accountsChanged\", (data = {\n      accounts: []\n    }) => {\n      this.setSelectedAddress(data.accounts[0]);\n    });\n    provider.on(\"chainChanged\", chainId => {\n      this.setChainID(parseInt(chainId, 16));\n    });\n    provider.on(\"disconnect\", () => {\n      this.wsEmbedInstance.hideTorusButton();\n    });\n    provider.on(\"connect\", () => {\n      var _this$walletInitOptio2;\n      if ((_this$walletInitOptio2 = this.walletInitOptions) !== null && _this$walletInitOptio2 !== void 0 && (_this$walletInitOptio2 = _this$walletInitOptio2.whiteLabel) !== null && _this$walletInitOptio2 !== void 0 && _this$walletInitOptio2.showWidgetButton) this.wsEmbedInstance.showTorusButton();\n    });\n  }\n  subscribeToWeb3AuthEvents(web3Auth) {\n    web3Auth.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.provider = data.provider || web3Auth.provider;\n      if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();\n      this.subscribeToProviderEvents(this.provider);\n    });\n    web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, async () => {\n      this.provider = null;\n      if (this.wsEmbedInstance.isLoggedIn) {\n        await this.wsEmbedInstance.logout();\n      }\n      this.wsEmbedInstance.hideTorusButton();\n    });\n  }\n  async sessionConfig() {\n    if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();\n    const [accounts, chainId, chainConfig] = await Promise.all([this.provider.request({\n      method: \"eth_accounts\"\n    }), this.provider.request({\n      method: \"eth_chainId\"\n    }), this.provider.request({\n      method: \"eth_provider_config\"\n    })]);\n    return {\n      chainId: parseInt(chainId, 16),\n      accounts: accounts,\n      chainConfig: chainConfig\n    };\n  }\n  async walletServicesSessionConfig() {\n    if (!this.wsEmbedInstance.provider) throw WalletServicesPluginError.web3AuthNotConnected();\n    const [accounts, chainId] = await Promise.all([this.wsEmbedInstance.provider.request({\n      method: \"eth_accounts\"\n    }), this.wsEmbedInstance.provider.request({\n      method: \"eth_chainId\"\n    })]);\n    return {\n      chainId: parseInt(chainId, 16),\n      accounts: accounts\n    };\n  }\n  async setSelectedAddress(address) {\n    var _walletServicesSessio;\n    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) throw WalletServicesPluginError.web3AuthNotConnected();\n    const walletServicesSessionConfig = await this.walletServicesSessionConfig();\n    if (address !== ((_walletServicesSessio = walletServicesSessionConfig.accounts) === null || _walletServicesSessio === void 0 ? void 0 : _walletServicesSessio[0])) {\n      throw WalletServicesPluginError.invalidSession();\n    }\n  }\n  async setChainID(chainId) {\n    const [sessionConfig, walletServicesSessionConfig] = await Promise.all([this.sessionConfig(), this.walletServicesSessionConfig()]);\n    const {\n      chainConfig\n    } = sessionConfig || {};\n    if (!chainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams(\"blockExplorerUrl is required in chainConfig\");\n    if (!chainConfig.displayName) throw WalletServicesPluginError.invalidParams(\"displayName is required in chainConfig\");\n    if (!chainConfig.logo) throw WalletServicesPluginError.invalidParams(\"logo is required in chainConfig\");\n    if (!chainConfig.ticker) throw WalletServicesPluginError.invalidParams(\"ticker is required in chainConfig\");\n    if (!chainConfig.tickerName) throw WalletServicesPluginError.invalidParams(\"tickerName is required in chainConfig\");\n    if (chainId !== walletServicesSessionConfig.chainId && chainConfig) {\n      try {\n        var _this$wsEmbedInstance2, _this$wsEmbedInstance3;\n        await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({\n          method: \"wallet_addEthereumChain\",\n          params: [{\n            chainId: chainConfig.chainId,\n            chainName: chainConfig.displayName,\n            rpcUrls: [chainConfig.rpcTarget],\n            blockExplorerUrls: [chainConfig.blockExplorerUrl],\n            nativeCurrency: {\n              name: chainConfig.tickerName,\n              symbol: chainConfig.ticker,\n              decimals: chainConfig.decimals || 18\n            },\n            iconUrls: [chainConfig.logo]\n          }]\n        }).catch(() => {\n          // TODO: throw more specific error from the controller\n          log.error(\"WalletServicesPlugin: Error adding chain\");\n        }));\n        await ((_this$wsEmbedInstance3 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance3 === void 0 ? void 0 : _this$wsEmbedInstance3.request({\n          method: \"wallet_switchEthereumChain\",\n          params: [{\n            chainId: chainConfig.chainId\n          }]\n        }));\n      } catch (error) {\n        // TODO: throw more specific error from the controller\n        log.error(\"WalletServicesPlugin: Error switching chain\");\n      }\n    }\n  }\n}\n\nexport { WalletServicesPlugin };\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "deepmerge", "d", "b", "PatchError", "document", "Mirror", "ObserverInfo", "CacheStrategy", "import_loglevel", "log", "loglevel", "pump", "dequal", "window", "document", "import_loglevel", "log"]
}
