{
  "version": 3,
  "sources": ["../../@toruslabs/torus-embed/dist/torus.esm.js", "../../@metamask/rpc-errors/src/error-constants.ts", "../../@metamask/superstruct/src/error.ts", "../../@metamask/superstruct/src/utils.ts", "../../@metamask/superstruct/src/struct.ts", "../../@metamask/superstruct/src/structs/utilities.ts", "../../@metamask/superstruct/src/structs/types.ts", "../../@metamask/superstruct/src/structs/coercions.ts", "../../@metamask/superstruct/src/structs/refinements.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/misc.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/errors.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/assert.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/base64.ts", "../../@scure/base/index.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/hex.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/bytes.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/caip-types.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/checksum.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/coercers.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/collections.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/json.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/logging.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/time.ts", "../../@metamask/rpc-errors/node_modules/@metamask/utils/src/versions.ts", "../../@metamask/rpc-errors/src/utils.ts", "../../@metamask/rpc-errors/src/classes.ts", "../../@metamask/rpc-errors/src/errors.ts", "../../@web3auth/torus-evm-adapter/dist/torusEvmAdapter.esm.js"],
  "sourcesContent": ["import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { get, setAPIKey } from '@toruslabs/http-helpers';\nimport { SafeEventEmitter, ObjectMultiplex, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, BasePostMessageStream, setupMultiplex } from '@toruslabs/openlogin-jrpc';\nimport deepmerge from 'lodash.merge';\nimport { rpcErrors, EthereumProviderError } from '@metamask/rpc-errors';\nimport dequal from 'fast-deep-equal';\nimport pump from 'pump';\nimport loglevel from 'loglevel';\n\nconst WALLET_VERIFIERS = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  TWITCH: \"twitch\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  EMAIL_PASSWORDLESS: \"torus-auth0-email-passwordless\"\n};\nconst WALLET_OPENLOGIN_VERIFIER_MAP = {\n  [WALLET_VERIFIERS.GOOGLE]: \"tkey-google\",\n  [WALLET_VERIFIERS.FACEBOOK]: \"tkey-facebook\",\n  [WALLET_VERIFIERS.TWITCH]: \"tkey-twitch\",\n  [WALLET_VERIFIERS.REDDIT]: \"tkey-reddit\",\n  [WALLET_VERIFIERS.DISCORD]: \"tkey-discord\",\n  [WALLET_VERIFIERS.EMAIL_PASSWORDLESS]: \"tkey-auth0-email-passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  RAMPNETWORK: \"rampnetwork\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\",\n  BANXA: \"banxa\"\n};\nconst SUPPORTED_PAYMENT_NETWORK = {\n  MAINNET: \"mainnet\",\n  MATIC: \"matic\",\n  BSC_MAINNET: \"bsc_mainnet\",\n  AVALANCHE_MAINNET: \"avalanche_mainnet\",\n  XDAI: \"xdai\",\n  ARBITRUM_MAINNET: \"arbitrum_mainnet\",\n  OPTIMISM_MAINNET: \"optimism_mainnet\"\n};\nconst TORUS_BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  BINANCE: \"binance\",\n  TESTING: \"testing\",\n  LRC: \"lrc\",\n  BETA: \"beta\",\n  BNB: \"bnb\",\n  POLYGON: \"polygon\",\n  ALPHA: \"alpha\"\n};\nconst BUTTON_POSITION = {\n  BOTTOM_LEFT: \"bottom-left\",\n  TOP_LEFT: \"top-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_RIGHT: \"top-right\"\n};\n\n/**\n * From https://min-api.cryptocompare.com/data/v2/pair/mapping/fsym?fsym=BTC&extraParams=YourSite\n * GET https://min-api.cryptocompare.com/data/v2/pair/mapping/fsym?fsym=BTC\n * Then map over returned entries, picking tsym\n *\n * Last updated: Date of commit\n */\nconst CRYPTO_COMPARE_CURRENCIES = [\"ETH\", \"USDT\", \"USDC\", \"TUSD\", \"EOSDT\", \"USD\", \"DAI\", \"GUSD\", \"DKKT\", \"PAX\", \"ILS\", \"RUB\", \"BYN\", \"EUR\", \"GBP\", \"JPY\", \"KRW\", \"PLN\", \"MXN\", \"AUD\", \"BRL\", \"CAD\", \"CHF\", \"KPW\", \"LAK\", \"LBP\", \"LKR\", \"XOF\", \"CNHT\", \"DOGE\", \"UAH\", \"TRY\", \"HKD\", \"XJP\", \"SGD\", \"USC\", \"NZD\", \"NGN\", \"RUR\", \"COP\", \"GHS\", \"EGP\", \"IDR\", \"BHD\", \"CRC\", \"PEN\", \"AED\", \"DOP\", \"PKR\", \"HUF\", \"VND\", \"XAR\", \"LTC\", \"RON\", \"OMR\", \"MYR\", \"DKK\", \"UGX\", \"ZMW\", \"SAR\", \"SEK\", \"GEL\", \"RWF\", \"IRR\", \"TZS\", \"CNY\", \"VEF\", \"BDT\", \"HRK\", \"CLP\", \"THB\", \"XAF\", \"ARS\", \"UYU\", \"SZL\", \"KZT\", \"NOK\", \"KES\", \"PAB\", \"INR\", \"CZK\", \"MAD\", \"TWD\", \"PHP\", \"ZAR\", \"BOB\", \"CDF\", \"DASH\", \"VES\", \"ISK\", \"MWK\", \"BAM\", \"TTD\", \"XRP\", \"JOD\", \"RSD\", \"HNL\", \"BGN\", \"GTQ\", \"BWP\", \"XMR\", \"MMK\", \"QAR\", \"AOA\", \"KWD\", \"MUR\", \"WUSD\", \"WEUR\", \"WAVES\", \"WTRY\", \"LRD\", \"LSL\", \"LYD\", \"AWG\", \"MDL\", \"BTO\", \"EURS\", \"CHFT\", \"MKD\", \"MNT\", \"MOP\", \"MRO\", \"MVR\", \"VOLLAR\", \"CKUSD\", \"KHR\", \"VUV\", \"BITCNY\", \"QC\", \"BBD\", \"NAD\", \"NPR\", \"PGK\", \"PYG\", \"BIF\", \"BMD\", \"BND\", \"XLM\", \"BNB\", \"SCR\", \"BAT\", \"CRO\", \"HT\", \"KCS\", \"LEO\", \"LINK\", \"MKR\", \"NPXS\", \"OMG\", \"REP\", \"ZB\", \"ZIL\", \"ZRX\", \"BCH\", \"BZD\", \"CUP\", \"CVE\", \"DJF\", \"DZD\", \"ERN\", \"ETB\", \"FJD\", \"FKP\", \"BUSD\", \"ANCT\", \"ALL\", \"AMD\", \"ANG\", \"CNYX\", \"IQD\", \"UZS\", \"TND\", \"GGP\", \"XAU\", \"KGS\", \"GIP\", \"JMD\", \"ZEC\", \"USDP\", \"BSV\", \"EMC2\", \"SNT\", \"GTO\", \"POWR\", \"EUSD\", \"EURT\", \"BCY\", \"BTS\", \"ATM\", \"BLOCKPAY\", \"ARDR\", \"AMP\", \"B2X\", \"BITGOLD\", \"BITEUR\", \"ATB\", \"BITUSD\", \"AGRS\", \"DFXT\", \"HIKEN\", \"BIX\", \"KNC\", \"EOS\", \"COB\", \"COSS\", \"BMH\", \"NANO\", \"BDG\", \"BNT\", \"XVG\", \"LKK1Y\", \"LKK\", \"USDK\", \"EURN\", \"NZDT\", \"JSE\", \"GMD\", \"GNF\", \"GYD\", \"YER\", \"XPF\", \"HTG\", \"SLL\", \"SOS\", \"WST\", \"SVC\", \"SYP\", \"NEO\", \"KMF\", \"JUMP\", \"AYA\", \"BLAST\", \"WGR\", \"BCN\", \"BTG\", \"URALS\", \"INN\", \"USDQ\", \"CNH\", \"HUSD\", \"BKRW\", \"NZDX\", \"EURX\", \"CADX\", \"USDEX\", \"JPYX\", \"AUDX\", \"VNDC\", \"EON\", \"GBPX\", \"CHFX\", \"USDJ\", \"IDRT\", \"USDS\", \"USDN\", \"BIDR\", \"IDK\", \"BSD\", \"BTN\", \"KYD\", \"NIO\", \"SBD\", \"SDG\", \"SHP\", \"TOP\", \"XCD\", \"XCHF\", \"CNYT\", \"GYEN\", \"ZUSD\", \"GOLD\", \"TRX\", \"TRYB\", \"PLATC\", \"STRAX\", \"UST\", \"GLM\", \"VAI\", \"BRZ\", \"DDRST\", \"XAUT\", \"MIM\"];\n\n/**\n * currencies supported by the payment provider\n * Last updated: Date of commit\n */\nconst PROVIDER_SUPPORTED_FIAT_CURRENCIES = {\n  // https://integrations.simplex.com/supported_currencies\n  // https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-\n  [PAYMENT_PROVIDER.MOONPAY]: [\"AUD\", \"BGN\", \"BRL\", \"CAD\", \"CHF\", \"CNY\", \"COP\", \"CZK\", \"DKK\", \"DOP\", \"EGP\", \"EUR\", \"GBP\", \"HKD\", \"HRK\", \"IDR\", \"ILS\", \"JPY\", \"JOD\", \"KES\", \"KRW\", \"KWD\", \"LKR\", \"MAD\", \"MXN\", \"MYR\", \"NGN\", \"NOK\", \"NZD\", \"OMR\", \"PEN\", \"PKR\", \"PLN\", \"RON\", \"RUB\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TWD\", \"USD\", \"VND\", \"ZAR\"],\n  // https://support.ramp.network/en/articles/471-supported-fiat-currencies\n  [PAYMENT_PROVIDER.RAMPNETWORK]: [\"USD\", \"EUR\", \"GBP\", \"BMD\", \"BAM\", \"BWP\", \"BRL\", \"BGN\", \"COP\", \"CRC\", \"CZK\", \"DKK\", \"DOP\", \"GEL\", \"GTQ\", \"HNL\", \"HUF\", \"ISK\", \"INR\", \"ILS\", \"KZT\", \"KES\", \"KWD\", \"LAK\", \"MKD\", \"MYR\", \"MXN\", \"MDL\", \"MZN\", \"NZD\", \"NGN\", \"PYG\", \"PEN\", \"PLN\", \"RON\", \"RSD\", \"SGD\", \"ZAR\", \"LKR\", \"SEK\", \"CHF\", \"TJS\", \"THB\", \"UYU\"],\n  // https://help.mercuryo.io/en/articles/6121246-which-fiat-currencies-are-supported\n  // RUB / UAH currently not supported\n  [PAYMENT_PROVIDER.MERCURYO]: [\"EUR\", \"USD\", \"GBP\", \"TRY\", \"JPY\", \"BRL\", \"NGN\", \"VND\", \"MXN\", \"KRW\", \"PLN\", \"SEK\", \"CHF\", \"CAD\", \"CZK\", \"DKK\", \"BGN\", \"HKD\", \"AUD\", \"INR\"],\n  /**\n   * https://support.transak.com/hc/en-us/articles/360020615578-Credit-and-Debit-Card-Payments-through-Transak\n   * or\n   * https://transak.stoplight.io/docs/transak-docs/b3A6OTk1ODQ0-2-get-fiat-currencies\n   */\n  [PAYMENT_PROVIDER.TRANSAK]: [\"ARS\", \"AUD\", \"BBD\", \"BGN\", \"BMD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\", \"CRC\", \"CZK\", \"DKK\", \"DOP\", \"EUR\", \"FJD\", \"FKP\", \"GBP\", \"GIP\", \"HRK\", \"HUF\", \"IDR\", \"ILS\", \"ISK\", \"JMD\", \"JPY\", \"KES\", \"KRW\", \"MDL\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PEN\", \"PHP\", \"PLN\", \"PYG\", \"RON\", \"SEK\", \"SGD\", \"THB\", \"TRY\", \"TZS\", \"USD\", \"ZAR\"],\n  [PAYMENT_PROVIDER.BANXA]: [\"AUD\", \"CAD\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"JPY\", \"NOK\", \"NZD\", \"NZD\", \"PLN\", \"RUB\", \"SEK\", \"SGD\", \"TRY\", \"USD\"]\n};\nconst cryptoCompareCurrenciesSet = new Set(CRYPTO_COMPARE_CURRENCIES);\n/**\n * Fiat currencies that we support\n */\nfunction supportedFiatCurrencies(provider) {\n  const providerSupportedFiatCurrencies = PROVIDER_SUPPORTED_FIAT_CURRENCIES[provider];\n  return providerSupportedFiatCurrencies.filter(currency => cryptoCompareCurrenciesSet.has(currency));\n}\n\nconst paymentProviders$1 = {\n  [PAYMENT_PROVIDER.MOONPAY]: {\n    line1: \"Credit/ Debit Card/ Apple Pay\",\n    line2: \"4.5% or 5 USD\",\n    line3: \"2,000€/day, 10,000€/mo\",\n    supportPage: \"https://help.moonpay.io/en/\",\n    minOrderValue: 24.99,\n    maxOrderValue: 50000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.MOONPAY),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"aave\",\n        display: \"AAVE\"\n      }, {\n        value: \"bat\",\n        display: \"BAT\"\n      }, {\n        value: \"dai\",\n        display: \"DAI\"\n      }, {\n        value: \"eth\",\n        display: \"ETH\"\n      }, {\n        value: \"mkr\",\n        display: \"MKR\"\n      }, {\n        value: \"matic\",\n        display: \"MATIC\"\n      }, {\n        value: \"usdt\",\n        display: \"USDT\"\n      }, {\n        value: \"uni\",\n        display: \"UNI\"\n      }, {\n        value: \"usdc\",\n        display: \"USDC\"\n      }, {\n        value: \"weth\",\n        display: \"WETH\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"eth_polygon\",\n        display: \"ETH\"\n      }, {\n        value: \"matic_polygon\",\n        display: \"MATIC\"\n      }, {\n        value: \"usdc_polygon\",\n        display: \"USDC\"\n      }, {\n        value: \"usdt_polygon\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"bnb_bsc\",\n        display: \"BNB\"\n      }, {\n        value: \"busd_bsc\",\n        display: \"BUSD\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"avax_cchain\",\n        display: \"AVAX\"\n      }, {\n        value: \"usdc_cchain\",\n        display: \"USDC\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.ARBITRUM_MAINNET]: [{\n        value: \"eth_arbitrum\",\n        display: \"ETH\"\n      }, {\n        value: \"usdc_arbitrum\",\n        display: \"USDC\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.OPTIMISM_MAINNET]: [{\n        value: \"eth_optimism\",\n        display: \"ETH\"\n      }, {\n        value: \"usdc_optimism\",\n        display: \"USDC\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.RAMPNETWORK]: {\n    line1: \"Debit Card/ <br>Apple Pay/ Bank transfer\",\n    line2: \"0.49% - 2.9%\",\n    line3: \"5,000€/purchase, 20,000€/mo\",\n    supportPage: \"https://instant.ramp.network/\",\n    minOrderValue: 50,\n    maxOrderValue: 20000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.RAMPNETWORK),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MATIC_BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"MATIC_DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"MATIC_MATIC\",\n        display: \"MATIC\"\n      }, {\n        value: \"MATIC_USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"MATIC_USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAX_AVAX\",\n        display: \"AVAX\"\n      }, {\n        value: \"AVAX_USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"AVAX_USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.ARBITRUM_MAINNET]: [{\n        value: \"ARBITRUM_ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"ARBITRUM_USDC.e\t\",\n        display: \"USDC\"\n      }, {\n        value: \"ARBITRUM_USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.OPTIMISM_MAINNET]: [{\n        value: \"OPTIMISM_DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"OPTIMISM_OPTIMISM\",\n        display: \"OPTIMISM\"\n      }, {\n        value: \"OPTIMISM_USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"OPTIMISM_USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"BSC_BNB\",\n        display: \"BNB\"\n      }, {\n        value: \"BSC_BUSD\",\n        display: \"BUSD\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    receiveHint: \"walletTopUp.receiveHintRamp\",\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.MERCURYO]: {\n    line1: \"Credit/ Debit Card/ Apple Pay\",\n    line2: \"3.95% or 4 USD\",\n    line3: \"10,000€/day, 25,000€/mo\",\n    supportPage: \"mailto:support@mercuryo.io\",\n    minOrderValue: 30,\n    maxOrderValue: 5000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.MERCURYO),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"BNB\",\n        display: \"BNB\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }, {\n        value: \"1INCH\",\n        display: \"1INCH\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAX\",\n        display: \"AVAX\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MATIC\",\n        display: \"MATIC\"\n      }]\n    },\n    includeFees: true,\n    api: true,\n    enforceMax: false\n  },\n  [PAYMENT_PROVIDER.TRANSAK]: {\n    line1: \"Apple & Google Pay / Credit/Debit Card<br/>Bangkok Bank Mobile & iPay<br/>Bank Transfer (sepa/gbp) / SCB Mobile & Easy\",\n    line2: \"0.99% - 5.5% or 5 USD\",\n    line3: \"$5,000/day, $28,000/mo\",\n    supportPage: \"https://support.transak.com/hc/en-US\",\n    minOrderValue: 30,\n    maxOrderValue: 500,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.TRANSAK),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"1INCH\",\n        display: \"1INCH\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"MATIC\",\n        display: \"MATIC\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"WETH\",\n        display: \"WETH\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.BSC_MAINNET]: [{\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"BNB\",\n        display: \"BNB\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.AVALANCHE_MAINNET]: [{\n        value: \"AVAX\",\n        display: \"AVAX\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.OPTIMISM_MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.ARBITRUM_MAINNET]: [{\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"ETH\",\n        display: \"ETH\"\n      }]\n    },\n    includeFees: true,\n    enforceMax: true\n  },\n  [PAYMENT_PROVIDER.BANXA]: {\n    line1: \"Debit Card/ <br>Apple Pay/ Bank transfer\",\n    line2: \"0.49% - 2.9%\",\n    line3: \"5,000€/purchase, 20,000€/mo\",\n    supportPage: \"https://support.banxa.com\",\n    minOrderValue: 20,\n    maxOrderValue: 15000,\n    validCurrencies: supportedFiatCurrencies(PAYMENT_PROVIDER.BANXA),\n    validCryptoCurrenciesByChain: {\n      [SUPPORTED_PAYMENT_NETWORK.MAINNET]: [{\n        value: \"ETH\",\n        display: \"ETH\"\n      }, {\n        value: \"DAI\",\n        display: \"DAI\"\n      }, {\n        value: \"MKR\",\n        display: \"MKR\"\n      }, {\n        value: \"USDT\",\n        display: \"USDT\"\n      }, {\n        value: \"BUSD\",\n        display: \"BUSD\"\n      }, {\n        value: \"USDC\",\n        display: \"USDC\"\n      }, {\n        value: \"BAT\",\n        display: \"BAT\"\n      }, {\n        value: \"AAVE\",\n        display: \"AAVE\"\n      }, {\n        value: \"COMP\",\n        display: \"COMP\"\n      }, {\n        value: \"UNI\",\n        display: \"UNI\"\n      }],\n      [SUPPORTED_PAYMENT_NETWORK.MATIC]: [{\n        value: \"MATIC\",\n        display: \"MATIC\"\n      }]\n      // [BSC_MAINNET]: [{ value: 'BNB', display: 'BNB' }],\n    },\n    includeFees: true,\n    enforceMax: true\n  }\n};\nconst translations = {\n  en: {\n    embed: {\n      continue: \"Continue\",\n      actionRequired: \"Authorization required\",\n      pendingAction: \"Click continue to proceed with your request in a popup\",\n      cookiesRequired: \"Cookies Required\",\n      enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n      clickHere: \"More Info\"\n    }\n  },\n  de: {\n    embed: {\n      continue: \"Fortsetzen\",\n      actionRequired: \"Autorisierung erforderlich\",\n      pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n      cookiesRequired: \"Cookies benötigt\",\n      enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n      clickHere: \"Mehr Info\"\n    }\n  },\n  ja: {\n    embed: {\n      continue: \"継続する\",\n      actionRequired: \"認証が必要です\",\n      pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\n      cookiesRequired: \"必要なクッキー\",\n      enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\n      clickHere: \"詳しくは\"\n    }\n  },\n  ko: {\n    embed: {\n      continue: \"계속하다\",\n      actionRequired: \"승인 필요\",\n      pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\n      cookiesRequired: \"쿠키 필요\",\n      enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\n      clickHere: \"더 많은 정보\"\n    }\n  },\n  zh: {\n    embed: {\n      continue: \"继续\",\n      actionRequired: \"需要授权\",\n      pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\n      cookiesRequired: \"必填Cookie\",\n      enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\n      clickHere: \"更多信息\"\n    }\n  }\n};\nvar configuration = {\n  supportedVerifierList: Object.values(WALLET_VERIFIERS),\n  paymentProviders: paymentProviders$1,\n  api: \"https://api.tor.us\",\n  translations,\n  prodTorusUrl: \"\",\n  localStorageKeyPrefix: `torus-`\n};\n\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\nconst handleStream = (handle, eventName, handler) => {\n  const handlerWrapper = chunk => {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n  handle.on(eventName, handlerWrapper);\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction isStream(stream) {\n  return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\n}\nfunction isWritableStream(stream) {\n  return isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\n}\nfunction isReadableStream(stream) {\n  return isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\n}\nfunction isDuplexStream(stream) {\n  return isWritableStream(stream) && isReadableStream(stream);\n}\n\nvar log = loglevel.getLogger(\"torus-embed\");\n\nvar messages = {\n  errors: {\n    disconnected: () => \"Torus: Lost connection to Torus.\",\n    permanentlyDisconnected: () => \"Torus: Disconnected from iframe. Page reload required.\",\n    sendSiteMetadata: () => \"Torus: Failed to send site metadata. This is an internal error, please report this bug.\",\n    unsupportedSync: method => `Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\n    invalidOptions: (maxEventListeners, shouldSendMetadata) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}, shouldSendMetadata: ${shouldSendMetadata} }`,\n    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,\n    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,\n    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,\n    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,\n    invalidLoggerMethod: method => `'args.logger' must include required method '${method}'.`\n  },\n  info: {\n    connected: chainId => `Torus: Connected to chain with ID \"${chainId}\".`\n  },\n  warnings: {\n    // deprecated methods\n    enableDeprecation: 'Torus: \"\"ethereum.enable()\" is deprecated and may be removed in the future. ' + 'Please use \"ethereum.send(\"eth_requestAccounts\")\" instead. For more information, see: https://eips.ethereum.org/EIPS/eip-1102',\n    sendDeprecation: 'Torus: \"ethereum.send(...)\" is deprecated and may be removed in the future.' + ' Please use \"ethereum.sendAsync(...)\" or \"ethereum.request(...)\" instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193'\n  }\n};\n\nconst {\n  paymentProviders\n} = configuration;\nconst validatePaymentProvider = (provider, params) => {\n  const errors = {};\n  if (!provider) {\n    return {\n      errors,\n      isValid: true\n    };\n  }\n  if (provider && !paymentProviders[provider]) {\n    errors.provider = \"Invalid Provider\";\n    return {\n      errors,\n      isValid: Object.keys(errors).length === 0\n    };\n  }\n  const selectedProvider = paymentProviders[provider];\n  const selectedParams = params || {};\n\n  // set default values\n  // if (!selectedParams.selectedCurrency) [selectedParams.selectedCurrency] = selectedProvider.validCurrencies\n  // if (!selectedParams.fiatValue) selectedParams.fiatValue = selectedProvider.minOrderValue\n  // if (!selectedParams.selectedCryptoCurrency) [selectedParams.selectedCryptoCurrency] = selectedProvider.validCryptoCurrencies\n\n  // validations\n  if (selectedParams.fiatValue) {\n    const requestedOrderAmount = +parseFloat(selectedParams.fiatValue.toString()) || 0;\n    if (requestedOrderAmount < selectedProvider.minOrderValue) errors.fiatValue = \"Requested amount is lower than supported\";\n    if (requestedOrderAmount > selectedProvider.maxOrderValue && selectedProvider.enforceMax) errors.fiatValue = \"Requested amount is higher than supported\";\n  }\n  if (selectedParams.selectedCurrency && !selectedProvider.validCurrencies.includes(selectedParams.selectedCurrency)) {\n    errors.selectedCurrency = \"Unsupported currency\";\n  }\n  if (selectedParams.selectedCryptoCurrency) {\n    const validCryptoCurrenciesByChain = Object.values(selectedProvider.validCryptoCurrenciesByChain).flat().map(currency => currency.value);\n    const finalCryptoCurrency = provider === PAYMENT_PROVIDER.MOONPAY ? selectedParams.selectedCryptoCurrency.toLowerCase() : selectedParams.selectedCryptoCurrency;\n    if (validCryptoCurrenciesByChain && !validCryptoCurrenciesByChain.includes(finalCryptoCurrency)) errors.selectedCryptoCurrency = \"Unsupported cryptoCurrency\";\n  }\n  return {\n    errors,\n    isValid: Object.keys(errors).length === 0\n  };\n};\n\n// utility functions\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\nfunction createErrorMiddleware() {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== \"string\" || !req.method) {\n      res.error = rpcErrors.invalidRequest({\n        message: `The request 'method' must be a non-empty string.`,\n        data: _objectSpread(_objectSpread({}, req || {}), {}, {\n          cause: \"The request 'method' must be a non-empty string.\"\n        })\n      });\n    }\n    next(done => {\n      const {\n        error\n      } = res;\n      if (!error) {\n        return done();\n      }\n      log.error(`MetaMask - RPC Error: ${error.message}`, error);\n      return done();\n    });\n  };\n}\n\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\n  let warningMsg = `MetaMask: Lost connection to \"${remoteLabel}\".`;\n  if (error !== null && error !== void 0 && error.stack) {\n    warningMsg += `\\n${error.stack}`;\n  }\n  log.warn(warningMsg);\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\n    emitter.emit(\"error\", warningMsg);\n  }\n}\nconst getPreopenInstanceId = () => Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv, integrity) => {\n  let torusUrl;\n  let logLevel;\n  // Do not change this line\n  const version = \"5.0.0\";\n  let versionUsed = integrity.version || version;\n  try {\n    if ((buildEnv === \"binance\" || buildEnv === \"production\") && !integrity.version) {\n      let response;\n      if (!configuration.prodTorusUrl) response = await get(`${configuration.api}/latestversion?name=@toruslabs/torus-embed&version=${version}`, {}, {\n        useAPIKey: true\n      });else response = {\n        data: configuration.prodTorusUrl\n      };\n      versionUsed = response.data;\n      // eslint-disable-next-line require-atomic-updates\n      configuration.prodTorusUrl = response.data;\n    }\n  } catch (error) {\n    log.error(error, \"unable to fetch latest version\");\n  }\n  log.info(\"version used: \", versionUsed);\n  switch (buildEnv) {\n    case \"binance\":\n      torusUrl = `https://binance.tor.us/v${versionUsed}`;\n      logLevel = \"info\";\n      break;\n    case \"testing\":\n      torusUrl = \"https://testing.tor.us\";\n      logLevel = \"debug\";\n      break;\n    case \"bnb\":\n      torusUrl = \"https://bnb.tor.us\";\n      logLevel = \"error\";\n      break;\n    case \"polygon\":\n      torusUrl = \"https://polygon.tor.us\";\n      logLevel = \"error\";\n      break;\n    case \"lrc\":\n      torusUrl = \"https://lrc.tor.us\";\n      logLevel = \"debug\";\n      break;\n    case \"beta\":\n      torusUrl = \"https://beta.tor.us\";\n      logLevel = \"debug\";\n      break;\n    case \"development\":\n      torusUrl = \"http://localhost:4050\";\n      logLevel = \"debug\";\n      break;\n    case \"alpha\":\n      torusUrl = \"https://alpha.tor.us\";\n      logLevel = \"debug\";\n      break;\n    default:\n      torusUrl = `https://app.tor.us/v${versionUsed}`;\n      logLevel = \"error\";\n      break;\n  }\n  return {\n    torusUrl,\n    logLevel\n  };\n};\nconst getUserLanguage = () => {\n  let userLanguage = window.navigator.language || \"en-US\";\n  const userLanguages = userLanguage.split(\"-\");\n  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n  return userLanguage;\n};\nconst EMITTED_NOTIFICATIONS = [\"eth_subscription\" // per eth-json-rpc-filters/subscriptionManager\n];\nconst NOOP = () => {\n  // empty function\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=660,width=375\";\nconst FEATURES_DEFAULT_WALLET_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=740,width=1315\";\nconst FEATURES_CONFIRM_WINDOW = \"directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=700,width=450\";\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n  return features;\n}\n\nSafeEventEmitter.defaultMaxListeners = 100;\n\n// resolve response.result, reject errors\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      return reject(error || response.error);\n    }\n    return !unwrapResult || Array.isArray(response) ? resolve(response) : resolve(response.result);\n  };\n};\nclass TorusInpageProvider extends SafeEventEmitter {\n  constructor(connectionStream) {\n    let {\n      maxEventListeners = 100,\n      shouldSendMetadata = true,\n      jsonRpcStreamName = \"provider\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /**\n     * The chain ID of the currently connected Ethereum chain.\n     * See [chainId.network]{@link https://chainid.network} for more information.\n     */\n    _defineProperty(this, \"chainId\", void 0);\n    /**\n     * The user's currently selected Ethereum address.\n     * If null, MetaMask is either locked or the user has not permitted any\n     * addresses to be viewed.\n     */\n    _defineProperty(this, \"selectedAddress\", void 0);\n    _defineProperty(this, \"_rpcEngine\", void 0);\n    _defineProperty(this, \"networkVersion\", void 0);\n    _defineProperty(this, \"shouldSendMetadata\", void 0);\n    /**\n     * Indicating that this provider is a MetaMask provider.\n     */\n    _defineProperty(this, \"isTorus\", void 0);\n    _defineProperty(this, \"tryPreopenHandle\", void 0);\n    _defineProperty(this, \"enable\", void 0);\n    _defineProperty(this, \"_state\", void 0);\n    _defineProperty(this, \"_jsonRpcConnection\", void 0);\n    if (!isDuplexStream(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n    this.isTorus = true;\n    this.setMaxListeners(maxEventListeners);\n\n    // private state\n    this._state = _objectSpread({}, TorusInpageProvider._defaultState);\n\n    // public state\n    this.selectedAddress = null;\n    this.networkVersion = null;\n    this.chainId = null;\n    this.shouldSendMetadata = shouldSendMetadata;\n\n    // bind functions (to prevent e.g. web3@1.x from making unbound calls)\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n    this._sendSync = this._sendSync.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this.request = this.request.bind(this);\n    this.send = this.send.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    // this.enable = this.enable.bind(this);\n\n    // setup connectionStream multiplexing\n    const mux = new ObjectMultiplex();\n    pump(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"MetaMask\"));\n\n    // ignore phishing warning message (handled elsewhere)\n    mux.ignoreStream(\"phishing\");\n\n    // setup own event listeners\n\n    // EIP-1193 connect\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    });\n\n    // connect to async provider\n\n    const jsonRpcConnection = createStreamMiddleware();\n    pump(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"MetaMask RpcProvider\"));\n\n    // handle RPC requests via dapp-side rpc engine\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(createErrorMiddleware());\n    rpcEngine.push(jsonRpcConnection.middleware);\n    this._rpcEngine = rpcEngine;\n\n    // json rpc notification listener\n    jsonRpcConnection.events.on(\"notification\", payload => {\n      const {\n        method,\n        params\n      } = payload;\n      if (method === \"wallet_accountsChanged\") {\n        this._handleAccountsChanged(params);\n      } else if (method === \"wallet_unlockStateChanged\") {\n        this._handleUnlockStateChanged(params);\n      } else if (method === \"wallet_chainChanged\") {\n        this._handleChainChanged(params);\n      } else if (EMITTED_NOTIFICATIONS.includes(payload.method)) {\n        // EIP 1193 subscriptions, per eth-json-rpc-filters/subscriptionManager\n        this.emit(\"data\", payload); // deprecated\n        this.emit(\"notification\", params.result);\n        this.emit(\"message\", {\n          type: method,\n          data: params\n        });\n      }\n\n      // Backward compatibility for older non EIP 1193 subscriptions\n      // this.emit('data', null, payload)\n    });\n  }\n\n  /**\n   * Returns whether the inpage provider is connected to Torus.\n   */\n  isConnected() {\n    return this._state.isConnected;\n  }\n\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   *\n   * @param args - The RPC request arguments.\n   * @returns A Promise that resolves with the result of the RPC method,\n   * or rejects if an error is encountered.\n   */\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    const {\n      method,\n      params\n    } = args;\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: _objectSpread(_objectSpread({}, args || {}), {}, {\n          cause: messages.errors.invalidRequestArgs()\n        })\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @param payload - The RPC request object.\n   * @param cb - The callback function.\n   */\n  sendAsync(payload, callback) {\n    this._rpcRequest(payload, callback);\n  }\n\n  // Private Methods\n  //= ===================\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n  async _initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked,\n        networkVersion\n      } = await this.request({\n        method: \"wallet_getProviderState\"\n      });\n\n      // indicate that we've connected, for EIP-1193 compliance\n      this.emit(\"connect\", {\n        chainId\n      });\n      this._handleChainChanged({\n        chainId,\n        networkVersion\n      });\n      this._handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n      this._handleAccountsChanged(accounts);\n    } catch (error) {\n      log.error(\"MetaMask: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound.\n   *\n   * @param payload - The RPC request object.\n   * @param callback - The consumer's callback.\n   * @param isInternal - false - Whether the request is internal.\n   */\n  _rpcRequest(payload, callback) {\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let cb = callback;\n    const _payload = payload;\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n      if (_payload.method === \"eth_accounts\" || _payload.method === \"eth_requestAccounts\") {\n        // handle accounts changing\n        cb = (err, res) => {\n          this._handleAccountsChanged(res.result || [], _payload.method === \"eth_accounts\", isInternal);\n          callback(err, res);\n        };\n      } else if (_payload.method === \"wallet_getProviderState\") {\n        this._rpcEngine.handle(payload, cb);\n        return;\n      }\n    }\n    this.tryPreopenHandle(_payload, cb);\n  }\n\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   *\n   * @deprecated Use \"request\" instead.\n   * @param method - The method to request.\n   * @param params - Any params for the method.\n   * @returns A Promise that resolves with the JSON-RPC response object for the\n   * request.\n   */\n\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @deprecated Use \"request\" instead.\n   * @param payload - A JSON-RPC request object.\n   * @param callback - An error-first callback that will receive the JSON-RPC\n   * response object.\n   */\n\n  /**\n   * Accepts a JSON-RPC request object, and synchronously returns the cached result\n   * for the given method. Only supports 4 specific RPC methods.\n   *\n   * @deprecated Use \"request\" instead.\n   * @param payload - A JSON-RPC request object.\n   * @returns A JSON-RPC response object.\n   */\n\n  send(methodOrPayload, callbackOrArgs) {\n    if (typeof methodOrPayload === \"string\" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n      return new Promise((resolve, reject) => {\n        try {\n          this._rpcRequest({\n            method: methodOrPayload,\n            params: callbackOrArgs\n          }, getRpcPromiseCallback(resolve, reject, false));\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n    if (methodOrPayload && typeof methodOrPayload === \"object\" && typeof callbackOrArgs === \"function\") {\n      return this._rpcRequest(methodOrPayload, callbackOrArgs);\n    }\n    return this._sendSync(methodOrPayload);\n  }\n\n  /**\n   * DEPRECATED.\n   * Internal backwards compatibility method, used in send.\n   */\n  _sendSync(payload) {\n    let result;\n    switch (payload.method) {\n      case \"eth_accounts\":\n        result = this.selectedAddress ? [this.selectedAddress] : [];\n        break;\n      case \"eth_coinbase\":\n        result = this.selectedAddress || null;\n        break;\n      case \"eth_uninstallFilter\":\n        this._rpcRequest(payload, NOOP);\n        result = true;\n        break;\n      case \"net_version\":\n        result = this.networkVersion || null;\n        break;\n      default:\n        throw new Error(messages.errors.unsupportedSync(payload.method));\n    }\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result\n    };\n  }\n\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits MetaMaskInpageProvider#connect\n   */\n  _handleConnect(chainId) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        chainId\n      });\n      log.debug(messages.info.connected(chainId));\n    }\n  }\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits MetaMaskInpageProvider#disconnect\n   */\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n      if (isRecoverable) {\n        error = new EthereumProviderError(1013,\n        // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumProviderError(1011,\n        // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.chainId = null;\n        this._state.accounts = null;\n        this.selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n      this.emit(\"disconnect\", error);\n    }\n  }\n\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits MetamaskInpageProvider#disconnect\n   */\n  _handleStreamDisconnect(streamName, error) {\n    logStreamDisconnectWarning(streamName, error, this);\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n\n  /**\n   * Called when accounts may have changed.\n   */\n  _handleAccountsChanged(accounts) {\n    let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // defensive programming\n    let finalAccounts = accounts;\n    if (!Array.isArray(finalAccounts)) {\n      log.error(\"MetaMask: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n      finalAccounts = [];\n    }\n    for (const account of accounts) {\n      if (typeof account !== \"string\") {\n        log.error(\"MetaMask: Received non-string account. Please report this bug.\", accounts);\n        finalAccounts = [];\n        break;\n      }\n    }\n\n    // emit accountsChanged if anything about the accounts array has changed\n    if (!dequal(this._state.accounts, finalAccounts)) {\n      // we should always have the correct accounts even before eth_accounts\n      // returns, except in cases where isInternal is true\n      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n        log.error('MetaMask: \"eth_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n      }\n      this._state.accounts = finalAccounts;\n      this.emit(\"accountsChanged\", finalAccounts);\n    }\n\n    // handle selectedAddress\n    if (this.selectedAddress !== finalAccounts[0]) {\n      this.selectedAddress = finalAccounts[0] || null;\n    }\n  }\n\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits MetamaskInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */\n  _handleChainChanged() {\n    let {\n      chainId,\n      networkVersion\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!chainId || !networkVersion) {\n      log.error(\"MetaMask: Received invalid network parameters. Please report this bug.\", {\n        chainId,\n        networkVersion\n      });\n      return;\n    }\n    if (networkVersion === \"loading\") {\n      this._handleDisconnect(true);\n    } else {\n      this._handleConnect(chainId);\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n        if (this._state.initialized) {\n          this.emit(\"chainChanged\", this.chainId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */\n  _handleUnlockStateChanged() {\n    let {\n      accounts,\n      isUnlocked\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof isUnlocked !== \"boolean\") {\n      log.error(\"MetaMask: Received invalid isUnlocked parameter. Please report this bug.\", {\n        isUnlocked\n      });\n      return;\n    }\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n      this._handleAccountsChanged(accounts || []);\n    }\n  }\n}\n_defineProperty(TorusInpageProvider, \"_defaultState\", {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false,\n  hasEmittedConnection: false\n});\n\nclass PopupHandler extends SafeEventEmitter {\n  constructor(_ref) {\n    let {\n      url,\n      target,\n      features,\n      timeout = 30000\n    } = _ref;\n    super();\n    _defineProperty(this, \"url\", void 0);\n    _defineProperty(this, \"target\", void 0);\n    _defineProperty(this, \"features\", void 0);\n    _defineProperty(this, \"window\", void 0);\n    _defineProperty(this, \"windowTimer\", void 0);\n    _defineProperty(this, \"iClosedWindow\", void 0);\n    _defineProperty(this, \"timeout\", void 0);\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures();\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n    this.timeout = timeout;\n    this._setupTimer();\n  }\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n        setTimeout(() => {\n          if (!this.iClosedWindow) {\n            this.emit(\"close\");\n          }\n          this.iClosedWindow = false;\n          this.window = undefined;\n        }, this.timeout);\n      }\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n  open() {\n    var _this$window;\n    this.window = window.open(this.url.href, this.target, this.features);\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n  }\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url.href);\n    } else {\n      window.location.href = this.url.href;\n    }\n  }\n}\n\n/**\n * Returns whether the given image URL exists\n * @param url - the url of the image\n * @returns - whether the image exists\n */\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n/**\n * Extracts a name for the site from the DOM\n */\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n  if (siteName) {\n    return siteName.content;\n  }\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n  return window.location.hostname;\n};\n\n/**\n * Extracts an icon for the site from the DOM\n */\nasync function getSiteIcon(window) {\n  const {\n    document\n  } = window;\n\n  // Use the site's favicon if it exists\n  let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n\n  // Search through available icons in no particular order\n  icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\n  if (icon && (await imgExists(icon.href))) {\n    return icon.href;\n  }\n  return null;\n}\n\n/**\n * Gets site metadata and returns it\n *\n */\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\n\n/**\n * Sends site metadata over an RPC request.\n */\nasync function sendSiteMetadata(engine) {\n  try {\n    const domainMetadata = await getSiteMetadata();\n    // call engine.handle directly to avoid normal RPC request handling\n    engine.handle({\n      jsonrpc: \"2.0\",\n      id: getPreopenInstanceId(),\n      method: \"wallet_sendDomainMetadata\",\n      params: domainMetadata\n    }, NOOP);\n  } catch (error) {\n    log.error({\n      message: messages.errors.sendSiteMetadata(),\n      originalError: error\n    });\n  }\n}\n\nconst _excluded = [\"host\", \"chainId\", \"networkName\"];\nconst UNSAFE_METHODS = [\"eth_sendTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"personal_sign\", \"eth_getEncryptionPublicKey\", \"eth_decrypt\", \"wallet_addEthereumChain\", \"wallet_switchEthereumChain\"];\n\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n  try {\n    if (typeof document === \"undefined\") return;\n    const torusIframeHtml = document.createElement(\"link\");\n    const {\n      torusUrl\n    } = await getTorusUrl(\"production\", {\n      version: \"\"\n    });\n    torusIframeHtml.href = `${torusUrl}/popup`;\n    torusIframeHtml.crossOrigin = \"anonymous\";\n    torusIframeHtml.type = \"text/html\";\n    torusIframeHtml.rel = \"prefetch\";\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(torusIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.warn(error);\n  }\n})();\nclass Torus {\n  constructor() {\n    let {\n      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,\n      buttonSize = 56,\n      modalZIndex = 99999,\n      apiKey = \"torus-default\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"buttonPosition\", BUTTON_POSITION.BOTTOM_LEFT);\n    _defineProperty(this, \"buttonSize\", void 0);\n    _defineProperty(this, \"torusUrl\", void 0);\n    _defineProperty(this, \"torusIframe\", void 0);\n    _defineProperty(this, \"styleLink\", void 0);\n    _defineProperty(this, \"isLoggedIn\", void 0);\n    _defineProperty(this, \"isInitialized\", void 0);\n    _defineProperty(this, \"torusWidgetVisibility\", void 0);\n    _defineProperty(this, \"torusAlert\", void 0);\n    _defineProperty(this, \"apiKey\", void 0);\n    _defineProperty(this, \"modalZIndex\", void 0);\n    _defineProperty(this, \"alertZIndex\", void 0);\n    _defineProperty(this, \"torusAlertContainer\", void 0);\n    _defineProperty(this, \"isIframeFullScreen\", void 0);\n    _defineProperty(this, \"whiteLabel\", void 0);\n    _defineProperty(this, \"requestedVerifier\", void 0);\n    _defineProperty(this, \"currentVerifier\", void 0);\n    _defineProperty(this, \"embedTranslations\", void 0);\n    _defineProperty(this, \"ethereum\", void 0);\n    _defineProperty(this, \"provider\", void 0);\n    _defineProperty(this, \"communicationMux\", void 0);\n    _defineProperty(this, \"isLoginCallback\", void 0);\n    _defineProperty(this, \"paymentProviders\", configuration.paymentProviders);\n    _defineProperty(this, \"loginHint\", \"\");\n    _defineProperty(this, \"useWalletConnect\", void 0);\n    _defineProperty(this, \"isCustomLogin\", false);\n    this.buttonPosition = buttonPosition;\n    this.buttonSize = buttonSize;\n    this.torusUrl = \"\";\n    this.isLoggedIn = false; // ethereum.enable working\n    this.isInitialized = false; // init done\n    this.torusWidgetVisibility = true;\n    this.requestedVerifier = \"\";\n    this.currentVerifier = \"\";\n    this.apiKey = apiKey;\n    setAPIKey(apiKey);\n    this.modalZIndex = modalZIndex;\n    this.alertZIndex = modalZIndex + 1000;\n    this.isIframeFullScreen = false;\n  }\n  async init() {\n    let {\n      buildEnv = TORUS_BUILD_ENV.PRODUCTION,\n      enableLogging = false,\n      network = {\n        host: \"mainnet\",\n        chainId: null,\n        networkName: \"\",\n        blockExplorer: \"\",\n        ticker: \"\",\n        tickerName: \"\"\n      },\n      loginConfig = {},\n      showTorusButton = true,\n      integrity = {\n        version: \"\"\n      },\n      whiteLabel,\n      useWalletConnect = false,\n      mfaLevel = \"default\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.isInitialized) throw new Error(\"Already initialized\");\n    const {\n      torusUrl,\n      logLevel\n    } = await getTorusUrl(buildEnv, integrity);\n    log.info(torusUrl, \"url loaded\");\n    this.torusUrl = torusUrl;\n    this.whiteLabel = whiteLabel;\n    this.useWalletConnect = useWalletConnect;\n    this.isCustomLogin = !!(loginConfig && Object.keys(loginConfig).length > 0) || !!(whiteLabel && Object.keys(whiteLabel).length > 0);\n    log.setDefaultLevel(logLevel);\n    if (enableLogging) log.enableAll();else log.disableAll();\n    this.torusWidgetVisibility = showTorusButton;\n    const torusIframeUrl = new URL(torusUrl);\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"popup\";else torusIframeUrl.pathname += \"/popup\";\n    torusIframeUrl.hash = `#isCustomLogin=${this.isCustomLogin}`;\n\n    // Iframe code\n    this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        allow=${useWalletConnect ? \"camera\" : \"\"}\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%; color-scheme: none;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex}\"\n      ></iframe>`);\n    this.torusAlertContainer = htmlToElement('<div id=\"torusAlertContainer\"></div>');\n    this.torusAlertContainer.style.display = \"none\";\n    this.torusAlertContainer.style.setProperty(\"z-index\", this.alertZIndex.toString());\n    const link = window.document.createElement(\"link\");\n    link.setAttribute(\"rel\", \"stylesheet\");\n    link.setAttribute(\"type\", \"text/css\");\n    link.setAttribute(\"href\", `${torusUrl}/css/widget.css`);\n    this.styleLink = link;\n    const {\n      defaultLanguage = getUserLanguage(),\n      customTranslations = {}\n    } = this.whiteLabel || {};\n    const mergedTranslations = deepmerge(configuration.translations, customTranslations);\n    const languageTranslations = mergedTranslations[defaultLanguage] || configuration.translations[getUserLanguage()];\n    this.embedTranslations = languageTranslations.embed;\n    return new Promise((resolve, reject) => {\n      this.torusIframe.onload = async () => {\n        // only do this if iframe is not full screen\n        this._setupWeb3();\n        const initStream = this.communicationMux.getStream(\"init_stream\");\n        initStream.on(\"data\", chunk => {\n          const {\n            name,\n            data,\n            error\n          } = chunk;\n          if (name === \"init_complete\" && data.success) {\n            // resolve promise\n            this.isInitialized = true;\n            this._displayIframe(this.isIframeFullScreen);\n            resolve(undefined);\n          } else if (error) {\n            reject(new Error(error));\n          }\n        });\n        initStream.write({\n          name: \"init_stream\",\n          data: {\n            loginConfig,\n            whiteLabel: this.whiteLabel,\n            buttonPosition: this.buttonPosition,\n            buttonSize: this.buttonSize,\n            torusWidgetVisibility: this.torusWidgetVisibility,\n            apiKey: this.apiKey,\n            network,\n            mfaLevel\n          }\n        });\n      };\n      window.document.head.appendChild(this.styleLink);\n      window.document.body.appendChild(this.torusIframe);\n      window.document.body.appendChild(this.torusAlertContainer);\n    });\n  }\n  login() {\n    let {\n      verifier = \"\",\n      login_hint: loginHint = \"\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    this.requestedVerifier = verifier;\n    this.loginHint = loginHint;\n    return this.ethereum.enable();\n  }\n  logout() {\n    return new Promise((resolve, reject) => {\n      if (!this.isLoggedIn) {\n        reject(new Error(\"User has not logged in yet\"));\n        return;\n      }\n      const logOutStream = this.communicationMux.getStream(\"logout\");\n      logOutStream.write({\n        name: \"logOut\"\n      });\n      const statusStream = this.communicationMux.getStream(\"status\");\n      const statusStreamHandler = arg => {\n        const status = arg;\n        if (!status.loggedIn) {\n          this.isLoggedIn = false;\n          this.currentVerifier = \"\";\n          this.requestedVerifier = \"\";\n          resolve();\n        } else reject(new Error(\"Some Error Occured\"));\n      };\n      handleStream(statusStream, \"data\", statusStreamHandler);\n    });\n  }\n  async cleanUp() {\n    if (this.isLoggedIn) {\n      await this.logout();\n    }\n    this.clearInit();\n  }\n  clearInit() {\n    function isElement(element) {\n      return element instanceof Element || element instanceof HTMLDocument;\n    }\n    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n      this.styleLink.remove();\n      this.styleLink = undefined;\n    }\n    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n      this.torusIframe.remove();\n      this.torusIframe = undefined;\n    }\n    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n      this.torusAlert = undefined;\n      this.torusAlertContainer.remove();\n      this.torusAlertContainer = undefined;\n    }\n    this.isInitialized = false;\n  }\n  hideTorusButton() {\n    this.torusWidgetVisibility = false;\n    this._sendWidgetVisibilityStatus(false);\n    this._displayIframe();\n  }\n  showTorusButton() {\n    this.torusWidgetVisibility = true;\n    this._sendWidgetVisibilityStatus(true);\n    this._displayIframe();\n  }\n  setProvider(_ref) {\n    let {\n        host = \"mainnet\",\n        chainId = null,\n        networkName = \"\"\n      } = _ref,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    return new Promise((resolve, reject) => {\n      const providerChangeStream = this.communicationMux.getStream(\"provider_change\");\n      const handler = arg => {\n        const chunk = arg;\n        const {\n          err,\n          success\n        } = chunk.data;\n        log.info(chunk);\n        if (err) {\n          reject(err);\n        } else if (success) {\n          resolve();\n        } else reject(new Error(\"some error occurred\"));\n      };\n      handleStream(providerChangeStream, \"data\", handler);\n      const preopenInstanceId = getPreopenInstanceId();\n      this._handleWindow(preopenInstanceId, {\n        target: \"_blank\",\n        features: FEATURES_PROVIDER_CHANGE_WINDOW\n      });\n      providerChangeStream.write({\n        name: \"show_provider_change\",\n        data: {\n          network: _objectSpread({\n            host,\n            chainId,\n            networkName\n          }, rest),\n          preopenInstanceId,\n          override: false\n        }\n      });\n    });\n  }\n  showWallet(path) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const showWalletStream = this.communicationMux.getStream(\"show_wallet\");\n    const finalPath = path ? `/${path}` : \"\";\n    showWalletStream.write({\n      name: \"show_wallet\",\n      data: {\n        path: finalPath\n      }\n    });\n    const showWalletHandler = arg => {\n      const chunk = arg;\n      if (chunk.name === \"show_wallet_instance\") {\n        // Let the error propogate up (hence, no try catch)\n        const {\n          instanceId\n        } = chunk.data;\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);\n        // Using URL constructor to prevent js injection and allow parameter validation.!\n        finalUrl.searchParams.append(\"integrity\", \"true\");\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach(x => {\n          finalUrl.searchParams.append(x, params[x]);\n        });\n        finalUrl.hash = `#isCustomLogin=${this.isCustomLogin}`;\n        const walletWindow = new PopupHandler({\n          url: finalUrl,\n          features: FEATURES_DEFAULT_WALLET_WINDOW\n        });\n        walletWindow.open();\n      }\n    };\n    handleStream(showWalletStream, \"data\", showWalletHandler);\n  }\n  async getPublicAddress(_ref2) {\n    let {\n      verifier,\n      verifierId,\n      isExtended = false\n    } = _ref2;\n    if (!configuration.supportedVerifierList.includes(verifier) || !WALLET_OPENLOGIN_VERIFIER_MAP[verifier]) throw new Error(\"Unsupported verifier\");\n    const walletVerifier = verifier;\n    const openloginVerifier = WALLET_OPENLOGIN_VERIFIER_MAP[verifier];\n    const url = new URL(`https://api.tor.us/lookup/torus`);\n    url.searchParams.append(\"verifier\", openloginVerifier);\n    url.searchParams.append(\"verifierId\", verifierId);\n    url.searchParams.append(\"walletVerifier\", walletVerifier);\n    url.searchParams.append(\"network\", \"mainnet\");\n    url.searchParams.append(\"isExtended\", isExtended.toString());\n    return get(url.href, {\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    }, {\n      useAPIKey: true\n    });\n  }\n  getUserInfo(message) {\n    return new Promise((resolve, reject) => {\n      if (this.isLoggedIn) {\n        const userInfoAccessStream = this.communicationMux.getStream(\"user_info_access\");\n        userInfoAccessStream.write({\n          name: \"user_info_access_request\"\n        });\n        const userInfoAccessHandler = arg => {\n          const chunk = arg;\n          const {\n            name,\n            data: {\n              approved,\n              payload,\n              rejected,\n              newRequest\n            }\n          } = chunk;\n          if (name === \"user_info_access_response\") {\n            if (approved) {\n              resolve(payload);\n            } else if (rejected) {\n              reject(new Error(\"User rejected the request\"));\n            } else if (newRequest) {\n              const userInfoStream = this.communicationMux.getStream(\"user_info\");\n              const userInfoHandler = arg2 => {\n                const handlerChunk = arg2;\n                if (handlerChunk.name === \"user_info_response\") {\n                  if (handlerChunk.data.approved) {\n                    resolve(handlerChunk.data.payload);\n                  } else {\n                    reject(new Error(\"User rejected the request\"));\n                  }\n                }\n              };\n              handleStream(userInfoStream, \"data\", userInfoHandler);\n              const preopenInstanceId = getPreopenInstanceId();\n              this._handleWindow(preopenInstanceId, {\n                target: \"_blank\",\n                features: FEATURES_PROVIDER_CHANGE_WINDOW\n              });\n              userInfoStream.write({\n                name: \"user_info_request\",\n                data: {\n                  message,\n                  preopenInstanceId\n                }\n              });\n            }\n          }\n        };\n        handleStream(userInfoAccessStream, \"data\", userInfoAccessHandler);\n      } else reject(new Error(\"User has not logged in yet\"));\n    });\n  }\n  initiateTopup(provider, params) {\n    return new Promise((resolve, reject) => {\n      if (this.isInitialized) {\n        const {\n          errors,\n          isValid\n        } = validatePaymentProvider(provider, params);\n        if (!isValid) {\n          reject(new Error(JSON.stringify(errors)));\n          return;\n        }\n        const topupStream = this.communicationMux.getStream(\"topup\");\n        const topupHandler = arg => {\n          const chunk = arg;\n          if (chunk.name === \"topup_response\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n          }\n        };\n        handleStream(topupStream, \"data\", topupHandler);\n        const preopenInstanceId = getPreopenInstanceId();\n        this._handleWindow(preopenInstanceId);\n        topupStream.write({\n          name: \"topup_request\",\n          data: {\n            provider,\n            params,\n            preopenInstanceId\n          }\n        });\n      } else reject(new Error(\"Torus is not initialized yet\"));\n    });\n  }\n  async loginWithPrivateKey(loginParams) {\n    const {\n      privateKey,\n      userInfo\n    } = loginParams;\n    return new Promise((resolve, reject) => {\n      if (this.isInitialized) {\n        if (Buffer.from(privateKey, \"hex\").length !== 32) {\n          reject(new Error(\"Invalid private key, Please provide a 32 byte valid secp25k1 private key\"));\n          return;\n        }\n        const loginPrivKeyStream = this.communicationMux.getStream(\"login_with_private_key\");\n        const loginHandler = arg => {\n          const chunk = arg;\n          if (chunk.name === \"login_with_private_key_response\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n          }\n        };\n        handleStream(loginPrivKeyStream, \"data\", loginHandler);\n        loginPrivKeyStream.write({\n          name: \"login_with_private_key_request\",\n          data: {\n            privateKey,\n            userInfo\n          }\n        });\n      } else reject(new Error(\"Torus is not initialized yet\"));\n    });\n  }\n  async showWalletConnectScanner() {\n    if (!this.useWalletConnect) throw new Error(\"Set `useWalletConnect` as true in init function options to use wallet connect scanner\");\n    return new Promise((resolve, reject) => {\n      if (this.isLoggedIn) {\n        const walletConnectStream = this.communicationMux.getStream(\"wallet_connect_stream\");\n        const walletConnectHandler = arg => {\n          const chunk = arg;\n          if (chunk.name === \"wallet_connect_stream_res\") {\n            if (chunk.data.success) {\n              resolve(chunk.data.success);\n            } else {\n              reject(new Error(chunk.data.error));\n            }\n            this._displayIframe();\n          }\n        };\n        handleStream(walletConnectStream, \"data\", walletConnectHandler);\n        walletConnectStream.write({\n          name: \"wallet_connect_stream_req\"\n        });\n        this._displayIframe(true);\n      } else reject(new Error(\"User has not logged in yet\"));\n    });\n  }\n  _handleWindow(preopenInstanceId) {\n    let {\n      url,\n      target,\n      features\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (preopenInstanceId) {\n      const windowStream = this.communicationMux.getStream(\"window\");\n      const finalUrl = new URL(url || `${this.torusUrl}/redirect?preopenInstanceId=${preopenInstanceId}`);\n      if (finalUrl.hash) finalUrl.hash += `&isCustomLogin=${this.isCustomLogin}`;else finalUrl.hash = `#isCustomLogin=${this.isCustomLogin}`;\n      const handledWindow = new PopupHandler({\n        url: finalUrl,\n        target,\n        features\n      });\n      handledWindow.open();\n      if (!handledWindow.window) {\n        this._createPopupBlockAlert(preopenInstanceId, finalUrl.href);\n        return;\n      }\n      windowStream.write({\n        name: \"opened_window\",\n        data: {\n          preopenInstanceId\n        }\n      });\n      const closeHandler = _ref3 => {\n        let {\n          preopenInstanceId: receivedId,\n          close\n        } = _ref3;\n        if (receivedId === preopenInstanceId && close) {\n          handledWindow.close();\n          windowStream.removeListener(\"data\", closeHandler);\n        }\n      };\n      windowStream.on(\"data\", closeHandler);\n      handledWindow.once(\"close\", () => {\n        windowStream.write({\n          data: {\n            preopenInstanceId,\n            closed: true\n          }\n        });\n        windowStream.removeListener(\"data\", closeHandler);\n      });\n    }\n  }\n  _setEmbedWhiteLabel(element) {\n    // Set whitelabel\n    const {\n      theme\n    } = this.whiteLabel || {};\n    if (theme) {\n      const {\n        isDark = false,\n        colors = {}\n      } = theme;\n      if (isDark) element.classList.add(\"torus-dark\");\n      if (colors.torusBrand1) element.style.setProperty(\"--torus-brand-1\", colors.torusBrand1);\n      if (colors.torusGray2) element.style.setProperty(\"--torus-gray-2\", colors.torusGray2);\n    }\n  }\n  _getLogoUrl() {\n    var _this$whiteLabel;\n    let logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n    if ((_this$whiteLabel = this.whiteLabel) !== null && _this$whiteLabel !== void 0 && (_this$whiteLabel = _this$whiteLabel.theme) !== null && _this$whiteLabel !== void 0 && _this$whiteLabel.isDark) {\n      var _this$whiteLabel2;\n      logoUrl = ((_this$whiteLabel2 = this.whiteLabel) === null || _this$whiteLabel2 === void 0 ? void 0 : _this$whiteLabel2.logoLight) || logoUrl;\n    } else {\n      var _this$whiteLabel3;\n      logoUrl = ((_this$whiteLabel3 = this.whiteLabel) === null || _this$whiteLabel3 === void 0 ? void 0 : _this$whiteLabel3.logoDark) || logoUrl;\n    }\n    return logoUrl;\n  }\n  _sendWidgetVisibilityStatus(status) {\n    const torusWidgetVisibilityStream = this.communicationMux.getStream(\"torus-widget-visibility\");\n    torusWidgetVisibilityStream.write({\n      data: status\n    });\n  }\n  _displayIframe() {\n    let isFull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const style = {};\n    const size = this.buttonSize + 14; // 15px padding\n    // set phase\n    if (!isFull) {\n      style.display = this.torusWidgetVisibility ? \"block\" : \"none\";\n      style.height = `${size}px`;\n      style.width = `${size}px`;\n      switch (this.buttonPosition) {\n        case BUTTON_POSITION.TOP_LEFT:\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.right = \"auto\";\n          style.bottom = \"auto\";\n          break;\n        case BUTTON_POSITION.TOP_RIGHT:\n          style.top = \"0px\";\n          style.right = \"0px\";\n          style.left = \"auto\";\n          style.bottom = \"auto\";\n          break;\n        case BUTTON_POSITION.BOTTOM_RIGHT:\n          style.bottom = \"0px\";\n          style.right = \"0px\";\n          style.top = \"auto\";\n          style.left = \"auto\";\n          break;\n        case BUTTON_POSITION.BOTTOM_LEFT:\n        default:\n          style.bottom = \"0px\";\n          style.left = \"0px\";\n          style.top = \"auto\";\n          style.right = \"auto\";\n          break;\n      }\n    } else {\n      style.display = \"block\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n    }\n    Object.assign(this.torusIframe.style, style);\n    this.isIframeFullScreen = isFull;\n  }\n  _setupWeb3() {\n    log.info(\"setupWeb3 running\");\n    // setup background connection\n    const metamaskStream = new BasePostMessageStream({\n      name: \"embed_metamask\",\n      target: \"iframe_metamask\",\n      targetWindow: this.torusIframe.contentWindow,\n      targetOrigin: new URL(this.torusUrl).origin\n    });\n\n    // Due to compatibility reasons, we should not set up multiplexing on window.metamaskstream\n    // because the MetamaskInpageProvider also attempts to do so.\n    // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n    const communicationStream = new BasePostMessageStream({\n      name: \"embed_comm\",\n      target: \"iframe_comm\",\n      targetWindow: this.torusIframe.contentWindow,\n      targetOrigin: new URL(this.torusUrl).origin\n    });\n\n    // Backward compatibility with Gotchi :)\n    // window.metamaskStream = this.communicationStream\n\n    // compose the inpage provider\n    const inpageProvider = new TorusInpageProvider(metamaskStream);\n\n    // detect eth_requestAccounts and pipe to enable for now\n    const detectAccountRequestPrototypeModifier = m => {\n      // @ts-ignore\n      const originalMethod = inpageProvider[m];\n      // @ts-ignore\n      inpageProvider[m] = function providerFunc(method) {\n        if (method && method === \"eth_requestAccounts\") {\n          return inpageProvider.enable();\n        }\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return originalMethod.apply(this, [method, ...args]);\n      };\n    };\n    detectAccountRequestPrototypeModifier(\"send\");\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\n    inpageProvider.enable = () => {\n      return new Promise((resolve, reject) => {\n        // If user is already logged in, we assume they have given access to the website\n        inpageProvider.sendAsync({\n          jsonrpc: \"2.0\",\n          id: getPreopenInstanceId(),\n          method: \"eth_requestAccounts\",\n          params: []\n        }, (err, response) => {\n          const {\n            result: res\n          } = response || {};\n          if (err) {\n            setTimeout(() => {\n              reject(err);\n            }, 50);\n          } else if (Array.isArray(res) && res.length > 0) {\n            // If user is already rehydrated, resolve this\n            // else wait for something to be written to status stream\n            const handleLoginCb = () => {\n              if (this.requestedVerifier !== \"\" && this.currentVerifier !== this.requestedVerifier) {\n                const {\n                  requestedVerifier\n                } = this;\n                // eslint-disable-next-line promise/no-promise-in-callback\n                this.logout()\n                // eslint-disable-next-line promise/always-return\n                .then(_ => {\n                  this.requestedVerifier = requestedVerifier;\n                  this._showLoginPopup(true, resolve, reject);\n                }).catch(error => reject(error));\n              } else {\n                resolve(res);\n              }\n            };\n            if (this.isLoggedIn) {\n              handleLoginCb();\n            } else {\n              this.isLoginCallback = handleLoginCb;\n            }\n          } else {\n            // set up listener for login\n            this._showLoginPopup(true, resolve, reject);\n          }\n        });\n      });\n    };\n    inpageProvider.tryPreopenHandle = (payload, cb) => {\n      const _payload = payload;\n      if (!Array.isArray(_payload) && UNSAFE_METHODS.includes(_payload.method)) {\n        const preopenInstanceId = getPreopenInstanceId();\n        this._handleWindow(preopenInstanceId, {\n          target: \"_blank\",\n          features: FEATURES_CONFIRM_WINDOW\n        });\n        _payload.preopenInstanceId = preopenInstanceId;\n      }\n      inpageProvider._rpcEngine.handle(_payload, cb);\n    };\n\n    // Work around for web3@1.0 deleting the bound `sendAsync` but not the unbound\n    // `sendAsync` method on the prototype, causing `this` reference issues with drizzle\n    const proxiedInpageProvider = new Proxy(inpageProvider, {\n      // straight up lie that we deleted the property so that it doesnt\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    this.ethereum = proxiedInpageProvider;\n    const communicationMux = setupMultiplex(communicationStream);\n    this.communicationMux = communicationMux;\n    const windowStream = communicationMux.getStream(\"window\");\n    windowStream.on(\"data\", chunk => {\n      if (chunk.name === \"create_window\") {\n        // url is the url we need to open\n        // we can pass the final url upfront so that it removes the step of redirecting to /redirect and waiting for finalUrl\n        this._createPopupBlockAlert(chunk.data.preopenInstanceId, chunk.data.url);\n      }\n    });\n\n    // show torus widget if button clicked\n    const widgetStream = communicationMux.getStream(\"widget\");\n    widgetStream.on(\"data\", chunk => {\n      const {\n        data\n      } = chunk;\n      this._displayIframe(data);\n    });\n\n    // Show torus button if wallet has been hydrated/detected\n    const statusStream = communicationMux.getStream(\"status\");\n    statusStream.on(\"data\", status => {\n      // login\n      if (status.loggedIn) {\n        this.isLoggedIn = status.loggedIn;\n        this.currentVerifier = status.verifier;\n      } // logout\n      else this._displayIframe();\n      if (this.isLoginCallback) {\n        this.isLoginCallback();\n        delete this.isLoginCallback;\n      }\n    });\n    this.provider = proxiedInpageProvider;\n    if (this.provider.shouldSendMetadata) sendSiteMetadata(this.provider._rpcEngine);\n    inpageProvider._initializeState();\n    log.debug(\"Torus - injected provider\");\n  }\n  _showLoginPopup(calledFromEmbed, resolve, reject) {\n    const loginHandler = arg => {\n      const data = arg;\n      const {\n        err,\n        selectedAddress\n      } = data;\n      if (err) {\n        log.error(err);\n        if (reject) reject(err);\n      }\n      // returns an array (cause accounts expects it)\n      else if (resolve) resolve([selectedAddress]);\n      if (this.isIframeFullScreen) this._displayIframe();\n    };\n    const oauthStream = this.communicationMux.getStream(\"oauth\");\n    if (!this.requestedVerifier) {\n      this._displayIframe(true);\n      handleStream(oauthStream, \"data\", loginHandler);\n      oauthStream.write({\n        name: \"oauth_modal\",\n        data: {\n          calledFromEmbed\n        }\n      });\n    } else {\n      handleStream(oauthStream, \"data\", loginHandler);\n      const preopenInstanceId = getPreopenInstanceId();\n      this._handleWindow(preopenInstanceId);\n      oauthStream.write({\n        name: \"oauth\",\n        data: {\n          calledFromEmbed,\n          verifier: this.requestedVerifier,\n          preopenInstanceId,\n          login_hint: this.loginHint\n        }\n      });\n    }\n  }\n  _createPopupBlockAlert(preopenInstanceId, url) {\n    const logoUrl = this._getLogoUrl();\n    const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n    const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n    const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n    btnContainer.appendChild(successAlert);\n    torusAlert.appendChild(btnContainer);\n    this._setEmbedWhiteLabel(torusAlert);\n    this.torusAlertContainer.style.display = \"block\";\n    this.torusAlertContainer.appendChild(torusAlert);\n    successAlert.addEventListener(\"click\", () => {\n      this._handleWindow(preopenInstanceId, {\n        url,\n        target: \"_blank\",\n        features: FEATURES_CONFIRM_WINDOW\n      });\n      torusAlert.remove();\n      if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n    });\n  }\n}\n\nexport { BUTTON_POSITION, PAYMENT_PROVIDER, SUPPORTED_PAYMENT_NETWORK, TORUS_BUILD_ENV, TorusInpageProvider, WALLET_OPENLOGIN_VERIFIER_MAP, WALLET_VERIFIERS, Torus as default };\n", "export const errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603,\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901,\n  },\n};\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const errorValues = {\n  '-32700': {\n    standard: 'JSON RPC 2.0',\n    message:\n      'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n  },\n  '-32600': {\n    standard: 'JSON RPC 2.0',\n    message: 'The JSON sent is not a valid Request object.',\n  },\n  '-32601': {\n    standard: 'JSON RPC 2.0',\n    message: 'The method does not exist / is not available.',\n  },\n  '-32602': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid method parameter(s).',\n  },\n  '-32603': {\n    standard: 'JSON RPC 2.0',\n    message: 'Internal JSON-RPC error.',\n  },\n  '-32000': {\n    standard: 'EIP-1474',\n    message: 'Invalid input.',\n  },\n  '-32001': {\n    standard: 'EIP-1474',\n    message: 'Resource not found.',\n  },\n  '-32002': {\n    standard: 'EIP-1474',\n    message: 'Resource unavailable.',\n  },\n  '-32003': {\n    standard: 'EIP-1474',\n    message: 'Transaction rejected.',\n  },\n  '-32004': {\n    standard: 'EIP-1474',\n    message: 'Method not supported.',\n  },\n  '-32005': {\n    standard: 'EIP-1474',\n    message: 'Request limit exceeded.',\n  },\n  '4001': {\n    standard: 'EIP-1193',\n    message: 'User rejected the request.',\n  },\n  '4100': {\n    standard: 'EIP-1193',\n    message:\n      'The requested account and/or method has not been authorized by the user.',\n  },\n  '4200': {\n    standard: 'EIP-1193',\n    message: 'The requested method is not supported by this Ethereum provider.',\n  },\n  '4900': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from all chains.',\n  },\n  '4901': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from the specified chain.',\n  },\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n", "/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any;\n  key: any;\n  type: string;\n  refinement: string | undefined;\n  message: string;\n  explanation?: string | undefined;\n  branch: any[];\n  path: any[];\n};\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any;\n\n  key!: any;\n\n  type!: string;\n\n  refinement!: string | undefined;\n\n  path!: any[];\n\n  branch!: any[];\n\n  failures: () => Failure[];\n\n  [x: string]: any;\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Failure[] | undefined;\n    const { message, explanation, ...rest } = failure;\n    const { path } = failure;\n    const cause =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n    super(explanation ?? cause);\n\n    if (explanation !== null && explanation !== undefined) {\n      this.cause = cause;\n    }\n\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()]);\n    };\n  }\n}\n", "import type { Failure } from './error.js';\nimport type { Struct, Infer, Result, Context, Describe } from './struct.js';\n\n/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable<Type>(value: unknown): value is Iterable<Type> {\n  return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isObject(\n  value: unknown,\n): value is Record<PropertyKey, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isPlainObject(value: unknown): value is { [key: string]: any } {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nexport function print(value: any): string {\n  if (typeof value === 'symbol') {\n    return value.toString();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nexport function shiftIterator<Type>(input: Iterator<Type>): Type | undefined {\n  const { done, value } = input.next();\n  return done ? undefined : value;\n}\n\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nexport function toFailure<Type, Schema>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<Type, Schema>,\n  value: any,\n): Failure | undefined {\n  if (result === true) {\n    return undefined;\n  } else if (result === false) {\n    // eslint-disable-next-line no-param-reassign\n    result = {};\n  } else if (typeof result === 'string') {\n    // eslint-disable-next-line no-param-reassign\n    result = { message: result };\n  }\n\n  const { path, branch } = context;\n  const { type } = struct;\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result;\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  };\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nexport function* toFailures<Type, Schema>(\n  result: Result,\n  context: Context,\n  struct: Struct<Type, Schema>,\n  value: any,\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    // eslint-disable-next-line no-param-reassign\n    result = [result];\n  }\n\n  for (const validationResult of result) {\n    const failure = toFailure(validationResult, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nexport function* run<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  options: {\n    path?: any[] | undefined;\n    branch?: any[] | undefined;\n    coerce?: boolean | undefined;\n    mask?: boolean | undefined;\n    message?: string | undefined;\n  } = {},\n): IterableIterator<[Failure, undefined] | [undefined, Type]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options;\n  const context: Context = { path, branch };\n\n  if (coerce) {\n    // eslint-disable-next-line no-param-reassign\n    value = struct.coercer(value, context);\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let status: 'valid' | 'not_refined' | 'not_valid' = 'valid';\n\n  for (const failure of struct.validator(value, context)) {\n    failure.explanation = options.message;\n    status = 'not_valid';\n    yield [failure, undefined];\n  }\n\n  // eslint-disable-next-line prefer-const\n  for (let [innerKey, innerValue, innerStruct] of struct.entries(\n    value,\n    context,\n  )) {\n    const iterable = run(innerValue, innerStruct as Struct, {\n      path: innerKey === undefined ? path : [...path, innerKey],\n      branch: innerKey === undefined ? branch : [...branch, innerValue],\n      coerce,\n      mask,\n      message: options.message,\n    });\n\n    for (const result of iterable) {\n      if (result[0]) {\n        status =\n          result[0].refinement === null || result[0].refinement === undefined\n            ? 'not_valid'\n            : 'not_refined';\n\n        yield [result[0], undefined];\n      } else if (coerce) {\n        innerValue = result[1];\n\n        if (innerKey === undefined) {\n          // eslint-disable-next-line no-param-reassign\n          value = innerValue;\n        } else if (value instanceof Map) {\n          value.set(innerKey, innerValue);\n        } else if (value instanceof Set) {\n          value.add(innerValue);\n        } else if (isObject(value)) {\n          if (innerValue !== undefined || innerKey in value) {\n            value[innerKey] = innerValue;\n          }\n        }\n      }\n    }\n  }\n\n  if (status !== 'not_valid') {\n    for (const failure of struct.refiner(value as Type, context)) {\n      failure.explanation = options.message;\n      status = 'not_refined';\n      yield [failure, undefined];\n    }\n  }\n\n  if (status === 'valid') {\n    yield [undefined, value as Type];\n  }\n}\n\n/**\n * Convert a union of type to an intersection.\n */\nexport type UnionToIntersection<Union> = (\n  Union extends any ? (arg: Union) => any : never\n) extends (arg: infer Type) => void\n  ? Type\n  : never;\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\nexport type Assign<Type, OtherType> = Simplify<\n  OtherType & Omit<Type, keyof OtherType>\n>;\n\n/**\n * A schema for enum structs.\n */\nexport type EnumSchema<Type extends string | number | undefined | null> = {\n  [Key in NonNullable<Type>]: Key;\n};\n\n/**\n * Check if a type is a match for another whilst treating overlapping\n * unions as a match.\n */\nexport type IsMatch<Type, OtherType> = Type extends OtherType\n  ? OtherType extends Type\n    ? Type\n    : never\n  : never;\n\n/**\n * Check if a type is an exact match.\n */\nexport type IsExactMatch<Type, OtherType> = (<Inner>() => Inner extends Type\n  ? 1\n  : 2) extends <Inner>() => Inner extends OtherType ? 1 : 2\n  ? Type\n  : never;\n\n/**\n * Check if a type is a record type.\n */\nexport type IsRecord<Type> = Type extends object\n  ? string extends keyof Type\n    ? Type\n    : never\n  : never;\n\n/**\n * Check if a type is a tuple.\n */\nexport type IsTuple<Type> = Type extends [any]\n  ? Type\n  : Type extends [any, any]\n  ? Type\n  : Type extends [any, any, any]\n  ? Type\n  : Type extends [any, any, any, any]\n  ? Type\n  : Type extends [any, any, any, any, any]\n  ? Type\n  : never;\n\n/**\n * Check if a type is a union.\n */\nexport type IsUnion<Type, Union extends Type = Type> = (\n  Type extends any ? (Union extends Type ? false : true) : false\n) extends false\n  ? never\n  : Type;\n\n/**\n * A schema for object structs.\n */\nexport type ObjectSchema = Record<string, Struct<any, any>>;\n\n/**\n * Infer a type from an object struct schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof Schema]: Infer<Schema[K]> }>\n>;\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<Type, Value> = Omit<\n  Type,\n  {\n    [Key in keyof Type]: Value extends Extract<Type[Key], Value> ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\nexport type Optionalize<Schema extends object> = OmitBy<Schema, undefined> &\n  Partial<PickBy<Schema, undefined>>;\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<Schema extends ObjectSchema> = {\n  [K in keyof Schema]: Struct<Infer<Schema[K]> | undefined>;\n};\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<Type, Value> = Pick<\n  Type,\n  {\n    [Key in keyof Type]: Value extends Extract<Type[Key], Value> ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<Type> = Type extends any[] | Date\n  ? Type\n  : // eslint-disable-next-line @typescript-eslint/ban-types\n    { [Key in keyof Type]: Type[Key] } & {};\n\nexport type If<Condition extends boolean, Then, Else> = Condition extends true\n  ? Then\n  : Else;\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<Type> = [Type] extends [string | undefined | null]\n  ? [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer Inner)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<Inner>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : { [K in keyof Type]: Describe<Type[K]> }\n  : null;\n\n/**\n * A schema for tuple structs.\n */\nexport type TupleSchema<Type> = { [K in keyof Type]: Struct<Type[K]> };\n\n/**\n * Shorthand type for matching any `Struct`.\n */\n\nexport type AnyStruct = Struct<any, any>;\n\n/**\n * Infer a tuple of types from a tuple of `Struct`s.\n *\n * This is used to recursively retrieve the type from `union` `intersection` and\n * `tuple` structs.\n */\n\nexport type InferStructTuple<\n  Tuple extends AnyStruct[],\n  Length extends number = Tuple['length'],\n> = Length extends Length\n  ? number extends Length\n    ? Tuple\n    : InferTuple<Tuple, Length, []>\n  : never;\n\ntype InferTuple<\n  Tuple extends AnyStruct[],\n  Length extends number,\n  Accumulated extends unknown[],\n  Index extends number = Accumulated['length'],\n> = Index extends Length\n  ? Accumulated\n  : InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;\n", "import type { Failure } from './error.js';\nimport { StructError } from './error.js';\nimport type { StructSchema } from './utils.js';\nimport { toFailures, shiftIterator, run } from './utils.js';\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<Type = unknown, Schema = unknown> {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  readonly TYPE!: Type;\n\n  type: string;\n\n  schema: Schema;\n\n  coercer: (value: unknown, context: Context) => unknown;\n\n  validator: (value: unknown, context: Context) => Iterable<Failure>;\n\n  refiner: (value: Type, context: Context) => Iterable<Failure>;\n\n  entries: (\n    value: unknown,\n    context: Context,\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>;\n\n  constructor(props: {\n    type: string;\n    schema: Schema;\n    coercer?: Coercer | undefined;\n    validator?: Validator | undefined;\n    refiner?: Refiner<Type> | undefined;\n    entries?: Struct<Type, Schema>['entries'] | undefined;\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {\n        /* noop */\n      },\n    } = props;\n\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown, message?: string): asserts value is Type {\n    return assert(value, this, message);\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown, message?: string): Type {\n    return create(value, this, message);\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is Type {\n    return is(value, this);\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown, message?: string): Type {\n    return mask(value, this, message);\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean;\n      message?: string;\n    } = {},\n  ): [StructError, undefined] | [undefined, Type] {\n    return validate(value, this, options);\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nexport function assert<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): asserts value is Type {\n  const result = validate(value, struct, { message });\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nexport function create<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  const result = validate(value, struct, { coerce: true, message });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nexport function mask<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  const result = validate(value, struct, { coerce: true, mask: true, message });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nexport function is<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n): value is Type {\n  const result = validate(value, struct);\n  return !result[0];\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nexport function validate<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  options: {\n    coerce?: boolean | undefined;\n    mask?: boolean | undefined;\n    message?: string | undefined;\n  } = {},\n): [StructError, undefined] | [undefined, Type] {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples) as [\n    Failure | undefined,\n    Type | undefined,\n  ];\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const innerTuple of tuples) {\n        if (innerTuple[0]) {\n          yield innerTuple[0];\n        }\n      }\n    });\n\n    return [error, undefined];\n  }\n\n  const validatedValue = tuple[1] as Type;\n  return [undefined, validatedValue];\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: any[];\n  path: any[];\n};\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<StructType extends Struct<any, any>> = StructType['TYPE'];\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>;\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<Type = unknown> = (\n  value: Type,\n  context: Context,\n) => unknown;\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result;\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<Type> = (value: Type, context: Context) => Result;\n", "import type { Context, Validator } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport type {\n  Assign,\n  ObjectSchema,\n  ObjectType,\n  PartialObjectSchema,\n} from '../utils.js';\nimport { object, optional, type } from './types.js';\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * Like JavaScript's `Object.assign` utility.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<First extends ObjectSchema, Second extends ObjectSchema>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n): Struct<ObjectType<Assign<First, Second>>, Assign<First, Second>>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n): Struct<\n  ObjectType<Assign<Assign<First, Second>, Third>>,\n  Assign<Assign<First, Second>, Third>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @param Fourth - The fourth struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n  Fourth extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n  Fourth: Struct<ObjectType<Fourth>, Fourth>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<First, Second>, Third>, Fourth>>,\n  Assign<Assign<Assign<First, Second>, Third>, Fourth>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @param Fourth - The fourth struct to combine.\n * @param Fifth - The fifth struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n  Fourth extends ObjectSchema,\n  Fifth extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n  Fourth: Struct<ObjectType<Fourth>, Fourth>,\n  Fifth: Struct<ObjectType<Fifth>, Fifth>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<First, Second>, Third>, Fourth>, Fifth>\n  >,\n  Assign<Assign<Assign<Assign<First, Second>, Third>, Fourth>, Fifth>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign(...Structs: Struct<any>[]): any {\n  const isType = Structs[0]?.type === 'type';\n  const schemas = Structs.map(({ schema }) => schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nexport function define<Type>(\n  name: string,\n  validator: Validator,\n): Struct<Type, null> {\n  return new Struct({ type: name, schema: null, validator });\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nexport function deprecated<Type>(\n  struct: Struct<Type>,\n  log: (value: unknown, ctx: Context) => void,\n): Struct<Type> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      }\n      log(value, ctx);\n      return struct.validator(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nexport function dynamic<Type>(\n  fn: (value: unknown, ctx: Context) => Struct<Type, any>,\n): Struct<Type, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nexport function lazy<Type>(fn: () => Struct<Type, any>): Struct<Type, null> {\n  let struct: Struct<Type, any> | undefined;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn();\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      struct ??= fn();\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      struct ??= fn();\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      struct ??= fn();\n      return struct.refiner(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nexport function omit<Schema extends ObjectSchema, Key extends keyof Schema>(\n  struct: Struct<ObjectType<Schema>, Schema>,\n  keys: Key[],\n): Struct<ObjectType<Omit<Schema, Key>>, Omit<Schema, Key>> {\n  const { schema } = struct;\n  const subschema: any = { ...schema };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema as Omit<Schema, Key>);\n    default:\n      return object(subschema as Omit<Schema, Key>);\n  }\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nexport function partial<Schema extends ObjectSchema>(\n  struct: Struct<ObjectType<Schema>, Schema> | Schema,\n): Struct<\n  ObjectType<PartialObjectSchema<Schema>>,\n  PartialObjectSchema<Schema>\n> {\n  const isStruct = struct instanceof Struct;\n  const schema: any = isStruct ? { ...struct.schema } : { ...struct };\n\n  // eslint-disable-next-line guard-for-in\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  if (isStruct && struct.type === 'type') {\n    return type(schema) as any;\n  }\n\n  return object(schema) as any;\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nexport function pick<Schema extends ObjectSchema, Key extends keyof Schema>(\n  struct: Struct<ObjectType<Schema>, Schema>,\n  keys: Key[],\n): Struct<ObjectType<Pick<Schema, Key>>, Pick<Schema, Key>> {\n  const { schema } = struct;\n  const subschema: any = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema) as any;\n\n    default:\n      return object(subschema) as any;\n  }\n}\n", "import type { Infer } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport type {\n  ObjectSchema,\n  ObjectType,\n  AnyStruct,\n  InferStructTuple,\n  UnionToIntersection,\n} from '../utils.js';\nimport { print, run, isObject } from '../utils.js';\nimport { define } from './utilities.js';\n\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any(): Struct<any, null> {\n  return define('any', () => true);\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(\n  Element: Type,\n): Struct<Infer<Type>[], Type>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @returns A new struct that will accept any array.\n */\nexport function array(): Struct<unknown[], undefined>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(Element?: Type): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [index, arrayValue] of value.entries()) {\n          yield [index, arrayValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint(): Struct<bigint, null> {\n  return define('bigint', (value) => {\n    return typeof value === 'bigint';\n  });\n}\n\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean';\n  });\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends number, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends string, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<\n  Type extends string | number,\n  Values extends readonly Type[],\n>(values: Values): any {\n  const schema: any = {};\n  const description = values.map((value) => print(value)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance<Type extends new (...args: any) => any>(\n  Class: Type,\n): Struct<InstanceType<Type>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<\n  Infer<First> & UnionToIntersection<InferStructTuple<Rest>[number]>,\n  null\n> {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, context) {\n      for (const { entries } of Structs) {\n        yield* entries(value, context);\n      }\n    },\n    *validator(value, context) {\n      for (const { validator } of Structs) {\n        yield* validator(value, context);\n      }\n    },\n    *refiner(value, context) {\n      for (const { refiner } of Structs) {\n        yield* refiner(value, context);\n      }\n    },\n  });\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends boolean>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends number>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends string>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): Struct<Type, null>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): any {\n  const description = print(constant);\n  const valueType = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema:\n      valueType === 'string' ||\n      valueType === 'number' ||\n      valueType === 'boolean'\n        ? constant\n        : null,\n\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(): Struct<Map<unknown, unknown>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Map<Key, Value>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(Key?: Struct<Key>, Value?: Struct<Value>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [mapKey, mapValue] of value.entries()) {\n          yield [mapKey as string, mapKey, Key];\n          yield [mapKey as string, mapValue, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never(): Struct<never, null> {\n  return define('never', () => false);\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | null, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @returns A new struct that will only accept objects.\n */\nexport function object(): Struct<Record<string, unknown>, null>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema?: Schema | undefined,\n): any {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ?? null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key] as Struct<any>];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | undefined, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record<Key extends string, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Record<Key, Value>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        // eslint-disable-next-line guard-for-in\n        for (const objectKey in value) {\n          const objectValue = value[objectKey];\n          yield [objectKey, objectKey, Key];\n          yield [objectKey, objectValue, Value];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp;\n  });\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(): Struct<Set<unknown>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element: Struct<Type>): Struct<Set<Type>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element?: Struct<Type>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const setValue of value) {\n          yield [setValue as string, setValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<[Infer<First>, ...InferStructTuple<Rest>], null> {\n  const Never = never();\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k] as Struct<any>];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<Infer<First> | InferStructTuple<Rest>[number], null> {\n  const description = Structs.map((struct) => struct.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value) {\n      for (const InnerStruct of Structs) {\n        const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n        if (!error) {\n          return coerced;\n        }\n      }\n\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const InnerStruct of Structs) {\n        const [...tuples] = run(value, InnerStruct, ctx);\n        const [first] = tuples;\n\n        if (!first?.[0]) {\n          return [];\n        }\n\n        for (const [failure] of tuples) {\n          if (failure) {\n            failures.push(failure);\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value,\n        )}`,\n        ...failures,\n      ];\n    },\n  });\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true);\n}\n", "import type { Coercer } from '../struct.js';\nimport { Struct, is } from '../struct.js';\nimport { isPlainObject } from '../utils.js';\nimport { string, unknown } from './types.js';\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nexport function coerce<Type, Schema, CoercionType>(\n  struct: Struct<Type, Schema>,\n  condition: Struct<CoercionType, any>,\n  coercer: Coercer<CoercionType>,\n): Struct<Type, Schema> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx);\n    },\n  });\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nexport function defaulted<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  fallback: any,\n  options: {\n    strict?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  return coerce(struct, unknown(), (value) => {\n    const result = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (value === undefined) {\n      return result;\n    }\n\n    if (!options.strict && isPlainObject(value) && isPlainObject(result)) {\n      const ret = { ...value };\n      let changed = false;\n\n      for (const key in result) {\n        if (ret[key] === undefined) {\n          ret[key] = result[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return value;\n  });\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nexport function trimmed<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type, Schema> {\n  return coerce(struct, string(), (value) => value.trim());\n}\n", "import type { Refiner } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport { toFailures } from '../utils.js';\n\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nexport function empty<\n  Type extends string | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(struct: Struct<Type, Schema>): Struct<Type, Schema> {\n  return refine(struct, 'empty', (value) => {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const size = getSize(value);\n    return (\n      size === 0 ||\n      `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``\n    );\n  });\n}\n\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value: string | any[] | Map<any, any> | Set<any>): number {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  }\n\n  return value.length;\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nexport function max<Type extends number | Date, Schema>(\n  struct: Struct<Type, Schema>,\n  threshold: Type,\n  options: {\n    exclusive?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  const { exclusive } = options;\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} less than ${\n            exclusive ? '' : 'or equal to '\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          }${threshold} but received \\`${value}\\``;\n  });\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nexport function min<Type extends number | Date, Schema>(\n  struct: Struct<Type, Schema>,\n  threshold: Type,\n  options: {\n    exclusive?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  const { exclusive } = options;\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          }${threshold} but received \\`${value}\\``;\n  });\n}\n\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nexport function nonempty<\n  Type extends string | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(struct: Struct<Type, Schema>): Struct<Type, Schema> {\n  return refine(struct, 'nonempty', (value) => {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const size = getSize(value);\n    return (\n      size > 0 || `Expected a nonempty ${struct.type} but received an empty one`\n    );\n  });\n}\n\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nexport function pattern<Type extends string, Schema>(\n  struct: Struct<Type, Schema>,\n  regexp: RegExp,\n): Struct<Type, Schema> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    );\n  });\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nexport function size<\n  Type extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n  minimum: number,\n  maximum: number = minimum,\n): Struct<Type, Schema> {\n  const expected = `Expected a ${struct.type}`;\n  const of =\n    minimum === maximum\n      ? `of \\`${minimum}\\``\n      : `between \\`${minimum}\\` and \\`${maximum}\\``;\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (minimum <= value && value <= maximum) ||\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `${expected} ${of} but received \\`${value}\\``\n      );\n    } else if (value instanceof Map || value instanceof Set) {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const { size } = value;\n      return (\n        (minimum <= size && size <= maximum) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      );\n    }\n\n    const { length } = value;\n    return (\n      (minimum <= length && length <= maximum) ||\n      `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n    );\n  });\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nexport function refine<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  name: string,\n  refiner: Refiner<Type>,\n): Struct<Type, Schema> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name };\n      }\n    },\n  });\n}\n", "//\n// Types\n//\n\n/**\n * Makes every specified property of the specified object type mutable.\n *\n * @template ObjectValue - The object whose readonly properties to make mutable.\n * @template TargetKey - The property key(s) to make mutable.\n */\nexport type Mutable<\n  ObjectValue extends Record<string, unknown>,\n  TargetKey extends keyof ObjectValue,\n> = {\n  -readonly [Key in keyof Pick<ObjectValue, TargetKey>]: ObjectValue[Key];\n} & {\n  [Key in keyof Omit<ObjectValue, TargetKey>]: ObjectValue[Key];\n};\n\n/**\n * Get a type representing the public interface of the given type. The\n * returned type will have all public properties, but will omit private\n * properties.\n *\n * @template Interface - The interface to return a public representation of.\n */\nexport type PublicInterface<Interface> = Pick<Interface, keyof Interface>;\n\n/**\n * Useful for representing some value that _might_ be present and / or complete.\n *\n * @template Value - The value that might be present or complete.\n */\nexport type PartialOrAbsent<Value> = Partial<Value> | null | undefined;\n\n/**\n * Like {@link Array}, but always non-empty.\n *\n * @template Element - The non-empty array member type.\n */\nexport type NonEmptyArray<Element> = [Element, ...Element[]];\n\n/**\n * A JavaScript object that is not `null`, a function, or an array.\n */\nexport type RuntimeObject = Record<PropertyKey, unknown>;\n\n//\n// Type Guards\n//\n\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray<Element>(\n  value: Element[],\n): value is NonEmptyArray<Element> {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value: unknown): value is RuntimeObject {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n//\n// Other utility functions\n//\n\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = <\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ObjectToCheck extends Object,\n  Property extends PropertyKey,\n>(\n  objectToCheck: ObjectToCheck,\n  name: Property,\n): objectToCheck is ObjectToCheck &\n  Record<\n    Property,\n    Property extends keyof ObjectToCheck ? ObjectToCheck[Property] : unknown\n  > => Object.hasOwnProperty.call(objectToCheck, name);\n\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames<Key extends PropertyKey>(\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.getOwnPropertyNames(object) as Key[];\n}\n\nexport type PlainObject = Record<number | string | symbol, unknown>;\n\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport enum JsonSize {\n  Null = 4,\n  Comma = 1,\n  Wrapper = 1,\n  True = 4,\n  False = 5,\n  Quote = 1,\n  Colon = 1,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Date = 24,\n}\n\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character: string) {\n  return character.charCodeAt(0) <= 127;\n}\n\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value: string): number {\n  const size = value.split('').reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n\n  // Also detect characters that need backslash escape\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value: number): number {\n  return value.toString().length;\n}\n", "import { ErrorWithCause } from 'pony-cause';\n\nimport { isNullOrUndefined, isObject } from './misc';\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error: unknown): error is Error {\n  return (\n    error instanceof Error ||\n    (isObject(error) && error.constructor.name === 'Error')\n  );\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error: unknown): error is { code: string } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(\n  error: unknown,\n): error is { message: string } {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error: unknown): error is { stack: string } {\n  return typeof error === 'object' && error !== null && 'stack' in error;\n}\n\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isErrorWithMessage(error) && typeof error.message === 'string') {\n    return error.message;\n  }\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  return String(error);\n}\n\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError<Throwable>(\n  originalError: Throwable,\n  message: string,\n): Error & { code?: string } {\n  if (isError(originalError)) {\n    let error: Error & { code?: string };\n    if (Error.length === 2) {\n      // for some reason `tsserver` is not complaining that the\n      // Error constructor doesn't support a second argument in the editor,\n      // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new Error(message, { cause: originalError });\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n\n    return error;\n  }\n\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n\n  return new Error(String(originalError));\n}\n", "import type { Struct } from '@metamask/superstruct';\nimport { assert as assertSuperstruct } from '@metamask/superstruct';\n\nimport { getErrorMessage } from './errors';\n\nexport type AssertionErrorConstructor =\n  | (new (args: { message: string }) => Error)\n  | ((args: { message: string }) => Error);\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(\n  fn: AssertionErrorConstructor,\n): fn is new (args: { message: string }) => Error {\n  /* istanbul ignore next */\n  return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error: unknown): string {\n  // We'll add our own period.\n  return getErrorMessage(error).replace(/\\.$/u, '');\n}\n\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper: AssertionErrorConstructor, message: string) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message,\n    });\n  }\n  return ErrorWrapper({\n    message,\n  });\n}\n\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n  readonly code = 'ERR_ASSERTION';\n\n  constructor(options: { message: string }) {\n    super(options.message);\n  }\n}\n\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(\n  value: any,\n  message: string | Error = 'Assertion failed.',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n\n    throw getError(ErrorWrapper, message);\n  }\n}\n\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  errorPrefix = 'Assertion failed',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value is Type {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`,\n    );\n  }\n}\n\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object: never): never {\n  throw new Error(\n    'Invalid branch reached. Should be detected during compilation.',\n  );\n}\n", "import type { Struct } from '@metamask/superstruct';\nimport { pattern } from '@metamask/superstruct';\n\nimport { assert } from './assert';\n\nexport type Base64Options = {\n  /**\n   * Is the `=` padding at the end required or not.\n   *\n   * @default false\n   */\n  // Padding is optional in RFC 4648, that's why the default value is false\n  paddingRequired?: boolean;\n  /**\n   * Which character set should be used.\n   * The sets are based on {@link https://datatracker.ietf.org/doc/html/rfc4648 RFC 4648}.\n   *\n   * @default 'base64'\n   */\n  characterSet?: 'base64' | 'base64url';\n};\n\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nexport const base64 = <Type extends string, Schema>(\n  struct: Struct<Type, Schema>,\n  options: Base64Options = {},\n) => {\n  const paddingRequired = options.paddingRequired ?? false;\n  const characterSet = options.characterSet ?? 'base64';\n\n  let letters: string;\n  if (characterSet === 'base64') {\n    letters = String.raw`[A-Za-z0-9+\\/]`;\n  } else {\n    assert(characterSet === 'base64url');\n    letters = String.raw`[-_A-Za-z0-9]`;\n  }\n\n  let re: RegExp;\n  if (paddingRequired) {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  } else {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  }\n\n  return pattern(struct, re);\n};\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n: number) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\ntype Alphabet = string[] | string;\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet: Alphabet): Coder<number[], string[]> {\n  return {\n    encode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map((i) => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length)\n          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i]!;\n      });\n    },\n    decode: (input: string[]) => {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('alphabet.decode input should be array of strings');\n      return input.map((letter) => {\n        if (typeof letter !== 'string')\n          throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: (from) => {\n      if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n        throw new Error('join.encode input should be array of strings');\n      for (let i of from)\n        if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data: string[]): string[] {\n      if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of data)\n        if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of input)\n        if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!(((end - 1) * bits) % 8))\n          throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data: number[], from: number, to: number) {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach((d) => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i]!;\n      const digitBase = from * carry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        (from * carry) / from !== carry ||\n        digitBase - digit !== from * carry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a: number, b: number): number => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const mask = 2 ** to - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  assertNumber(num);\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix2.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789ABCDEF'),\n  join('')\n);\nexport const base32: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\nexport const base32nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\nexport const base32hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\nexport const base32hexnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\nexport const base32crockford: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\nexport const base64: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\nexport const base64nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\nexport const base64url: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\nexport const base64urlnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = (abc: string) => chain(radix(58), alphabet(abc), join(''));\n\nexport const base58: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\nexport const base58flickr: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\nexport const base58xrp: BytesCoder = /* @__PURE__ */ genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n// legacy export, bad name\nexport const base58check = createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = /* @__PURE__ */ chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m') {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    if (typeof prefix !== 'string')\n      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    if (typeof str !== 'string')\n      throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || (limit !== false && str.length > limit))\n      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\n\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\nexport const hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789abcdef'),\n  join(''),\n  normalize((s: string) => {\n    if (typeof s !== 'string' || s.length % 2)\n      throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n  })\n);\n\n// prettier-ignore\nconst CODERS = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof typeof CODERS;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\n\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n", "import type { Struct } from '@metamask/superstruct';\nimport { is, pattern, string } from '@metamask/superstruct';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport { assert } from './assert';\nimport { bytesToHex } from './bytes';\n\nexport type Hex = `0x${string}`;\n\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu) as Struct<\n  Hex,\n  null\n>;\nexport const HexAddressStruct = pattern(\n  string(),\n  /^0x[0-9a-f]{40}$/u,\n) as Struct<Hex, null>;\nexport const HexChecksumAddressStruct = pattern(\n  string(),\n  /^0x[0-9a-fA-F]{40}$/u,\n) as Struct<Hex, null>;\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return is(value, HexStruct);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return is(value, StrictHexStruct);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddress(possibleAddress: Hex) {\n  return (\n    is(possibleAddress, HexAddressStruct) ||\n    isValidChecksumAddress(possibleAddress)\n  );\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddress(address: Hex): Hex {\n  assert(is(address, HexChecksumAddressStruct), 'Invalid hex address.');\n  const unPrefixed = remove0x(address.toLowerCase());\n  const unPrefixedHash = remove0x(bytesToHex(keccak256(unPrefixed)));\n  return `0x${unPrefixed\n    .split('')\n    .map((character, nibbleIndex) => {\n      const hashCharacter = unPrefixedHash[nibbleIndex];\n      assert(is(hashCharacter, string()), 'Hash shorter than address.');\n      return parseInt(hashCharacter, 16) > 7\n        ? character.toUpperCase()\n        : character;\n    })\n    .join('')}`;\n}\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddress(possibleChecksum: Hex) {\n  if (!is(possibleChecksum, HexChecksumAddressStruct)) {\n    return false;\n  }\n\n  return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n", "import { base64 } from '@scure/base';\n\nimport { assert } from './assert';\nimport type { Hex } from './hex';\nimport { add0x, assertIsHexString, remove0x } from './hex';\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n\nexport type Bytes = bigint | number | string | Uint8Array;\n\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder(): () => string[] {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable: string[] = [];\n\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n\n    return lookupTable;\n  };\n}\n\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nexport function isBytes(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nexport function assertIsBytes(value: unknown): asserts value is Uint8Array {\n  assert(isBytes(value), 'Value must be a Uint8Array.');\n}\n\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  assertIsBytes(bytes);\n\n  if (bytes.length === 0) {\n    return '0x';\n  }\n\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]!];\n  }\n\n  return add0x(hexadecimal.join(''));\n}\n\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\n\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nexport function bytesToSignedBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bytes.length * 8, value);\n}\n\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nexport function bytesToNumber(bytes: Uint8Array): number {\n  assertIsBytes(bytes);\n\n  const bigint = bytesToBigInt(bytes);\n\n  assert(\n    bigint <= BigInt(Number.MAX_SAFE_INTEGER),\n    'Number is not a safe integer. Use `bytesToBigInt` instead.',\n  );\n\n  return Number(bigint);\n}\n\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nexport function bytesToString(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nexport function bytesToBase64(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return base64.encode(bytes);\n}\n\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function hexToBytes(value: string): Uint8Array {\n  // \"0x\" is often used as empty byte array.\n  if (value?.toLowerCase?.() === '0x') {\n    return new Uint8Array();\n  }\n\n  assertIsHexString(value);\n\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = remove0x(value).toLowerCase();\n  const normalizedValue =\n    strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 =\n      c1 -\n      (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n    const n2 =\n      c2 -\n      (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function bigIntToBytes(value: bigint): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= BigInt(0), 'Value must be a non-negative bigint.');\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value: bigint, bytes: number): boolean {\n  assert(bytes > 0);\n\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nexport function signedBigIntToBytes(\n  value: bigint,\n  byteLength: number,\n): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(typeof byteLength === 'number', 'Byte length must be a number.');\n  assert(byteLength > 0, 'Byte length must be greater than 0.');\n  assert(\n    bigIntFits(value, byteLength),\n    'Byte length is too small to represent the given value.',\n  );\n\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n\n  return bytes.reverse();\n}\n\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nexport function numberToBytes(value: number): Uint8Array {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToBytes` instead.',\n  );\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function stringToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function base64ToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return base64.decode(value);\n}\n\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function valueToBytes(value: Bytes): Uint8Array {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n\n    return stringToBytes(value);\n  }\n\n  if (isBytes(value)) {\n    return value;\n  }\n\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nexport function concatBytes(values: Bytes[]): Uint8Array {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]!);\n\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n\n  return bytes;\n}\n\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nexport function createDataView(bytes: Uint8Array): DataView {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(\n      bytes.byteOffset,\n      bytes.byteOffset + bytes.byteLength,\n    );\n\n    return new DataView(buffer);\n  }\n\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n", "import { is, pattern, string } from '@metamask/superstruct';\nimport type { Infer, Struct } from '@metamask/superstruct';\n\nexport const CAIP_CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\n\nexport const CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\n\nexport const CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\n\nexport const CAIP_ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\n\nexport const CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const CaipChainIdStruct = pattern(\n  string(),\n  CAIP_CHAIN_ID_REGEX,\n) as Struct<CaipChainId, null>;\nexport type CaipChainId = `${string}:${string}`;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexport const CaipNamespaceStruct = pattern(string(), CAIP_NAMESPACE_REGEX);\nexport type CaipNamespace = Infer<typeof CaipNamespaceStruct>;\n\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexport const CaipReferenceStruct = pattern(string(), CAIP_REFERENCE_REGEX);\nexport type CaipReference = Infer<typeof CaipReferenceStruct>;\n\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexport const CaipAccountIdStruct = pattern(\n  string(),\n  CAIP_ACCOUNT_ID_REGEX,\n) as Struct<CaipAccountId, null>;\nexport type CaipAccountId = `${string}:${string}:${string}`;\n\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexport const CaipAccountAddressStruct = pattern(\n  string(),\n  CAIP_ACCOUNT_ADDRESS_REGEX,\n);\nexport type CaipAccountAddress = Infer<typeof CaipAccountAddressStruct>;\n\n/** Known CAIP namespaces. */\nexport enum KnownCaipNamespace {\n  /** EIP-155 compatible chains. */\n  Eip155 = 'eip155',\n  Wallet = 'wallet',\n}\n\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nexport function isCaipChainId(value: unknown): value is CaipChainId {\n  return is(value, CaipChainIdStruct);\n}\n\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nexport function isCaipNamespace(value: unknown): value is CaipNamespace {\n  return is(value, CaipNamespaceStruct);\n}\n\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nexport function isCaipReference(value: unknown): value is CaipReference {\n  return is(value, CaipReferenceStruct);\n}\n\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nexport function isCaipAccountId(value: unknown): value is CaipAccountId {\n  return is(value, CaipAccountIdStruct);\n}\n\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nexport function isCaipAccountAddress(\n  value: unknown,\n): value is CaipAccountAddress {\n  return is(value, CaipAccountAddressStruct);\n}\n\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nexport function parseCaipChainId(caipChainId: CaipChainId): {\n  namespace: CaipNamespace;\n  reference: CaipReference;\n} {\n  const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace as CaipNamespace,\n    reference: match.groups.reference as CaipReference,\n  };\n}\n\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nexport function parseCaipAccountId(caipAccountId: CaipAccountId): {\n  address: CaipAccountAddress;\n  chainId: CaipChainId;\n  chain: { namespace: CaipNamespace; reference: CaipReference };\n} {\n  const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress as CaipAccountAddress,\n    chainId: match.groups.chainId as CaipChainId,\n    chain: {\n      namespace: match.groups.namespace as CaipNamespace,\n      reference: match.groups.reference as CaipReference,\n    },\n  };\n}\n\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nexport function toCaipChainId(\n  namespace: CaipNamespace,\n  reference: CaipReference,\n): CaipChainId {\n  if (!isCaipNamespace(namespace)) {\n    throw new Error(\n      `Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipReference(reference)) {\n    throw new Error(\n      `Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  return `${namespace}:${reference}`;\n}\n", "import { size, string } from '@metamask/superstruct';\n\nimport { base64 } from './base64';\n\nexport const ChecksumStruct = size(\n  base64(string(), { paddingRequired: true }),\n  44,\n  44,\n);\n", "import type { Infer } from '@metamask/superstruct';\nimport {\n  bigint,\n  coerce,\n  create,\n  instance,\n  number,\n  string,\n  StructError,\n  union,\n} from '@metamask/superstruct';\n\nimport { assert } from './assert';\nimport { bytesToHex, hexToBytes } from './bytes';\nimport type { Hex } from './hex';\nimport { StrictHexStruct } from './hex';\n\nconst NumberLikeStruct = union([number(), bigint(), string(), StrictHexStruct]);\nconst NumberCoercer = coerce(number(), NumberLikeStruct, Number);\nconst BigIntCoercer = coerce(bigint(), NumberLikeStruct, BigInt);\n\nconst BytesLikeStruct = union([StrictHexStruct, instance(Uint8Array)]);\nconst BytesCoercer = coerce(\n  instance(Uint8Array),\n  union([StrictHexStruct]),\n  hexToBytes,\n);\n\nconst HexCoercer = coerce(StrictHexStruct, instance(Uint8Array), bytesToHex);\n\nexport type NumberLike = Infer<typeof NumberLikeStruct>;\nexport type BytesLike = Infer<typeof BytesLikeStruct>;\n\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nexport function createNumber(value: NumberLike): number {\n  try {\n    const result = create(value, NumberCoercer);\n\n    assert(\n      Number.isFinite(result),\n      `Expected a number-like value, got \"${value}\".`,\n    );\n\n    return result;\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(`Expected a number-like value, got \"${value}\".`);\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nexport function createBigInt(value: NumberLike): bigint {\n  try {\n    // The `BigInt` constructor throws if the value is not a number-like value.\n    // There is no need to validate the value manually.\n    return create(value, BigIntCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a number-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nexport function createBytes(value: BytesLike): Uint8Array {\n  if (typeof value === 'string' && value.toLowerCase() === '0x') {\n    return new Uint8Array();\n  }\n\n  try {\n    return create(value, BytesCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a bytes-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nexport function createHex(value: BytesLike): Hex {\n  if (\n    (value instanceof Uint8Array && value.length === 0) ||\n    (typeof value === 'string' && value.toLowerCase() === '0x')\n  ) {\n    return '0x';\n  }\n\n  try {\n    return create(value, HexCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a bytes-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n", "/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap<Key, Value> implements ReadonlyMap<Key, Value> {\n  readonly #map: Map<Key, Value>;\n\n  public get size() {\n    return this.#map.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#map[Symbol.iterator]();\n  }\n\n  constructor(entries?: readonly (readonly [Key, Value])[] | null) {\n    this.#map = new Map<Key, Value>(entries);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#map.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, key: Key, map: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return this.#map.forEach((value: Value, key: Key, _map: unknown) =>\n      callbackfn.call(thisArg, value, key, this),\n    );\n  }\n\n  public get(key: Key) {\n    return this.#map.get(key);\n  }\n\n  public has(key: Key) {\n    return this.#map.has(key);\n  }\n\n  public keys() {\n    return this.#map.keys();\n  }\n\n  public values() {\n    return this.#map.values();\n  }\n\n  public toString(): string {\n    return `FrozenMap(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.entries()]\n            .map(([key, value]) => `${String(key)} => ${String(value)}`)\n            .join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet<Value> implements ReadonlySet<Value> {\n  readonly #set: Set<Value>;\n\n  public get size() {\n    return this.#set.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#set[Symbol.iterator]();\n  }\n\n  constructor(values?: readonly Value[] | null) {\n    this.#set = new Set<Value>(values);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#set.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, value2: Value, set: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return this.#set.forEach((value: Value, value2: Value, _set: unknown) =>\n      callbackfn.call(thisArg, value, value2, this),\n    );\n  }\n\n  public has(value: Value) {\n    return this.#set.has(value);\n  }\n\n  public keys() {\n    return this.#set.keys();\n  }\n\n  public values() {\n    return this.#set.values();\n  }\n\n  public toString(): string {\n    return `FrozenSet(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\n\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n\nexport { FrozenMap, FrozenSet };\n", "import {\n  any,\n  array,\n  boolean,\n  coerce,\n  create,\n  define,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  number,\n  object as superstructObject,\n  optional,\n  record,\n  string,\n  union,\n  unknown,\n  Struct,\n} from '@metamask/superstruct';\nimport type {\n  Context,\n  Infer,\n  ObjectSchema,\n  Simplify,\n  Optionalize,\n} from '@metamask/superstruct';\n\nimport type { AssertionErrorConstructor } from './assert';\nimport { assertStruct } from './assert';\nimport { hasProperty } from './misc';\n\n/**\n * Any JSON-compatible value.\n */\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [prop: string]: Json };\n\n/**\n * A helper type to make properties with `undefined` in their type optional, but\n * not `undefined` itself.\n *\n * @example\n * ```ts\n * type Foo = ObjectOptional<{ foo: string | undefined }>;\n * // Foo is equivalent to { foo?: string }\n * ```\n */\nexport type ObjectOptional<Schema extends Record<string, unknown>> = {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? Key\n    : never]?: Schema[Key] extends ExactOptionalGuard & infer Original\n    ? Original\n    : never;\n} & {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? never\n    : Key]: Schema[Key];\n};\n\n/**\n * An object type with support for exact optionals. This is used by the `object`\n * struct. This uses the {@link ObjectOptional} helper to make properties with\n * `undefined` in their type optional, but not `undefined` itself.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ObjectOptional<\n    Optionalize<{\n      [Key in keyof Schema]: Infer<Schema[Key]>;\n    }>\n  >\n>;\n\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = <Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>> =>\n  // The type is slightly different from a regular object struct, because we\n  // want to make properties with `undefined` in their type optional, but not\n  // `undefined` itself. This means that we need a type cast.\n  superstructObject(schema) as unknown as Struct<ObjectType<Schema>>;\n\ndeclare const exactOptionalSymbol: unique symbol;\ntype ExactOptionalGuard = {\n  _exactOptionalGuard?: typeof exactOptionalSymbol;\n};\n\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }: Context): boolean {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\n\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type & ExactOptionalGuard, Schema> {\n  return new Struct<Type & ExactOptionalGuard, Schema>({\n    ...struct,\n\n    type: `optional ${struct.type}`,\n    validator: (value, context) =>\n      !hasOptional(context) || struct.validator(value, context),\n\n    refiner: (value, context) =>\n      !hasOptional(context) || struct.refiner(value as Type, context),\n  });\n}\n\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () =>\n  define<number>('finite number', (value) => {\n    return is(value, number()) && Number.isFinite(value);\n  });\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexport const UnsafeJsonStruct: Struct<Json> = union([\n  literal(null),\n  boolean(),\n  finiteNumber(),\n  string(),\n  array(lazy(() => UnsafeJsonStruct)),\n  record(\n    string(),\n    lazy(() => UnsafeJsonStruct),\n  ),\n]);\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(UnsafeJsonStruct, any(), (value) => {\n  assertStruct(value, UnsafeJsonStruct);\n  return JSON.parse(\n    JSON.stringify(value, (propKey, propValue) => {\n      // Strip __proto__ and constructor properties to prevent prototype pollution.\n      if (propKey === '__proto__' || propKey === 'constructor') {\n        return undefined;\n      }\n      return propValue;\n    }),\n  );\n});\n\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value: unknown): value is Json {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson<Type extends Json = Json>(value: unknown): Type {\n  return create(value, JsonStruct) as Type;\n}\n\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value: unknown): number {\n  assertStruct(value, JsonStruct, 'Invalid JSON value');\n\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\n\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0' as const;\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\n\n/**\n * A String specifying the version of the JSON-RPC protocol.\n * MUST be exactly \"2.0\".\n */\nexport type JsonRpcVersion2 = typeof jsonrpc2;\n\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\n\n/**\n * An identifier established by the Client that MUST contain a String, Number,\n * or NULL value if included. If it is not included it is assumed to be a\n * notification. The value SHOULD normally not be Null and Numbers SHOULD\n * NOT contain fractional parts.\n */\nexport type JsonRpcId = Infer<typeof JsonRpcIdStruct>;\n\nexport const JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string()),\n});\n\n/**\n * Mark a certain key of a type as optional.\n */\nexport type OptionalField<\n  Type extends Record<string, unknown>,\n  Key extends keyof Type,\n> = Omit<Type, Key> & Partial<Pick<Type, Key>>;\n\n/**\n * A JSON-RPC error object.\n *\n * Note that TypeScript infers `unknown | undefined` as `unknown`, meaning that\n * the `data` field is not optional. To make it optional, we use the\n * `OptionalField` helper, to explicitly make it optional.\n */\nexport type JsonRpcError = OptionalField<\n  Infer<typeof JsonRpcErrorStruct>,\n  'data'\n>;\n\nexport const JsonRpcParamsStruct: Struct<Json[] | Record<string, Json>, null> =\n  union([record(string(), JsonStruct), array(JsonStruct)]);\n\nexport type JsonRpcParams = Json[] | Record<string, Json>;\n\nexport const JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\nexport type InferWithParams<\n  Type extends Struct<any>,\n  Params extends JsonRpcParams,\n> = Infer<Type> & {\n  params?: Params;\n};\n\n/**\n * A JSON-RPC request object.\n */\nexport type JsonRpcRequest<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcRequestStruct, Params>;\n\nexport const JsonRpcNotificationStruct = object({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\n/**\n * A JSON-RPC notification object.\n */\nexport type JsonRpcNotification<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcNotificationStruct, Params>;\n\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(\n  value: unknown,\n): value is JsonRpcNotification {\n  return is(value, JsonRpcNotificationStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcNotification {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    'Invalid JSON-RPC notification',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value: unknown): value is JsonRpcRequest {\n  return is(value, JsonRpcRequestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcRequest {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    'Invalid JSON-RPC request',\n    ErrorWrapper,\n  );\n}\n\nexport const PendingJsonRpcResponseStruct = superstructObject({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct),\n});\n\n/**\n * A JSON-RPC response object that has not yet been resolved.\n */\nexport type PendingJsonRpcResponse<Result extends Json> = Omit<\n  Infer<typeof PendingJsonRpcResponseStruct>,\n  'result'\n> & {\n  result?: Result;\n};\n\nexport const JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct,\n});\n\n/**\n * A successful JSON-RPC response object.\n */\nexport type JsonRpcSuccess<Result extends Json> = Omit<\n  Infer<typeof JsonRpcSuccessStruct>,\n  'result'\n> & {\n  result: Result;\n};\n\nexport const JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct as Struct<JsonRpcError>,\n});\n\n/**\n * A failed JSON-RPC response object.\n */\nexport type JsonRpcFailure = Infer<typeof JsonRpcFailureStruct>;\n\nexport const JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n]);\n\n/**\n * A JSON-RPC response object. Must be checked to determine whether it's a\n * success or failure.\n *\n * @template Result - The type of the result.\n */\nexport type JsonRpcResponse<Result extends Json> =\n  | JsonRpcSuccess<Result>\n  | JsonRpcFailure;\n\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(\n  response: unknown,\n): response is PendingJsonRpcResponse<Json> {\n  return is(response, PendingJsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(\n  response: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts response is PendingJsonRpcResponse<Json> {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    'Invalid pending JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(\n  response: unknown,\n): response is JsonRpcResponse<Json> {\n  return is(response, JsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcResponse<Json> {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    'Invalid JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(\n  value: unknown,\n): value is JsonRpcSuccess<Json> {\n  return is(value, JsonRpcSuccessStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcSuccess<Json> {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    'Invalid JSON-RPC success response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value: unknown): value is JsonRpcFailure {\n  return is(value, JsonRpcFailureStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcFailure {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    'Invalid JSON-RPC failure response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value: unknown): value is JsonRpcError {\n  return is(value, JsonRpcErrorStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcError {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    'Invalid JSON-RPC error',\n    ErrorWrapper,\n  );\n}\n\ntype JsonRpcValidatorOptions = {\n  permitEmptyString?: boolean;\n  permitFractions?: boolean;\n  permitNull?: boolean;\n};\n\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options?: JsonRpcValidatorOptions) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options,\n  };\n\n  /**\n   * Type guard for {@link JsonRpcId}.\n   *\n   * @param id - The JSON-RPC ID value to check.\n   * @returns Whether the given ID is valid per the options given to the\n   * factory.\n   */\n  const isValidJsonRpcId = (id: unknown): id is JsonRpcId => {\n    return Boolean(\n      (typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n        (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n        (permitNull && id === null),\n    );\n  };\n\n  return isValidJsonRpcId;\n}\n", "import type { Debugger } from 'debug';\nimport debug from 'debug';\n\nconst globalLogger = debug('metamask');\n\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nexport function createProjectLogger(projectName: string): Debugger {\n  return globalLogger.extend(projectName);\n}\n\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nexport function createModuleLogger(\n  projectLogger: Debugger,\n  moduleName: string,\n): Debugger {\n  return projectLogger.extend(moduleName);\n}\n", "/**\n * Common duration constants, in milliseconds.\n */\nexport enum Duration {\n  /**\n   * A millisecond.\n   */\n  Millisecond = 1,\n\n  /**\n   * A second, in milliseconds.\n   */\n  Second = 1000, // Millisecond * 1000\n\n  /**\n   * A minute, in milliseconds.\n   */\n  Minute = 60_000, // Second * 60\n\n  /**\n   * An hour, in milliseconds.\n   */\n  Hour = 3_600_000, // Minute * 60\n\n  /**\n   * A day, in milliseconds.\n   */\n  Day = 86_400_000, // Hour * 24\n\n  /**\n   * A week, in milliseconds.\n   */\n  Week = 604_800_000, // Day * 7\n\n  /**\n   * A year, in milliseconds.\n   */\n  Year = 31_536_000_000, // Day * 365\n}\n\nconst isNonNegativeInteger = (number: number) =>\n  Number.isInteger(number) && number >= 0;\n\nconst assertIsNonNegativeInteger = (number: number, name: string) => {\n  if (!isNonNegativeInteger(number)) {\n    throw new Error(\n      `\"${name}\" must be a non-negative integer. Received: \"${number}\".`,\n    );\n  }\n};\n\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nexport function inMilliseconds(count: number, duration: Duration): number {\n  assertIsNonNegativeInteger(count, 'count');\n  return count * duration;\n}\n\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nexport function timeSince(timestamp: number): number {\n  assertIsNonNegativeInteger(timestamp, 'timestamp');\n  return Date.now() - timestamp;\n}\n", "import type { Struct } from '@metamask/superstruct';\nimport { is, refine, string } from '@metamask/superstruct';\nimport {\n  gt as gtSemver,\n  gtr as gtrSemver,\n  satisfies as satisfiesSemver,\n  valid as validSemVerVersion,\n  validRange as validSemVerRange,\n} from 'semver';\n\nimport { assertStruct } from './assert';\nimport type { Opaque } from './opaque';\n\n/**\n * {@link https://codemix.com/opaque-types-in-javascript/ Opaque} type for SemVer ranges.\n *\n * @example Use {@link assertIsSemVerRange} and {@link isValidSemVerRange} to cast to proper type.\n * ```typescript\n * const unsafeRange: string = dataFromUser();\n * assertIsSemVerRange(unsafeRange);\n * unsafeRange\n * // ^? SemVerRange\n * ```\n * @example If you know what you're doing and want to side-step type safety, casting from a string works correctly.\n * ```typescript\n * const unsafeRange: string = dataFromUser();\n * unsafeRange as SemVerRange;\n * // ^? SemVerRange\n * ```\n * @see {@link assertIsSemVerRange}\n * @see {@link isValidSemVerRange}\n */\nexport type SemVerRange = Opaque<string, typeof semVerRange>;\ndeclare const semVerRange: unique symbol;\n\n/**\n * {@link https://codemix.com/opaque-types-in-javascript/ Opaque} type for singular SemVer version.\n *\n * @example Use {@link assertIsSemVerVersion} and {@link isValidSemVerVersion} to cast to proper type.\n * ```typescript\n * const unsafeVersion: string = dataFromUser();\n * assertIsSemVerVersion(unsafeRange);\n * unsafeVersion\n * // ^? SemVerVersion\n * ```\n * @example If you know what you're doing and want to side-step type safety, casting from a string works correctly.\n * ```typescript\n * const unsafeVersion: string = dataFromUser();\n * unsafeRange as SemVerVersion;\n * // ^? SemVerVersion\n * ```\n * @see {@link assertIsSemVerVersion}\n * @see {@link isValidSemVerVersion}\n */\nexport type SemVerVersion = Opaque<string, typeof semVerVersion>;\ndeclare const semVerVersion: unique symbol;\n\n/**\n * A struct for validating a version string.\n */\nexport const VersionStruct = refine<SemVerVersion, null>(\n  string() as unknown as Struct<SemVerVersion, null>,\n  'Version',\n  (value) => {\n    if (validSemVerVersion(value) === null) {\n      return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n  },\n);\n\nexport const VersionRangeStruct = refine<SemVerRange, null>(\n  string() as unknown as Struct<SemVerRange, null>,\n  'Version range',\n  (value) => {\n    if (validSemVerRange(value) === null) {\n      return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n  },\n);\n\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nexport function isValidSemVerVersion(\n  version: unknown,\n): version is SemVerVersion {\n  return is(version, VersionStruct);\n}\n\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nexport function isValidSemVerRange(\n  versionRange: unknown,\n): versionRange is SemVerRange {\n  return is(versionRange, VersionRangeStruct);\n}\n\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nexport function assertIsSemVerVersion(\n  version: unknown,\n): asserts version is SemVerVersion {\n  assertStruct(version, VersionStruct);\n}\n\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nexport function assertIsSemVerRange(\n  range: unknown,\n): asserts range is SemVerRange {\n  assertStruct(range, VersionRangeStruct);\n}\n\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nexport function gtVersion(\n  version1: SemVerVersion,\n  version2: SemVerVersion,\n): boolean {\n  return gtSemver(version1, version2);\n}\n\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nexport function gtRange(version: SemVerVersion, range: SemVerRange): boolean {\n  return gtrSemver(version, range);\n}\n\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nexport function satisfiesVersionRange(\n  version: SemVerVersion,\n  versionRange: SemVerRange,\n): boolean {\n  return satisfiesSemver(version, versionRange, {\n    includePrerelease: true,\n  });\n}\n", "import type {\n  Json,\n  JsonRpcError as SerializedJsonRpcError,\n  RuntimeObject,\n} from '@metamask/utils';\nimport {\n  hasProperty,\n  isValidJson,\n  isObject,\n  isJsonRpcError,\n} from '@metamask/utils';\n\nimport { errorCodes, errorValues } from './error-constants';\n\n/**\n * A data object, that must be either:\n *\n * - A JSON-serializable object.\n * - An object with a `cause` property that is an error-like value, and any\n * other properties that are JSON-serializable.\n */\nexport type DataWithOptionalCause =\n  | Json\n  | {\n      // Unfortunately we can't use just `Json` here, because all properties of\n      // an object with an index signature must be assignable to the index\n      // signature's type. So we have to use `Json | unknown` instead.\n      [key: string]: Json | unknown;\n      cause?: unknown;\n    };\n\n/**\n * A data object, that must be either:\n *\n * - A valid DataWithOptionalCause value.\n * - undefined.\n */\nexport type OptionalDataWithOptionalCause = undefined | DataWithOptionalCause;\n\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE =\n  'Unspecified error message. This is a bug, please report it.';\nconst FALLBACK_ERROR: SerializedJsonRpcError = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE),\n};\n\nexport const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n\ntype ErrorValueKey = keyof typeof errorValues;\n\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */\nexport function getMessageFromCode(\n  code: unknown,\n  fallbackMessage: string = FALLBACK_MESSAGE,\n): string {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString as ErrorValueKey].message;\n    }\n\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\n\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */\nexport function isValidCode(code: unknown): code is number {\n  return Number.isInteger(code);\n}\n\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */\nexport function serializeError(\n  error: unknown,\n  { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {},\n): SerializedJsonRpcError {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\n      'Must provide fallback error with integer number code and string message.',\n    );\n  }\n\n  const serialized = buildError(error, fallbackError);\n\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n\n  return serialized;\n}\n\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */\nfunction buildError(\n  error: unknown,\n  fallbackError: SerializedJsonRpcError,\n): SerializedJsonRpcError {\n  // If an error specifies a `serialize` function, we call it and return the result.\n  if (\n    error &&\n    typeof error === 'object' &&\n    'serialize' in error &&\n    typeof error.serialize === 'function'\n  ) {\n    return error.serialize();\n  }\n\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n\n  // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    data: { cause },\n  };\n\n  return fallbackWithCause;\n}\n\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */\nfunction isJsonRpcServerError(code: number): boolean {\n  return code >= -32099 && code <= -32000;\n}\n\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */\nexport function serializeCause(error: unknown): Json {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject(error)) {\n    return serializeObject(error);\n  }\n\n  if (isValidJson(error)) {\n    return error;\n  }\n\n  return null;\n}\n\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */\nfunction serializeObject(object: RuntimeObject): Json {\n  return Object.getOwnPropertyNames(object).reduce<Record<string, Json>>(\n    (acc, key) => {\n      const value = object[key];\n      if (isValidJson(value)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {},\n  );\n}\n\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */\nexport function dataHasCause(data: unknown): data is {\n  [key: string]: Json | unknown;\n  cause: object;\n} {\n  return isObject(data) && hasProperty(data, 'cause') && isObject(data.cause);\n}\n", "import type {\n  Json,\n  JsonRpcError as SerializedJsonRpcError,\n} from '@metamask/utils';\nimport { hasProperty, isPlainObject } from '@metamask/utils';\nimport safeStringify from 'fast-safe-stringify';\n\nimport type { OptionalDataWithOptionalCause } from './utils';\nimport { dataHasCause, serializeCause } from './utils';\n\nexport type { SerializedJsonRpcError };\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */\nexport class JsonRpcError<\n  Data extends OptionalDataWithOptionalCause,\n> extends Error {\n  // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n  public cause?: unknown;\n\n  public code: number;\n\n  public data?: Data;\n\n  constructor(code: number, message: string, data?: Data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n\n    if (dataHasCause(data)) {\n      // @ts-expect-error - Error class does accept options argument depending on runtime, but types are mapping to oldest supported\n      super(message, { cause: data.cause });\n\n      // Browser backwards-compatibility fallback\n      if (!hasProperty(this, 'cause')) {\n        Object.assign(this, { cause: data.cause });\n      }\n    } else {\n      super(message);\n    }\n\n    if (data !== undefined) {\n      this.data = data;\n    }\n\n    this.code = code;\n  }\n\n  /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */\n  serialize(): SerializedJsonRpcError {\n    const serialized: SerializedJsonRpcError = {\n      code: this.code,\n      message: this.message,\n    };\n\n    if (this.data !== undefined) {\n      // `this.data` is not guaranteed to be a plain object, but this simplifies\n      // the type guard below. We can safely cast it because we know it's a\n      // JSON-serializable value.\n      serialized.data = this.data as { [key: string]: Json };\n\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */\n  toString(): string {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n}\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nexport class EthereumProviderError<\n  Data extends OptionalDataWithOptionalCause,\n> extends JsonRpcError<Data> {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */\n  constructor(code: number, message: string, data?: Data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error(\n        '\"code\" must be an integer such that: 1000 <= code <= 4999',\n      );\n    }\n\n    super(code, message, data);\n  }\n}\n\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */\nfunction isValidEthProviderCode(code: number): boolean {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */\nfunction stringifyReplacer(_: unknown, value: unknown): unknown {\n  if (value === '[Circular]') {\n    return undefined;\n  }\n\n  return value;\n}\n", "import { JsonRpcError, EthereumProviderError } from './classes';\nimport { errorCodes } from './error-constants';\nimport type { OptionalDataWithOptionalCause } from './utils';\nimport { getMessageFromCode } from './utils';\n\ntype EthereumErrorOptions<Data extends OptionalDataWithOptionalCause> = {\n  message?: string;\n  data?: Data;\n};\n\ntype ServerErrorOptions<Data extends OptionalDataWithOptionalCause> = {\n  code: number;\n} & EthereumErrorOptions<Data>;\n\ntype CustomErrorArg<Data extends OptionalDataWithOptionalCause> =\n  ServerErrorOptions<Data>;\n\ntype JsonRpcErrorsArg<Data extends OptionalDataWithOptionalCause> =\n  | EthereumErrorOptions<Data>\n  | string;\n\nexport const rpcErrors = {\n  /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  parse: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.parse, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidRequest: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidParams: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotFound: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  internal: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.internal, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  server: <Data extends OptionalDataWithOptionalCause>(\n    opts: ServerErrorOptions<Data>,\n  ) => {\n    if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n      throw new Error(\n        'Ethereum RPC Server errors must provide single object argument.',\n      );\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error(\n        '\"code\" must be an integer such that: -32099 <= code <= -32005',\n      );\n    }\n    return getJsonRpcError(code, opts);\n  },\n\n  /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidInput: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceNotFound: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceUnavailable: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  transactionRejected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotSupported: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  limitExceeded: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg),\n};\n\nexport const providerErrors = {\n  /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  userRejectedRequest: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unauthorized: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unsupportedMethod: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  disconnected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  chainDisconnected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n\n  /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  custom: <Data extends OptionalDataWithOptionalCause>(\n    opts: CustomErrorArg<Data>,\n  ) => {\n    if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n      throw new Error(\n        'Ethereum Provider custom errors must provide single object argument.',\n      );\n    }\n\n    const { code, message, data } = opts;\n\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  },\n};\n\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */\nfunction getJsonRpcError<Data extends OptionalDataWithOptionalCause>(\n  code: number,\n  arg?: JsonRpcErrorsArg<Data>,\n): JsonRpcError<Data> {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\n\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */\nfunction getEthProviderError<Data extends OptionalDataWithOptionalCause>(\n  code: number,\n  arg?: JsonRpcErrorsArg<Data>,\n): EthereumProviderError<Data> {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(\n    code,\n    message ?? getMessageFromCode(code),\n    data,\n  );\n}\n\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */\nfunction parseOpts<Data extends OptionalDataWithOptionalCause>(\n  arg?: JsonRpcErrorsArg<Data>,\n): [message?: string | undefined, data?: Data | undefined] {\n  if (arg) {\n    if (typeof arg === 'string') {\n      return [arg];\n    } else if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const { message, data } = arg;\n\n      if (message && typeof message !== 'string') {\n        throw new Error('Must specify string message.');\n      }\n      return [message ?? undefined, data];\n    }\n  }\n\n  return [];\n}\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Torus from '@toruslabs/torus-embed';\nimport { WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, log, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\n\nclass TorusWalletAdapter extends BaseEvmAdapter {\n  constructor(params = {}) {\n    super(params);\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.TORUS_EVM);\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n    _defineProperty(this, \"torusInstance\", null);\n    _defineProperty(this, \"torusWalletOptions\", void 0);\n    _defineProperty(this, \"initParams\", void 0);\n    _defineProperty(this, \"loginSettings\", {});\n    this.torusWalletOptions = params.adapterSettings || {};\n    this.initParams = params.initParams || {};\n    this.loginSettings = params.loginSettings || {};\n  }\n  get provider() {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.torusInstance) {\n      return this.torusInstance.provider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options = {}) {\n    await super.init(options);\n    super.checkInitializationRequirements();\n    const {\n      chainId,\n      blockExplorerUrl,\n      displayName,\n      rpcTarget,\n      ticker,\n      tickerName\n    } = this.chainConfig;\n    const network = {\n      chainId: Number.parseInt(chainId, 16),\n      host: rpcTarget,\n      blockExplorer: blockExplorerUrl,\n      networkName: displayName,\n      ticker,\n      tickerName\n      // decimals: decimals || 18,\n    };\n    this.torusInstance = new Torus(this.torusWalletOptions);\n    log.debug(\"initializing torus evm adapter init\");\n    await this.torusInstance.init(_objectSpread(_objectSpread({\n      showTorusButton: false\n    }, this.initParams), {}, {\n      network\n    }));\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.TORUS_EVM);\n    try {\n      log.debug(\"initializing torus evm adapter\");\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with torus evm provider\", error);\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\n      adapter: WALLET_ADAPTERS.TORUS_EVM\n    });\n    try {\n      await this.torusInstance.login(this.loginSettings);\n      const chainId = await this.torusInstance.provider.request({\n        method: \"eth_chainId\"\n      });\n      if (chainId && parseInt(chainId) !== parseInt(this.chainConfig.chainId, 16)) {\n        const {\n          chainId: _chainId,\n          blockExplorerUrl,\n          displayName,\n          rpcTarget,\n          ticker,\n          tickerName\n        } = this.chainConfig;\n        const network = {\n          chainId: Number.parseInt(_chainId, 16),\n          host: rpcTarget,\n          blockExplorer: blockExplorerUrl,\n          networkName: displayName,\n          tickerName,\n          ticker\n        };\n        // in some cases when user manually switches chain and relogin then adapter will not connect to initially passed\n        // chainConfig but will connect to the one that user switched to.\n        // So here trying to switch network to the one that was initially passed in chainConfig.\n        await this.torusInstance.setProvider(_objectSpread({}, network));\n        const updatedChainID = await this.torusInstance.ethereum.request({\n          method: \"eth_chainId\"\n        });\n        if (updatedChainID && parseInt(updatedChainID) !== parseInt(this.chainConfig.chainId, 16)) {\n          throw WalletInitializationError.fromCode(5000, `Not connected to correct chainId. Expected: ${this.chainConfig.chainId}, Current: ${updatedChainID}`);\n        }\n      }\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.torusInstance.showTorusButton();\n      this.emit(ADAPTER_STATUS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.TORUS_EVM,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_STATUS.ERRORED, error);\n      throw error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with torus wallet\", error);\n    }\n  }\n  async disconnect(options = {\n    cleanup: false\n  }) {\n    await super.disconnectSession();\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    await this.torusInstance.logout();\n    this.torusInstance.hideTorusButton();\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.torusInstance = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n    await super.disconnect();\n  }\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    const userInfo = await this.torusInstance.getUserInfo(\"\");\n    return userInfo;\n  }\n  async addChain(chainConfig, init = false) {\n    super.checkAddChainRequirements(chainConfig, init);\n    // TODO: add these in torus wallet.\n    // await this.torusInstance?.provider.request({\n    //   method: \"wallet_addEthereumChain\",\n    //   params: [\n    //     {\n    //       chainId: chainConfig.chainId,\n    //       chainName: chainConfig.displayName,\n    //       rpcUrls: [chainConfig.rpcTarget],\n    //       blockExplorerUrls: [chainConfig.blockExplorer],\n    //       nativeCurrency: {\n    //         name: chainConfig.tickerName,\n    //         symbol: chainConfig.ticker,\n    //         decimals: chainConfig.decimals || 18,\n    //       },\n    //     },\n    //   ],\n    // });\n    this.addChainConfig(chainConfig);\n  }\n  async switchChain(params, init = false) {\n    var _this$torusInstance;\n    super.checkSwitchChainRequirements(params, init);\n    // TODO: add these in torus wallet.\n    // await this.torusInstance?.provider.request({\n    //   method: \"wallet_switchEthereumChain\",\n    //   params: [{ chainId: params.chainId }],\n    // });\n    const chainConfig = this.getChainConfig(params.chainId);\n    await ((_this$torusInstance = this.torusInstance) === null || _this$torusInstance === void 0 ? void 0 : _this$torusInstance.setProvider({\n      host: chainConfig.rpcTarget,\n      chainId: parseInt(chainConfig.chainId, 16),\n      networkName: chainConfig.displayName,\n      blockExplorer: chainConfig.blockExplorerUrl,\n      ticker: chainConfig.ticker,\n      tickerName: chainConfig.tickerName\n    }));\n    this.setAdapterSettings({\n      chainConfig: this.getChainConfig(params.chainId)\n    });\n  }\n  async enableMFA() {\n    throw new Error(\"Method Not implemented\");\n  }\n}\n\nexport { TorusWalletAdapter };\n"],
  "mappings": "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",
  "names": ["type", "coerce", "mask", "type", "Element", "size", "isObject", "JsonSize", "isPlainObject", "assert", "assert", "alphabet", "padding", "mask", "base64", "assert", "isBytes", "assert", "KnownCaipNamespace", "object", "object", "object", "debug", "Duration", "isObject", "object", "isPlainObject", "safeStringify", "loglevel", "pump", "dequal", "window", "document", "deepmerge", "size"]
}
