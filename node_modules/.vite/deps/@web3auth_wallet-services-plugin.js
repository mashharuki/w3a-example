import {
  require_fast_deep_equal
} from "./chunk-JNRJT5DQ.js";
import {
  Interface
} from "./chunk-3YXMPSLU.js";
import {
  require_bn,
  require_dist
} from "./chunk-NPEP3W7F.js";
import "./chunk-WPDCR5GE.js";
import {
  CHAIN_NAMESPACES,
  COMMUNICATION_JRPC_METHODS,
  COMMUNICATION_NOTIFICATIONS,
  CONFIRMATION_STRATEGY,
  FEATURES_CONFIRM_WINDOW,
  FEATURES_DEFAULT_POPUP_WINDOW,
  FEATURES_PROVIDER_CHANGE_WINDOW,
  PROVIDER_JRPC_METHODS,
  PROVIDER_NOTIFICATIONS,
  SETUP_COMPLETE,
  bignumber_default,
  createLoggerMiddleware,
  getPopupFeatures,
  randomId
} from "./chunk-EUPFMFTY.js";
import {
  addHexPrefix
} from "./chunk-K6CC7U6K.js";
import "./chunk-66NAV3HW.js";
import "./chunk-656XUC5S.js";
import "./chunk-2I7FAV7Q.js";
import "./chunk-ML3C5VKE.js";
import {
  ADAPTER_EVENTS,
  ADAPTER_STATUS,
  BasePostMessageStream,
  EVM_PLUGINS,
  EthereumProviderError,
  JRPCEngine,
  ObjectMultiplex,
  PLUGIN_EVENTS,
  PLUGIN_NAMESPACES,
  PLUGIN_STATUS,
  SafeEventEmitter,
  WALLET_ADAPTERS,
  WalletServicesPluginError,
  createIdRemapMiddleware,
  createStreamMiddleware,
  getRpcPromiseCallback,
  require_color,
  require_fast_safe_stringify,
  require_loglevel,
  require_pump,
  rpcErrors
} from "./chunk-K4C2RABW.js";
import "./chunk-GJBZJ4UL.js";
import {
  TORUS_LEGACY_NETWORK,
  TORUS_SAPPHIRE_NETWORK,
  _defineProperty,
  _objectSpread2,
  require_base64url
} from "./chunk-MBKDGBSM.js";
import "./chunk-ATDVI3CM.js";
import "./chunk-CFIX2DL5.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");

// node_modules/@toruslabs/ethereum-controllers/dist/ethereumControllers.esm.js
var import_loglevel = __toESM(require_loglevel());
var import_bn = __toESM(require_bn());
var import_eth_sig_util = __toESM(require_dist());
var import_fast_safe_stringify = __toESM(require_fast_safe_stringify());
var import_deepmerge = __toESM(require_cjs());

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k = 0; k < keys_1.length; k++) {
      keys_1[k] = "" + k;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key in args) {
    var value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(key + ": " + value);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  function(_super) {
    __extends(PatchError2, _super);
    function PatchError2(message, name, index, operation, tree) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name, index, operation, tree })) || this;
      _this.name = name;
      _this.index = index;
      _this.operation = operation;
      _this.tree = tree;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name, index, operation, tree });
      return _this;
    }
    return PatchError2;
  }(Error)
);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document2) {
    obj[key] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key, document2) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key, document2) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key, document2) {
    return { newDocument: document2, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document2) {
    this.value = obj[key];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index === void 0) {
    index = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path = operation.path || "";
    var keys = path.split("/");
    var obj = document2;
    var t = 1;
    var len = keys.length;
    var existingPathFragment = void 0;
    var key = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch.length);
  for (var i = 0, length_1 = patch.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error = validate([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function validate(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document2, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  }()
);
var ObserverInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  }()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key = oldKeys[t];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key = newKeys[t];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) {
      patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: _deepClone(obj[key]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/@toruslabs/ethereum-controllers/dist/ethereumControllers.esm.js
var erc20Abi = [{
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "decimals",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "balance",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }, {
    name: "_extraData",
    type: "bytes"
  }],
  name: "approveAndCall",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    name: "remaining",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  inputs: [{
    name: "_initialAmount",
    type: "uint256"
  }, {
    name: "_tokenName",
    type: "string"
  }, {
    name: "_decimalUnits",
    type: "uint8"
  }, {
    name: "_tokenSymbol",
    type: "string"
  }],
  type: "constructor"
}, {
  payable: false,
  type: "fallback"
}];
var erc721Abi = [{
  constant: true,
  inputs: [{
    name: "interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    type: "bool"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "_name",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_approved",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "approve",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_index",
    type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_index",
    type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "_symbol",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}];
var erc1155Abi = [{
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address[]",
    name: "_owners",
    type: "address[]"
  }, {
    internalType: "uint256[]",
    name: "_ids",
    type: "uint256[]"
  }],
  name: "balanceOfBatch",
  outputs: [{
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "address",
    name: "_operator",
    type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
    internalType: "bool",
    name: "isOperator",
    type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_from",
    type: "address"
  }, {
    internalType: "address",
    name: "_to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "_amount",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_operator",
    type: "address"
  }, {
    internalType: "bool",
    name: "_approved",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "uri",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
var MAINNET_CHAIN_ID = "0x1";
var POLYGON_CHAIN_ID = "0x89";
var BSC_MAINNET_CHAIN_ID = "0x38";
var AVALANCHE_MAINNET_CHAIN_ID = "0xa86a";
var XDAI_CHAIN_ID = "0x64";
var ARBITRUM_MAINNET_CHAIN_ID = "0xa4b1";
var OPTIMISM_MAINNET_CHAIN_ID = "0xa";
var CELO_MAINNET_CHAIN_ID = "0xa4ec";
var BASE_CHAIN_ID = "0x2105";
var SEPOLIA_CHAIN_ID = "0xaa36a7";
var POLYGON_AMOY_CHAIN_ID = "0x13882";
var BSC_TESTNET_CHAIN_ID = "0x61";
var AVALANCHE_TESTNET_CHAIN_ID = "0xa869";
var ARBITRUM_TESTNET_CHAIN_ID = "0x66eee";
var OPTIMISM_TESTNET_CHAIN_ID = "0xaa37dc";
var BASE_TESTNET_CHAIN_ID = "0x14a34";
var INFURA_KEY = process.env.VITE_APP_INFURA_PROJECT_KEY;
var SUPPORTED_NETWORKS = {
  [MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://etherscan.io",
    chainId: MAINNET_CHAIN_ID,
    displayName: "Ethereum",
    logo: "eth.svg",
    rpcTarget: `https://mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [POLYGON_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://polygonscan.com",
    chainId: POLYGON_CHAIN_ID,
    displayName: "Polygon",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://bscscan.com",
    chainId: BSC_MAINNET_CHAIN_ID,
    displayName: "Binance Smart Chain (BSC)",
    logo: "bnb_logo.svg",
    rpcTarget: `https://bsc-dataseed.binance.org`,
    ticker: "BNB",
    tickerName: "Binance Coin"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://snowtrace.io",
    chainId: AVALANCHE_MAINNET_CHAIN_ID,
    displayName: "Avalanche",
    logo: "avax.svg",
    rpcTarget: `https://api.avax.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://optimistic.etherscan.io",
    chainId: OPTIMISM_MAINNET_CHAIN_ID,
    displayName: "Optimism",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://explorer.celo.org",
    chainId: CELO_MAINNET_CHAIN_ID,
    displayName: "Celo Mainnet",
    logo: "celo.svg",
    rpcTarget: `https://celo-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "CELO",
    tickerName: "Celo"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://arbiscan.io",
    chainId: ARBITRUM_MAINNET_CHAIN_ID,
    displayName: "Arbitrum One",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [XDAI_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://gnosis.blockscout.com",
    chainId: XDAI_CHAIN_ID,
    displayName: "xDai",
    logo: "xDai.svg",
    rpcTarget: `https://rpc.gnosischain.com`,
    ticker: "DAI",
    tickerName: "xDai Token"
  },
  [BASE_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://basescan.org",
    chainId: BASE_CHAIN_ID,
    displayName: "Base",
    logo: "base.svg",
    rpcTarget: `https://mainnet.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [SEPOLIA_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.etherscan.io",
    chainId: SEPOLIA_CHAIN_ID,
    displayName: "Sepolia Test Network",
    logo: "eth.svg",
    rpcTarget: `https://sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [POLYGON_AMOY_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://amoy.polygonscan.com",
    chainId: POLYGON_AMOY_CHAIN_ID,
    displayName: "Polygon Amoy",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-amoy.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token",
    isTestnet: true
  },
  [BSC_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.bscscan.com",
    chainId: BSC_TESTNET_CHAIN_ID,
    displayName: "Binance Smart Chain Testnet",
    logo: "bnb_logo.svg",
    rpcTarget: `https://data-seed-prebsc-1-s1.binance.org:8545`,
    ticker: "BNB",
    tickerName: "Binance Coin",
    isTestnet: true
  },
  [AVALANCHE_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.snowtrace.io",
    chainId: AVALANCHE_TESTNET_CHAIN_ID,
    displayName: "Avalanche Testnet C-Chain",
    logo: "avax.svg",
    rpcTarget: `https://api.avax-test.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche",
    isTestnet: true
  },
  [ARBITRUM_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.arbiscan.io",
    chainId: ARBITRUM_TESTNET_CHAIN_ID,
    displayName: "Arbitrum Sepolia",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [OPTIMISM_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia-optimistic.etherscan.io",
    chainId: OPTIMISM_TESTNET_CHAIN_ID,
    displayName: "Optimism Sepolia",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [BASE_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.basescan.org",
    chainId: BASE_TESTNET_CHAIN_ID,
    displayName: "Base Sepolia",
    logo: "base.svg",
    rpcTarget: `https://sepolia.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  }
};
var METHOD_TYPES = {
  GET_ACCOUNTS: "eth_accounts",
  ETH_TRANSACTION: "eth_sendTransaction",
  ETH_REQUEST_ACCOUNTS: "eth_requestAccounts",
  ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  PERSONAL_SIGN: "personal_sign",
  ETH_GET_TRANSACTION_COUNT: "eth_getTransactionCount",
  ETH_GET_TRANSACTION_BY_HASH: "eth_getTransactionByHash",
  ETH_GET_ENCRYPTION_PUBLIC_KEY: "eth_getEncryptionPublicKey",
  ETH_DECRYPT: "eth_decrypt",
  ETH_GET_TRANSACTION_RECEIPT: "eth_getTransactionReceipt",
  WATCH_ASSET: "wallet_watchAsset",
  ETH_GET_BLOCK_BY_HASH: "eth_getBlockByHash",
  ETH_GET_CODE: "eth_getCode",
  ETH_GET_GAS_PRICE: "eth_gasPrice",
  SWITCH_CHAIN: "wallet_switchEthereumChain",
  ADD_CHAIN: "wallet_addEthereumChain"
};
var CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [OPTIMISM_MAINNET_CHAIN_ID]: 1,
  [OPTIMISM_TESTNET_CHAIN_ID]: 1
};
var COINGECKO_PLATFORMS_CHAIN_CODE_MAP = {
  [POLYGON_CHAIN_ID]: {
    platform: "polygon-pos",
    currency: "matic"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    platform: "binance-smart-chain",
    currency: "bnb"
  },
  [MAINNET_CHAIN_ID]: {
    platform: "ethereum",
    currency: "eth"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    platform: "arbitrum-one",
    currency: "eth"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    platform: "optimistic-ethereum",
    currency: "eth"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    platform: "celo",
    currency: "celo"
  },
  [XDAI_CHAIN_ID]: {
    platform: "xdai",
    currency: "xDAI"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    platform: "avalanche",
    currency: "avax"
  },
  [BASE_CHAIN_ID]: {
    platform: "base",
    currency: "eth"
  }
};
var SINGLE_CALL_BALANCES_ADDRESSES = {
  [MAINNET_CHAIN_ID]: "0xb1f8e55c7f64d203c1400b9d8555d050f94adf39",
  // [SEPOLIA_CHAIN_ID]: SINGLE_CALL_BALANCES_ADDRESS_SEPOLIA,
  // [FANTOM_CHAIN_ID]: "0x07f697424ABe762bB808c109860c04eA488ff92B",
  [BSC_MAINNET_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [OPTIMISM_MAINNET_CHAIN_ID]: "0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC",
  [POLYGON_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [AVALANCHE_MAINNET_CHAIN_ID]: "0xD023D153a0DFa485130ECFdE2FAA7e612EF94818",
  [ARBITRUM_MAINNET_CHAIN_ID]: "0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c"
};
var erc20Interface = new Interface(erc20Abi);
var erc721Interface = new Interface(erc721Abi);
var erc1155Interface = new Interface(erc1155Abi);
var idleTimeTracker = ((activityThresholdTime) => {
  let isIdle = false;
  let idleTimeout = null;
  const resetTimer = () => {
    if (idleTimeout) {
      window.clearTimeout(idleTimeout);
    }
    isIdle = false;
    idleTimeout = window.setTimeout(() => {
      isIdle = true;
    }, activityThresholdTime * 1e3);
  };
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    window.addEventListener("load", resetTimer);
    document.addEventListener("mousemove", resetTimer);
    document.addEventListener("keydown", resetTimer);
  }
  function checkIfIdle() {
    return isIdle;
  }
  return {
    checkIfIdle
  };
})(60 * 3);
var GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: addHexPrefix(21e3.toString(16)),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: addHexPrefix(1e5.toString(16))
};
var BIG_NUMBER_WEI_MULTIPLIER = new bignumber_default("1000000000000000000");
var BIG_NUMBER_GWEI_MULTIPLIER = new bignumber_default("1000000000");
var BIG_NUMBER_ETH_MULTIPLIER = new bignumber_default("1");
var CacheStrategy = function(CacheStrategy2) {
  CacheStrategy2["Block"] = "block";
  CacheStrategy2["Fork"] = "fork";
  CacheStrategy2["Never"] = "never";
  CacheStrategy2["Permanent"] = "perma";
  return CacheStrategy2;
}({});
var DEFAULT_INTERVAL$1 = 180 * 1e3;
var DEFAULT_INTERVAL = 180 * 1e3;

// node_modules/@web3auth/ws-embed/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_base64url = __toESM(require_base64url());
var import_color = __toESM(require_color());
function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (err) {
    const error = err;
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededError" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
var MemoryStore = class {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(key) {
    return this.store.get(key) || null;
  }
  setItem(key, value) {
    this.store.set(key, value);
  }
  removeItem(key) {
    this.store.delete(key);
  }
};
var BrowserStorage = class {
  constructor(storeKey, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey;
    try {
      if (!storage.getItem(storeKey)) {
        this.resetStore();
      }
    } catch (error) {
    }
  }
  static getInstance(key) {
    let storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(key)) {
      let storage;
      if (storageKey === "local" && storageAvailable("localStorage")) {
        storage = window.localStorage;
      } else if (storageKey === "session" && storageAvailable("sessionStorage")) {
        storage = window.sessionStorage;
      } else {
        storage = new MemoryStore();
      }
      this.instanceMap.set(key, new this(key, storage));
    }
    return this.instanceMap.get(key);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const currStore = this.getStore();
    this.storage.removeItem(this._storeKey);
    return currStore;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(key) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  set(key, value) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
var OPENLOGIN_NETWORK = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);
var THEME_MODES = {
  light: "light",
  dark: "dark",
  auto: "auto"
};

// node_modules/@web3auth/ws-embed/dist/embed.esm.js
var import_pump = __toESM(require_pump());
var import_loglevel2 = __toESM(require_loglevel());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
  return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
  return isWritableStream(stream) && isReadableStream(stream);
}
var messages = {
  errors: {
    disconnected: () => "Web3Auth: Lost connection to Web3Auth.",
    permanentlyDisconnected: () => "Web3Auth: Disconnected from iframe. Page reload required.",
    unsupportedSync: (method) => `Web3Auth: The Web3Auth Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidOptions: (maxEventListeners) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
    invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`
  },
  info: {
    connected: (chainId) => `Web3Auth: Connected to chain with ID "${chainId}".`
  },
  warnings: {}
};
var log2 = import_loglevel2.default.getLogger("ws-embed");
function createErrorMiddleware() {
  return (req, res, next) => {
    if (typeof req.method !== "string" || !req.method) {
      res.error = rpcErrors.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: _objectSpread2(_objectSpread2({}, req || {}), {}, {
          cause: `The request 'method' must be a non-empty string.`
        })
      });
    }
    next((done) => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      log2.error(`Ws-Embed - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Web3Auth: Lost connection to "${remoteLabel}".`;
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += `
${error.stack}`;
  }
  log2.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
var EMITTED_NOTIFICATIONS = [
  "eth_subscription"
  // per eth-json-rpc-filters/subscriptionManager
];
var BaseProvider = class extends SafeEventEmitter {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super();
    _defineProperty(this, "rpcEngine", void 0);
    _defineProperty(this, "jsonRpcConnectionEvents", void 0);
    _defineProperty(this, "isWeb3Auth", void 0);
    _defineProperty(this, "state", void 0);
    if (!isDuplexStream(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }
    this.isWeb3Auth = true;
    this.setMaxListeners(maxEventListeners);
    this.handleConnect = this.handleConnect.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
    this.handleStreamDisconnect = this.handleStreamDisconnect.bind(this);
    this.rpcRequest = this.rpcRequest.bind(this);
    this.initializeState = this.initializeState.bind(this);
    this.request = this.request.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.send = this.send.bind(this);
    const mux = new ObjectMultiplex();
    (0, import_pump.default)(connectionStream, mux, connectionStream, this.handleStreamDisconnect.bind(this, "Web3Auth"));
    mux.ignoreStream("phishing");
    const jsonRpcConnection = createStreamMiddleware();
    (0, import_pump.default)(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this.handleStreamDisconnect.bind(this, "Web3Auth RpcProvider"));
    const rpcEngine = new JRPCEngine();
    rpcEngine.push(createIdRemapMiddleware());
    rpcEngine.push(createErrorMiddleware());
    rpcEngine.push(createLoggerMiddleware({
      origin: location.origin
    }));
    rpcEngine.push(jsonRpcConnection.middleware);
    this.rpcEngine = rpcEngine;
    this.jsonRpcConnectionEvents = jsonRpcConnection.events;
  }
  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   *
   * @param args - The RPC request arguments.
   * @returns A Promise that resolves with the result of the RPC method,
   * or rejects if an error is encountered.
   */
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestArgs(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestMethod(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestParams(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    return new Promise((resolve, reject) => {
      this.rpcRequest({
        method,
        params
      }, getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  send(payload, callback) {
    this.rpcRequest(payload, callback);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  sendAsync(payload) {
    return new Promise((resolve, reject) => {
      this.rpcRequest(payload, getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * emits InpageProvider#disconnect
   */
  handleStreamDisconnect(streamName, error) {
    logStreamDisconnectWarning(streamName, error, this);
    this.handleDisconnect(false, error ? error.message : void 0);
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits InPageProvider#connect
   */
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits InpageProvider#disconnect
   */
};
var WS_EMBED_BUILD_ENV = {
  PRODUCTION: "production",
  STAGING: "staging",
  DEVELOPMENT: "development",
  TESTING: "testing"
};
var BUTTON_POSITION = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
};
var PopupHandler = class extends SafeEventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 3e4
  }) {
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
    this.window = void 0;
    this.windowTimer = void 0;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = void 0;
        }, this.timeout);
      }
      if (this.window === void 0) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url.href, this.target, this.features);
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
};
var CommunicationProvider = class _CommunicationProvider extends BaseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }, state) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "tryWindowHandle", void 0);
    _defineProperty(this, "windowRefs", void 0);
    _defineProperty(this, "iframeUrl", void 0);
    _defineProperty(this, "iframeId", void 0);
    this.state = _objectSpread2(_objectSpread2({}, _CommunicationProvider.defaultState), state);
    this.iframeUrl = "";
    this.iframeId = "";
    this.windowRefs = /* @__PURE__ */ new Map();
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const notificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
        const {
          isFullScreen,
          rid
        } = params;
        this.displayIframe({
          isFull: isFullScreen,
          rid
        });
      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
        this.handleCloseWindow(params);
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
        const {
          currentLoginProvider
        } = params;
        this.state.isLoggedIn = true;
        this.state.currentLoginProvider = currentLoginProvider;
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
        this.state.isLoggedIn = false;
        this.state.currentLoginProvider = null;
        this.displayIframe();
      }
    };
    this.jsonRpcConnectionEvents.on("notification", notificationHandler);
  }
  get isLoggedIn() {
    return this.state.isLoggedIn;
  }
  get isIFrameFullScreen() {
    return this.state.isIFrameFullScreen;
  }
  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }
  async initializeState(params) {
    try {
      const {
        torusUrl,
        torusIframeId
      } = params;
      this.iframeUrl = torusUrl;
      this.iframeId = torusIframeId;
      const {
        currentLoginProvider,
        isLoggedIn
      } = await this.request({
        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      if (isLoggedIn) this.handleConnect(currentLoginProvider, isLoggedIn);
    } catch (error) {
      log2.error("Web3Auth: Failed to get initial state. Please report this bug.", error);
    } finally {
      log2.info("initialized communication state");
      this.state.initialized = true;
      this.emit("_initialized");
    }
  }
  hideTorusButton() {
    this.state.widgetVisibility = false;
    this.displayIframe();
  }
  showTorusButton() {
    this.state.widgetVisibility = true;
    this.displayIframe();
  }
  displayIframe({
    isFull = false,
    rid = ""
  } = {}) {
    const style = {};
    if (!isFull) {
      style.display = this.state.widgetVisibility ? "block" : "none";
      style.height = "70px";
      style.width = "70px";
      switch (this.state.buttonPosition) {
        case BUTTON_POSITION.TOP_LEFT:
          style.top = "0px";
          style.left = "0px";
          style.right = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.TOP_RIGHT:
          style.top = "0px";
          style.right = "0px";
          style.left = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_RIGHT:
          style.bottom = "0px";
          style.right = "0px";
          style.top = "auto";
          style.left = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_LEFT:
        default:
          style.bottom = "0px";
          style.left = "0px";
          style.top = "auto";
          style.right = "auto";
          break;
      }
    } else {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      style.top = "0px";
      style.right = "0px";
      style.left = "0px";
      style.bottom = "0px";
    }
    const iframe = document.getElementById(this.iframeId);
    Object.assign(iframe.style, style);
    this.state.isIFrameFullScreen = isFull;
    this.request({
      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
      params: {
        isIFrameFullScreen: isFull,
        rid
      }
    });
  }
  /**
   * Scenarios:
   * - Login request or pre-open confirmation windows
   * We try to open here or send a rpc request to iframe that window is blocked.
   */
  async handleWindow(windowId, {
    url,
    target,
    features,
    timeout
  } = {}) {
    const finalUrl = new URL(url || `${this.iframeUrl}/redirect?windowId=${windowId}&sessionNamespace=${window.location.hostname}`);
    const handledWindow = new PopupHandler({
      url: finalUrl,
      target,
      features,
      timeout
    });
    handledWindow.open();
    if (!handledWindow.window) {
      this.displayIframe({
        isFull: true
      });
      this.request({
        method: COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED,
        params: {
          windowId,
          finalUrl: finalUrl.href
        }
      });
      return;
    }
    this.windowRefs.set(windowId, handledWindow);
    handledWindow.once("close", () => {
      this.windowRefs.delete(windowId);
      this.request({
        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
        params: {
          windowId
        }
      });
    });
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback) {
    const cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
    }
    this.rpcEngine.handle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  handleConnect(currentLoginProvider, isLoggedIn) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        currentLoginProvider,
        isLoggedIn
      });
      log2.debug(messages.info.connected(currentLoginProvider));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new EthereumProviderError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log2.debug(error);
      } else {
        error = new EthereumProviderError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log2.error(error);
        this.state.currentLoginProvider = null;
        this.state.isLoggedIn = false;
        this.state.widgetVisibility = false;
        this.state.isIFrameFullScreen = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  handleCloseWindow(params) {
    const {
      windowId
    } = params;
    if (this.windowRefs.has(windowId)) {
      this.windowRefs.get(windowId).close();
      this.windowRefs.delete(windowId);
    }
  }
};
_defineProperty(CommunicationProvider, "defaultState", {
  buttonPosition: "bottom-left",
  currentLoginProvider: null,
  isIFrameFullScreen: false,
  widgetVisibility: false,
  initialized: false,
  isLoggedIn: false,
  isPermanentlyDisconnected: false,
  isConnected: false,
  hasEmittedConnection: false
});
var htmlToElement = (html) => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim();
  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
var TorusInPageProvider = class _TorusInPageProvider extends BaseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "selectedAddress", void 0);
    _defineProperty(this, "tryWindowHandle", void 0);
    this.state = _objectSpread2({}, _TorusInPageProvider.defaultState);
    this.selectedAddress = null;
    this.chainId = null;
    this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
    this.handleChainChanged = this.handleChainChanged.bind(this);
    this.handleUnlockStateChanged = this.handleUnlockStateChanged.bind(this);
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const jsonRpcNotificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {
        this.handleAccountsChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {
        this.handleUnlockStateChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {
        this.handleChainChanged(params);
      } else if (EMITTED_NOTIFICATIONS.includes(method)) {
        this.emit("data", payload);
        this.emit("notification", params.result);
        this.emit("message", {
          type: method,
          data: params
        });
      }
    };
    this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
  }
  /**
   * Returns whether the inpage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  async initializeState() {
    try {
      const {
        accounts,
        chainId,
        isUnlocked
      } = await this.request({
        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      this.emit("connect", {
        chainId
      });
      this.handleChainChanged({
        chainId
      });
      this.handleUnlockStateChanged({
        accounts,
        isUnlocked
      });
      this.handleAccountsChanged(accounts);
    } catch (error) {
      log2.error("WsEmbed: Failed to get initial state. Please report this bug.", error);
    } finally {
      log2.info("initialized provider state");
      this.state.initialized = true;
      this.emit("_initialized");
    }
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback, isInternal = false) {
    let cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
      if (_payload.method === "eth_accounts" || _payload.method === "eth_requestAccounts") {
        cb = (err, res) => {
          this.handleAccountsChanged(res.result || [], _payload.method === "eth_accounts", isInternal);
          callback(err, res);
        };
      } else if (_payload.method === "wallet_getProviderState") {
        this.rpcEngine.handle(payload, cb);
        return;
      }
    }
    this.tryWindowHandle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */
  handleConnect(chainId) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        chainId
      });
      log2.debug(messages.info.connected(chainId));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new EthereumProviderError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log2.debug(error);
      } else {
        error = new EthereumProviderError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log2.error(error);
        this.chainId = null;
        this.state.accounts = null;
        this.selectedAddress = null;
        this.state.isUnlocked = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  /**
   * Called when accounts may have changed.
   */
  handleAccountsChanged(accounts, isEthAccounts = false, isInternal = false) {
    let finalAccounts = accounts;
    if (!Array.isArray(finalAccounts)) {
      log2.error("WsEmbed: Received non-array accounts parameter. Please report this bug.", finalAccounts);
      finalAccounts = [];
    }
    for (const account of accounts) {
      if (typeof account !== "string") {
        log2.error("WsEmbed: Received non-string account. Please report this bug.", accounts);
        finalAccounts = [];
        break;
      }
    }
    if (!(0, import_fast_deep_equal.default)(this.state.accounts, finalAccounts)) {
      if (isEthAccounts && Array.isArray(this.state.accounts) && this.state.accounts.length > 0 && !isInternal) {
        log2.error('WsEmbed: "eth_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
      }
      this.state.accounts = finalAccounts;
      this.emit("accountsChanged", finalAccounts);
    }
    if (this.selectedAddress !== finalAccounts[0]) {
      this.selectedAddress = finalAccounts[0] || null;
    }
  }
  /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */
  handleChainChanged({
    chainId
  } = {}) {
    if (!chainId) {
      log2.error("WsEmbed: Received invalid network parameters. Please report this bug.", {
        chainId
      });
      return;
    }
    if (chainId === "loading") {
      this.handleDisconnect(true);
    } else {
      this.handleConnect(chainId);
      if (chainId !== this.chainId) {
        this.chainId = chainId;
        if (this.state.initialized) {
          this.emit("chainChanged", this.chainId);
        }
      }
    }
  }
  /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */
  handleUnlockStateChanged({
    accounts,
    isUnlocked
  } = {}) {
    if (typeof isUnlocked !== "boolean") {
      log2.error("WsEmbed: Received invalid isUnlocked parameter. Please report this bug.", {
        isUnlocked
      });
      return;
    }
    if (isUnlocked !== this.state.isUnlocked) {
      this.state.isUnlocked = isUnlocked;
      this.handleAccountsChanged(accounts || []);
    }
  }
};
_defineProperty(TorusInPageProvider, "defaultState", {
  accounts: null,
  isConnected: false,
  isUnlocked: false,
  initialized: false,
  isPermanentlyDisconnected: false,
  hasEmittedConnection: false
});
function imgExists(url) {
  return new Promise((resolve, reject) => {
    try {
      const img = document.createElement("img");
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}
var getSiteName = (window2) => {
  const {
    document: document2
  } = window2;
  const siteName = document2.querySelector('head > meta[property="og:site_name"]');
  if (siteName) {
    return siteName.content;
  }
  const metaTitle = document2.querySelector('head > meta[name="title"]');
  if (metaTitle) {
    return metaTitle.content;
  }
  if (document2.title && document2.title.length > 0) {
    return document2.title;
  }
  return window2.location.hostname;
};
async function getSiteIcon(window2) {
  try {
    const {
      document: document2
    } = window2;
    let icon = document2.querySelector('head > link[rel="shortcut icon"]');
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    icon = Array.from(document2.querySelectorAll('head > link[rel="icon"]')).find((_icon) => Boolean(_icon.href));
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    return "";
  } catch (error) {
    return "";
  }
}
var getSiteMetadata = async () => ({
  name: getSiteName(window),
  icon: await getSiteIcon(window)
});
var version = "2.0.23";
var addedVersion = `v${version.split(".")[0]}`;
var WALLET_URLS_DEFAULT = {
  [WS_EMBED_BUILD_ENV.TESTING]: {
    url: "https://develop-wallet.web3auth.io",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.DEVELOPMENT]: {
    url: "http://localhost:4050",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.STAGING]: {
    url: `https://staging-wallet.web3auth.io/${addedVersion}`,
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.PRODUCTION]: {
    url: `https://wallet.web3auth.io/${addedVersion}`,
    logLevel: "error"
  }
};
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined") return;
    const torusIframeHtml = document.createElement("link");
    const {
      url: torusUrl
    } = WALLET_URLS_DEFAULT.production;
    torusIframeHtml.href = `${torusUrl}/frame`;
    torusIframeHtml.crossOrigin = "anonymous";
    torusIframeHtml.type = "text/html";
    torusIframeHtml.rel = "prefetch";
    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
      if (torusIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(torusIframeHtml);
      }
    }
  } catch (error) {
    log2.warn(error);
  }
})();
/* @__PURE__ */ new Set([COMMUNICATION_JRPC_METHODS.SET_PROVIDER]);
var PROVIDER_UNSAFE_METHODS = /* @__PURE__ */ new Set([METHOD_TYPES.ETH_DECRYPT, METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY, METHOD_TYPES.ETH_SIGN, METHOD_TYPES.ETH_SIGN_TYPED_DATA, METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3, METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, METHOD_TYPES.PERSONAL_SIGN, METHOD_TYPES.ETH_TRANSACTION, METHOD_TYPES.ADD_CHAIN, METHOD_TYPES.SWITCH_CHAIN]);
var WsEmbed = class {
  constructor({
    modalZIndex = 99999,
    web3AuthClientId,
    web3AuthNetwork
  }) {
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "modalZIndex", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "widgetVisibility", void 0);
    _defineProperty(this, "communicationProvider", void 0);
    _defineProperty(this, "buttonPosition", void 0);
    _defineProperty(this, "web3AuthClientId", void 0);
    _defineProperty(this, "web3AuthNetwork", void 0);
    _defineProperty(this, "isPluginMode", void 0);
    _defineProperty(this, "confirmationStrategy", void 0);
    _defineProperty(this, "buildEnv", void 0);
    _defineProperty(this, "embedNonce", randomId());
    this.isInitialized = false;
    this.modalZIndex = modalZIndex;
    this.web3AuthClientId = web3AuthClientId;
    this.web3AuthNetwork = web3AuthNetwork;
  }
  get isLoggedIn() {
    var _this$communicationPr;
    return ((_this$communicationPr = this.communicationProvider) === null || _this$communicationPr === void 0 ? void 0 : _this$communicationPr.isLoggedIn) || false;
  }
  get getBuildEnv() {
    return this.buildEnv;
  }
  async init({
    buildEnv = WS_EMBED_BUILD_ENV.PRODUCTION,
    enableLogging = false,
    chainConfig,
    walletUrls,
    whiteLabel,
    confirmationStrategy = CONFIRMATION_STRATEGY.DEFAULT
  } = {}) {
    if (this.isInitialized) throw new Error("Already initialized");
    this.buildEnv = buildEnv;
    this.confirmationStrategy = confirmationStrategy;
    const {
      url: torusUrl,
      logLevel
    } = walletUrls && walletUrls[buildEnv] ? _objectSpread2(_objectSpread2({}, WALLET_URLS_DEFAULT[buildEnv]), walletUrls[buildEnv]) : WALLET_URLS_DEFAULT[buildEnv];
    log2.info(torusUrl, "url loaded");
    log2.setDefaultLevel(logLevel);
    if (enableLogging) log2.enableAll();
    else log2.disableAll();
    const torusIframeUrl = new URL(torusUrl);
    if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";
    else torusIframeUrl.pathname += "/frame";
    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);
    torusIframeUrl.hash = hashParams.toString();
    const colorScheme = this.getTheme((whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.mode) || THEME_MODES.light);
    const walletIframe = htmlToElement(`<iframe
        id="walletIframe-${this.embedNonce}"
        class="walletIframe-${this.embedNonce}"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()};
        color-scheme: ${colorScheme}"
        allow="clipboard-write"
      ></iframe>`);
    this.buttonPosition = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.buttonPosition) || BUTTON_POSITION.BOTTOM_LEFT;
    const dappMetadata = await getSiteMetadata();
    return new Promise((resolve, reject) => {
      try {
        window.document.body.appendChild(walletIframe);
        const handleMessage = async (ev) => {
          if (ev.origin !== torusIframeUrl.origin) return;
          if (ev.data === SETUP_COMPLETE) {
            window.removeEventListener("message", handleMessage);
            walletIframe.contentWindow.postMessage({
              chainConfig,
              dappMetadata,
              enableLogging,
              web3AuthClientId: this.web3AuthClientId,
              web3AuthNetwork: this.web3AuthNetwork,
              whiteLabel,
              confirmationStrategy
            }, torusIframeUrl.origin);
            await this.setupWeb3({
              torusUrl,
              walletIframe
            });
            this.widgetVisibility = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.showWidgetButton) || false;
            this.isInitialized = true;
            resolve();
          }
        };
        window.addEventListener("message", handleMessage);
      } catch (error) {
        reject(error);
      }
    });
  }
  async login(params = {}) {
    if (!this.isInitialized) throw new Error("Call init() first");
    try {
      if (!params.loginProvider) {
        this.communicationProvider.displayIframe({
          isFull: true
        });
      }
      const res = await new Promise((resolve, reject) => {
        this.provider.rpcRequest({
          method: "eth_requestAccounts",
          params: [params.loginProvider, params.login_hint]
        }, getRpcPromiseCallback(resolve, reject));
      });
      log2.info("check: res", res);
      if (Array.isArray(res) && res.length > 0) {
        if (this.widgetVisibility) this.showTorusButton();
        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.AUTO_APPROVE) log2.warn("Confirmation strategy auto approve is not allowed on Embed Mode, using Default instead.");
        return res;
      }
      throw new Error("Login failed");
    } catch (error) {
      log2.error("login failed", error);
      throw error;
    } finally {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async loginWithSessionId(params) {
    if (!this.isInitialized) throw new Error("Call init() first");
    if (!params.sessionId) throw new Error("sessionId is required");
    try {
      const res = await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID,
        params: [params.sessionId, params.sessionNamespace || ""]
      });
      log2.info("check: res", res);
      if (res.success) {
        this.isPluginMode = true;
        if (this.widgetVisibility) this.showTorusButton();
        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.POPUP) log2.warn("Confirmation strategy popup is not allowed on Plugin Mode, using Default instead.");
        return res.success;
      }
      throw new Error("Login failed");
    } catch (error) {
      log2.error("login with session id failed", error);
      throw error;
    }
  }
  async logout() {
    if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.LOGOUT,
      params: []
    });
    this.hideTorusButton();
  }
  async cleanUp() {
    var _this$communicationPr2;
    if ((_this$communicationPr2 = this.communicationProvider) !== null && _this$communicationPr2 !== void 0 && _this$communicationPr2.isLoggedIn) {
      await this.logout();
    }
    this.clearInit();
  }
  clearInit() {
    function isElement(element) {
      return element instanceof Element || element instanceof Document;
    }
    const walletIframe = window.document.getElementById(`walletIframe-${this.embedNonce}`);
    if (isElement(walletIframe)) {
      walletIframe.remove();
    }
    this.isInitialized = false;
  }
  hideTorusButton() {
    this.communicationProvider.hideTorusButton();
  }
  showTorusButton() {
    this.communicationProvider.showTorusButton();
  }
  async getUserInfo() {
    const userInfoResponse = await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.USER_INFO,
      params: []
    });
    return userInfoResponse;
  }
  async showWalletConnectScanner() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT,
      params: []
    });
  }
  async showWalletUi() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI,
      params: []
    });
  }
  async showCheckout() {
    this.communicationProvider.displayIframe({
      isFull: true
    });
    try {
      await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT,
        params: []
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  getConfirmationStrategyFinal(payload) {
    let confirmationStrategyFinal = this.confirmationStrategy;
    if (!Array.isArray(payload) && PROVIDER_UNSAFE_METHODS.has(payload.method) && this.confirmationStrategy !== CONFIRMATION_STRATEGY.MODAL && !this.isPluginMode) {
      confirmationStrategyFinal = CONFIRMATION_STRATEGY.POPUP;
    }
    return confirmationStrategyFinal;
  }
  getTheme(theme) {
    if (theme === THEME_MODES.light) return "light";
    if (theme === THEME_MODES.dark) return "dark";
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  async setupWeb3(providerParams) {
    log2.info("setupWeb3 running");
    const providerStream = new BasePostMessageStream({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });
    const communicationStream = new BasePostMessageStream({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });
    const inPageProvider = new TorusInPageProvider(providerStream, {});
    const communicationProvider = new CommunicationProvider(communicationStream, {}, {
      buttonPosition: this.buttonPosition
    });
    inPageProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW),
          timeout: 500
        });
        _payload.windowId = windowId;
      }
      inPageProvider.rpcEngine.handle(_payload, cb);
    };
    communicationProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW),
          // todo: are these features generic for all
          timeout: 500
        });
        _payload.params.windowId = windowId;
      }
      communicationProvider.rpcEngine.handle(_payload, cb);
    };
    const detectAccountRequestPrototypeModifier = (m) => {
      const originalMethod = inPageProvider[m];
      const self = this;
      inPageProvider[m] = function providerFunc(request, cb) {
        const {
          method,
          params = []
        } = request;
        if (method === "eth_requestAccounts") {
          if (!cb) return self.login({
            loginProvider: params[0]
          });
          self.login({
            loginProvider: params[0]
          }).then((res) => cb(null, res)).catch((err) => cb(err));
        }
        return originalMethod.apply(this, [request, cb]);
      };
    };
    detectAccountRequestPrototypeModifier("request");
    detectAccountRequestPrototypeModifier("sendAsync");
    detectAccountRequestPrototypeModifier("send");
    const proxiedInPageProvider = new Proxy(inPageProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    const proxiedCommunicationProvider = new Proxy(communicationProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    this.provider = proxiedInPageProvider;
    this.communicationProvider = proxiedCommunicationProvider;
    log2.info("test setupWeb3 ");
    await Promise.all([inPageProvider.initializeState(), communicationProvider.initializeState(_objectSpread2(_objectSpread2({}, providerParams), {}, {
      torusIframeId: providerParams.walletIframe.id
    }))]);
    log2.debug("WsEmbed - injected provider");
  }
};

// node_modules/@web3auth/wallet-services-plugin/dist/walletServicesPlugin.esm.js
var import_loglevel3 = __toESM(require_loglevel());
var WalletServicesPlugin = class extends SafeEventEmitter {
  constructor(options = {}) {
    super();
    _defineProperty(this, "name", EVM_PLUGINS.WALLET_SERVICES);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_ADAPTERS", [WALLET_ADAPTERS.OPENLOGIN, WALLET_ADAPTERS.SFA]);
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "wsEmbedInstance", void 0);
    _defineProperty(this, "provider", null);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "walletInitOptions", null);
    const {
      wsEmbedOpts,
      walletInitOptions
    } = options;
    this.wsEmbedInstance = new WsEmbed(wsEmbedOpts || {});
    this.walletInitOptions = walletInitOptions || {};
  }
  get proxyProvider() {
    return this.wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    var _this$web3auth$coreOp;
    if (this.isInitialized) return;
    if (!web3auth) throw WalletServicesPluginError.web3authRequired();
    if (web3auth.provider && !this.SUPPORTED_ADAPTERS.includes(web3auth.connectedAdapterName)) throw WalletServicesPluginError.notInitialized();
    if (web3auth.coreOptions.chainConfig.chainNamespace !== this.pluginNamespace) throw WalletServicesPluginError.unsupportedChainNamespace();
    if (web3auth.provider) {
      this.provider = web3auth.provider;
    }
    this.web3auth = web3auth;
    const mergedWhitelabelSettings = _objectSpread2(_objectSpread2({}, whiteLabel), this.walletInitOptions.whiteLabel || {});
    const {
      logoDark,
      logoLight
    } = mergedWhitelabelSettings || {};
    if (!logoDark || !logoLight) throw WalletServicesPluginError.invalidParams("logoDark and logoLight are required in whiteLabel config");
    this.wsEmbedInstance.web3AuthClientId = this.web3auth.coreOptions.clientId;
    this.wsEmbedInstance.web3AuthNetwork = this.web3auth.coreOptions.web3AuthNetwork;
    this.subscribeToWeb3AuthEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    if (!connectedChainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!connectedChainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!connectedChainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!connectedChainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!connectedChainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    const finalInitOptions = _objectSpread2(_objectSpread2({}, this.walletInitOptions), {}, {
      chainConfig: connectedChainConfig,
      enableLogging: (_this$web3auth$coreOp = this.web3auth.coreOptions) === null || _this$web3auth$coreOp === void 0 ? void 0 : _this$web3auth$coreOp.enableLogging,
      whiteLabel: mergedWhitelabelSettings
    });
    await this.wsEmbedInstance.init(finalInitOptions);
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  initWithProvider() {
    throw new Error("Method not implemented.");
  }
  async connect({
    sessionId,
    sessionNamespace
  }) {
    if (!this.isInitialized) throw WalletServicesPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
      }
    }
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    } else if (!this.web3auth.provider) {
      throw WalletServicesPluginError.providerRequired();
    }
    if (!sessionId) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    }
    try {
      var _this$walletInitOptio;
      await this.wsEmbedInstance.loginWithSessionId({
        sessionId,
        sessionNamespace
      });
      if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && (_this$walletInitOptio = _this$walletInitOptio.whiteLabel) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.showWidgetButton) this.wsEmbedInstance.showTorusButton();
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
      this.emit(PLUGIN_EVENTS.CONNECTED);
      this.status = PLUGIN_STATUS.CONNECTED;
    } catch (error) {
      import_loglevel3.default.error(error);
      this.status = PLUGIN_STATUS.ERRORED;
      this.emit(PLUGIN_EVENTS.ERRORED, {
        error: error.message || "Something went wrong"
      });
    }
  }
  async showWalletConnectScanner() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletConnectScanner();
  }
  async showCheckout() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showCheckout();
  }
  async showWalletUi() {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    await this.wsEmbedInstance.showWalletUi();
  }
  async disconnect() {
    if (this.wsEmbedInstance.isLoggedIn) {
      await this.wsEmbedInstance.logout();
      this.emit(PLUGIN_EVENTS.DISCONNECTED);
      this.status = PLUGIN_STATUS.DISCONNECTED;
    } else {
      throw WalletServicesPluginError.invalidSession("Wallet Services plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$wsEmbedInstance;
    (_this$wsEmbedInstance = this.wsEmbedInstance) === null || _this$wsEmbedInstance === void 0 || _this$wsEmbedInstance.provider.on("accountsChanged", (accounts = []) => {
      if (accounts.length === 0) {
        var _this$web3auth2, _this$web3auth3;
        this.wsEmbedInstance.hideTorusButton();
        if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.status) === ADAPTER_STATUS.CONNECTED) (_this$web3auth3 = this.web3auth) === null || _this$web3auth3 === void 0 || _this$web3auth3.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    provider.on("accountsChanged", (data = {
      accounts: []
    }) => {
      this.setSelectedAddress(data.accounts[0]);
    });
    provider.on("chainChanged", (chainId) => {
      this.setChainID(parseInt(chainId, 16));
    });
    provider.on("disconnect", () => {
      this.wsEmbedInstance.hideTorusButton();
    });
    provider.on("connect", () => {
      var _this$walletInitOptio2;
      if ((_this$walletInitOptio2 = this.walletInitOptions) !== null && _this$walletInitOptio2 !== void 0 && (_this$walletInitOptio2 = _this$walletInitOptio2.whiteLabel) !== null && _this$walletInitOptio2 !== void 0 && _this$walletInitOptio2.showWidgetButton) this.wsEmbedInstance.showTorusButton();
    });
  }
  subscribeToWeb3AuthEvents(web3Auth) {
    web3Auth.on(ADAPTER_EVENTS.CONNECTED, (data) => {
      this.provider = data.provider || web3Auth.provider;
      if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      if (this.wsEmbedInstance.isLoggedIn) {
        await this.wsEmbedInstance.logout();
      }
      this.wsEmbedInstance.hideTorusButton();
    });
  }
  async sessionConfig() {
    if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts,
      chainConfig
    };
  }
  async walletServicesSessionConfig() {
    if (!this.wsEmbedInstance.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId] = await Promise.all([this.wsEmbedInstance.provider.request({
      method: "eth_accounts"
    }), this.wsEmbedInstance.provider.request({
      method: "eth_chainId"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts
    };
  }
  async setSelectedAddress(address) {
    var _walletServicesSessio;
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) throw WalletServicesPluginError.web3AuthNotConnected();
    const walletServicesSessionConfig = await this.walletServicesSessionConfig();
    if (address !== ((_walletServicesSessio = walletServicesSessionConfig.accounts) === null || _walletServicesSessio === void 0 ? void 0 : _walletServicesSessio[0])) {
      throw WalletServicesPluginError.invalidSession();
    }
  }
  async setChainID(chainId) {
    const [sessionConfig, walletServicesSessionConfig] = await Promise.all([this.sessionConfig(), this.walletServicesSessionConfig()]);
    const {
      chainConfig
    } = sessionConfig || {};
    if (!chainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!chainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!chainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!chainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!chainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    if (chainId !== walletServicesSessionConfig.chainId && chainConfig) {
      try {
        var _this$wsEmbedInstance2, _this$wsEmbedInstance3;
        await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: chainConfig.chainId,
            chainName: chainConfig.displayName,
            rpcUrls: [chainConfig.rpcTarget],
            blockExplorerUrls: [chainConfig.blockExplorerUrl],
            nativeCurrency: {
              name: chainConfig.tickerName,
              symbol: chainConfig.ticker,
              decimals: chainConfig.decimals || 18
            },
            iconUrls: [chainConfig.logo]
          }]
        }).catch(() => {
          import_loglevel3.default.error("WalletServicesPlugin: Error adding chain");
        }));
        await ((_this$wsEmbedInstance3 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance3 === void 0 ? void 0 : _this$wsEmbedInstance3.request({
          method: "wallet_switchEthereumChain",
          params: [{
            chainId: chainConfig.chainId
          }]
        }));
      } catch (error) {
        import_loglevel3.default.error("WalletServicesPlugin: Error switching chain");
      }
    }
  }
};
export {
  WalletServicesPlugin
};
/*! Bundled license information:

fast-json-patch/module/helpers.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

fast-json-patch/module/duplex.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   *)
*/
//# sourceMappingURL=@web3auth_wallet-services-plugin.js.map
