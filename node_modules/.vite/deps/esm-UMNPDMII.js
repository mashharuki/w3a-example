import {
  Chain,
  Common
} from "./chunk-765BEDJH.js";
import {
  Address,
  BIGINT_0,
  BIGINT_1,
  BIGINT_2,
  BIGINT_27,
  BIGINT_8,
  MAX_INTEGER,
  MAX_UINT64,
  SECP256K1_ORDER_DIV_2,
  TypeOutput,
  bigIntToHex,
  bigIntToUnpaddedBytes,
  blobsToCommitments,
  blobsToProofs,
  bytesToBigInt,
  bytesToHex,
  commitmentsToVersionedHashes,
  computeVersionedHash,
  concatBytes,
  ecrecover,
  ecsign,
  fetchFromProvider,
  getBlobs,
  getProvider,
  hexToBytes,
  publicToAddress,
  setLengthLeft,
  toBytes,
  toType,
  unpadBytes,
  validateNoLeadingZeroes
} from "./chunk-K6CC7U6K.js";
import {
  equalsBytes,
  keccak256
} from "./chunk-656XUC5S.js";
import "./chunk-GJBZJ4UL.js";
import "./chunk-256EKJAK.js";

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/rlp/dist/esm/index.js
function encode(input) {
  if (Array.isArray(input)) {
    const output = [];
    let outputLength = 0;
    for (let i = 0; i < input.length; i++) {
      const encoded = encode(input[i]);
      output.push(encoded);
      outputLength += encoded.length;
    }
    return concatBytes2(encodeLength(outputLength, 192), ...output);
  }
  const inputBuf = toBytes2(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128) {
    return inputBuf;
  }
  return concatBytes2(encodeLength(inputBuf.length, 128), inputBuf);
}
function safeSlice(input, start, end) {
  if (end > input.length) {
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  }
  return input.slice(start, end);
}
function decodeLength(v) {
  if (v[0] === 0) {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseHexByte(bytesToHex2(v));
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Uint8Array.from([len + offset]);
  }
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes2(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (typeof input === "undefined" || input === null || input.length === 0) {
    return Uint8Array.from([]);
  }
  const inputBytes = toBytes2(input);
  const decoded = _decode(inputBytes);
  if (stream) {
    return {
      data: decoded.data,
      remainder: decoded.remainder.slice()
    };
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid RLP: remainder must be zero");
  }
  return decoded.data;
}
function _decode(input) {
  let length, llength, data, innerRemainder, d;
  const decoded = [];
  const firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.subarray(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = Uint8Array.from([]);
    } else {
      data = safeSlice(input, 1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    }
    return {
      data,
      remainder: input.subarray(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = decodeLength(safeSlice(input, 1, llength));
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = safeSlice(input, llength, length + llength);
    return {
      data,
      remainder: input.subarray(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = safeSlice(input, 1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(length)
    };
  } else {
    llength = firstByte - 246;
    length = decodeLength(safeSlice(input, 1, llength));
    if (length < 56) {
      throw new Error("invalid RLP: encoded list too short");
    }
    const totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid RLP: total length is larger than the data");
    }
    innerRemainder = safeSlice(input, llength, totalLength);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(totalLength)
    };
  }
}
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += cachedHexes[uint8a[i]];
  }
  return hex;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex.slice(j, j + 2));
  }
  return array;
}
function concatBytes2(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function utf8ToBytes(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex = integer.toString(16);
  return hex.length % 2 ? `0${hex}` : hex;
}
function padToEven(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function toBytes2(v) {
  if (v instanceof Uint8Array) {
    return v;
  }
  if (typeof v === "string") {
    if (isHexPrefixed(v)) {
      return hexToBytes2(padToEven(stripHexPrefix(v)));
    }
    return utf8ToBytes(v);
  }
  if (typeof v === "number" || typeof v === "bigint") {
    if (!v) {
      return Uint8Array.from([]);
    }
    return hexToBytes2(numberToHex(v));
  }
  if (v === null || v === void 0) {
    return Uint8Array.from([]);
  }
  throw new Error("toBytes: received unsupported type " + typeof v);
}
var RLP = { encode, decode };

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/types.js
var Capability;
(function(Capability2) {
  Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
  Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
  Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
  Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
  Capability2[Capability2["EIP7702EOACode"] = 7702] = "EIP7702EOACode";
})(Capability || (Capability = {}));
function isAccessListBytes(input) {
  if (input.length === 0) {
    return true;
  }
  const firstItem = input[0];
  if (Array.isArray(firstItem)) {
    return true;
  }
  return false;
}
function isAccessList(input) {
  return !isAccessListBytes(input);
}
function isAuthorizationListBytes(input) {
  if (input.length === 0) {
    return true;
  }
  const firstItem = input[0];
  if (Array.isArray(firstItem)) {
    return true;
  }
  return false;
}
function isAuthorizationList(input) {
  return !isAuthorizationListBytes(input);
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2[TransactionType2["Legacy"] = 0] = "Legacy";
  TransactionType2[TransactionType2["AccessListEIP2930"] = 1] = "AccessListEIP2930";
  TransactionType2[TransactionType2["FeeMarketEIP1559"] = 2] = "FeeMarketEIP1559";
  TransactionType2[TransactionType2["BlobEIP4844"] = 3] = "BlobEIP4844";
  TransactionType2[TransactionType2["EOACodeEIP7702"] = 4] = "EOACodeEIP7702";
})(TransactionType || (TransactionType = {}));
function isLegacyTx(tx) {
  return tx.type === TransactionType.Legacy;
}
function isAccessListEIP2930Tx(tx) {
  return tx.type === TransactionType.AccessListEIP2930;
}
function isFeeMarketEIP1559Tx(tx) {
  return tx.type === TransactionType.FeeMarketEIP1559;
}
function isBlobEIP4844Tx(tx) {
  return tx.type === TransactionType.BlobEIP4844;
}
function isEOACodeEIP7702Tx(tx) {
  return tx.type === TransactionType.EOACodeEIP7702;
}
function isLegacyTxData(txData) {
  const txType = Number(bytesToBigInt(toBytes(txData.type)));
  return txType === TransactionType.Legacy;
}
function isAccessListEIP2930TxData(txData) {
  const txType = Number(bytesToBigInt(toBytes(txData.type)));
  return txType === TransactionType.AccessListEIP2930;
}
function isFeeMarketEIP1559TxData(txData) {
  const txType = Number(bytesToBigInt(toBytes(txData.type)));
  return txType === TransactionType.FeeMarketEIP1559;
}
function isBlobEIP4844TxData(txData) {
  const txType = Number(bytesToBigInt(toBytes(txData.type)));
  return txType === TransactionType.BlobEIP4844;
}
function isEOACodeEIP7702TxData(txData) {
  const txType = Number(bytesToBigInt(toBytes(txData.type)));
  return txType === TransactionType.EOACodeEIP7702;
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/util.js
function checkMaxInitCodeSize(common, length) {
  const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
    throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
  }
}
var AccessLists = class {
  static getAccessListData(accessList) {
    let AccessListJSON;
    let bufferAccessList;
    if (isAccessList(accessList)) {
      AccessListJSON = accessList;
      const newAccessList = [];
      for (let i = 0; i < accessList.length; i++) {
        const item = accessList[i];
        const addressBytes = hexToBytes(item.address);
        const storageItems = [];
        for (let index = 0; index < item.storageKeys.length; index++) {
          storageItems.push(hexToBytes(item.storageKeys[index]));
        }
        newAccessList.push([addressBytes, storageItems]);
      }
      bufferAccessList = newAccessList;
    } else {
      bufferAccessList = accessList ?? [];
      const json = [];
      for (let i = 0; i < bufferAccessList.length; i++) {
        const data = bufferAccessList[i];
        const address = bytesToHex(data[0]);
        const storageKeys = [];
        for (let item = 0; item < data[1].length; item++) {
          storageKeys.push(bytesToHex(data[1][item]));
        }
        const jsonItem = {
          address,
          storageKeys
        };
        json.push(jsonItem);
      }
      AccessListJSON = json;
    }
    return {
      AccessListJSON,
      accessList: bufferAccessList
    };
  }
  static verifyAccessList(accessList) {
    for (let key = 0; key < accessList.length; key++) {
      const accessListItem = accessList[key];
      const address = accessListItem[0];
      const storageSlots = accessListItem[1];
      if (accessListItem[2] !== void 0) {
        throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
      }
      if (address.length !== 20) {
        throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
      }
      for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
        if (storageSlots[storageSlot].length !== 32) {
          throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
        }
      }
    }
  }
  static getAccessListJSON(accessList) {
    const accessListJSON = [];
    for (let index = 0; index < accessList.length; index++) {
      const item = accessList[index];
      const JSONItem = {
        address: bytesToHex(setLengthLeft(item[0], 20)),
        storageKeys: []
      };
      const storageSlots = item[1];
      for (let slot = 0; slot < storageSlots.length; slot++) {
        const storageSlot = storageSlots[slot];
        JSONItem.storageKeys.push(bytesToHex(setLengthLeft(storageSlot, 32)));
      }
      accessListJSON.push(JSONItem);
    }
    return accessListJSON;
  }
  static getDataFeeEIP2930(accessList, common) {
    const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
    const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
    let slots = 0;
    for (let index = 0; index < accessList.length; index++) {
      const item = accessList[index];
      const storageSlots = item[1];
      slots += storageSlots.length;
    }
    const addresses = accessList.length;
    return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
  }
};
var AuthorizationLists = class {
  static getAuthorizationListData(authorizationList) {
    let AuthorizationListJSON;
    let bufferAuthorizationList;
    if (isAuthorizationList(authorizationList)) {
      AuthorizationListJSON = authorizationList;
      const newAuthorizationList = [];
      const jsonItems = ["chainId", "address", "nonce", "yParity", "r", "s"];
      for (let i = 0; i < authorizationList.length; i++) {
        const item = authorizationList[i];
        for (const key of jsonItems) {
          if (item[key] === void 0) {
            throw new Error(`EIP-7702 authorization list invalid: ${key} is not defined`);
          }
        }
        const chainId = hexToBytes(item.chainId);
        const addressBytes = hexToBytes(item.address);
        const nonceList = [];
        for (let j = 0; j < item.nonce.length; j++) {
          nonceList.push(hexToBytes(item.nonce[j]));
        }
        const yParity = hexToBytes(item.yParity);
        const r = hexToBytes(item.r);
        const s = hexToBytes(item.s);
        newAuthorizationList.push([chainId, addressBytes, nonceList, yParity, r, s]);
      }
      bufferAuthorizationList = newAuthorizationList;
    } else {
      bufferAuthorizationList = authorizationList ?? [];
      const json = [];
      for (let i = 0; i < bufferAuthorizationList.length; i++) {
        const data = bufferAuthorizationList[i];
        const chainId = bytesToHex(data[0]);
        const address = bytesToHex(data[1]);
        const nonces = data[2];
        const nonceList = [];
        for (let j = 0; j < nonces.length; j++) {
          nonceList.push(bytesToHex(nonces[j]));
        }
        const yParity = bytesToHex(data[3]);
        const r = bytesToHex(data[4]);
        const s = bytesToHex(data[5]);
        const jsonItem = {
          chainId,
          address,
          nonce: nonceList,
          yParity,
          r,
          s
        };
        json.push(jsonItem);
      }
      AuthorizationListJSON = json;
    }
    return {
      AuthorizationListJSON,
      authorizationList: bufferAuthorizationList
    };
  }
  static verifyAuthorizationList(authorizationList) {
    for (let key = 0; key < authorizationList.length; key++) {
      const authorizationListItem = authorizationList[key];
      const address = authorizationListItem[1];
      const nonceList = authorizationListItem[2];
      const yParity = authorizationListItem[3];
      const r = authorizationListItem[4];
      const s = authorizationListItem[5];
      validateNoLeadingZeroes({ yParity, r, s });
      if (address.length !== 20) {
        throw new Error("Invalid EIP-7702 transaction: address length should be 20 bytes");
      }
      if (nonceList.length > 1) {
        throw new Error("Invalid EIP-7702 transaction: nonce list should consist of at most 1 item");
      } else if (nonceList.length === 1) {
        validateNoLeadingZeroes({ nonce: nonceList[0] });
      }
    }
  }
  static getDataFeeEIP7702(authorityList, common) {
    const perAuthBaseCost = common.param("gasPrices", "perAuthBaseCost");
    return authorityList.length * Number(perAuthBaseCost);
  }
};
function txTypeBytes(txType) {
  return hexToBytes(`0x${txType.toString(16).padStart(2, "0")}`);
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/baseTransaction.js
var BaseTransaction = class {
  constructor(txData, opts) {
    this.cache = {
      hash: void 0,
      dataFee: void 0,
      senderPubKey: void 0
    };
    this.activeCapabilities = [];
    this.DEFAULT_CHAIN = Chain.Mainnet;
    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
    this._type = Number(bytesToBigInt(toBytes(type)));
    this.txOptions = opts;
    const toB = toBytes(to === "" ? "0x" : to);
    const vB = toBytes(v);
    const rB = toBytes(r);
    const sB = toBytes(s);
    this.nonce = bytesToBigInt(toBytes(nonce));
    this.gasLimit = bytesToBigInt(toBytes(gasLimit));
    this.to = toB.length > 0 ? new Address(toB) : void 0;
    this.value = bytesToBigInt(toBytes(value));
    this.data = toBytes(data === "" ? "0x" : data);
    this.v = vB.length > 0 ? bytesToBigInt(vB) : void 0;
    this.r = rB.length > 0 ? bytesToBigInt(rB) : void 0;
    this.s = sB.length > 0 ? bytesToBigInt(sB) : void 0;
    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    const createContract = this.to === void 0 || this.to === null;
    const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false;
    const common = opts.common ?? this._getCommon();
    if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {
      checkMaxInitCodeSize(common, this.data.length);
    }
  }
  /**
   * Returns the transaction type.
   *
   * Note: legacy txs will return tx type `0`.
   */
  get type() {
    return this._type;
  }
  /**
   * Checks if a tx type defining capability is active
   * on a tx, for example the EIP-1559 fee market mechanism
   * or the EIP-2930 access list feature.
   *
   * Note that this is different from the tx type itself,
   * so EIP-2930 access lists can very well be active
   * on an EIP-1559 tx for example.
   *
   * This method can be useful for feature checks if the
   * tx type is unknown (e.g. when instantiated with
   * the tx factory).
   *
   * See `Capabilities` in the `types` module for a reference
   * on all supported capabilities.
   */
  supports(capability) {
    return this.activeCapabilities.includes(capability);
  }
  /**
   * Validates the transaction signature and minimum gas requirements.
   * @returns {string[]} an array of error strings
   */
  getValidationErrors() {
    const errors = [];
    if (this.isSigned() && !this.verifySignature()) {
      errors.push("Invalid Signature");
    }
    if (this.getBaseFee() > this.gasLimit) {
      errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
    }
    return errors;
  }
  /**
   * Validates the transaction signature and minimum gas requirements.
   * @returns {boolean} true if the transaction is valid, false otherwise
   */
  isValid() {
    const errors = this.getValidationErrors();
    return errors.length === 0;
  }
  /**
   * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
   */
  getBaseFee() {
    const txFee = this.common.param("gasPrices", "tx");
    let fee = this.getDataFee();
    if (txFee)
      fee += txFee;
    if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
      const txCreationFee = this.common.param("gasPrices", "txCreation");
      if (txCreationFee)
        fee += txCreationFee;
    }
    return fee;
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    const txDataZero = this.common.param("gasPrices", "txDataZero");
    const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
    let cost = BIGINT_0;
    for (let i = 0; i < this.data.length; i++) {
      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
    }
    if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
      const dataLength = BigInt(Math.ceil(this.data.length / 32));
      const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
      cost += initCodeCost;
    }
    return cost;
  }
  /**
   * If the tx's `to` is to the creation address
   */
  toCreationAddress() {
    return this.to === void 0 || this.to.bytes.length === 0;
  }
  isSigned() {
    const { v, r, s } = this;
    if (v === void 0 || r === void 0 || s === void 0) {
      return false;
    } else {
      return true;
    }
  }
  /**
   * Determines if the signature is valid
   */
  verifySignature() {
    try {
      const publicKey = this.getSenderPublicKey();
      return unpadBytes(publicKey).length !== 0;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns the sender's address
   */
  getSenderAddress() {
    return new Address(publicToAddress(this.getSenderPublicKey()));
  }
  /**
   * Signs a transaction.
   *
   * Note that the signed tx is returned as a new object,
   * use as follows:
   * ```javascript
   * const signedTx = tx.sign(privateKey)
   * ```
   */
  sign(privateKey) {
    var _a;
    if (privateKey.length !== 32) {
      const msg = this._errorMsg("Private key must be 32 bytes in length.");
      throw new Error(msg);
    }
    let hackApplied = false;
    if (this.type === TransactionType.Legacy && this.common.gteHardfork("spuriousDragon") && !this.supports(Capability.EIP155ReplayProtection)) {
      this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      hackApplied = true;
    }
    const msgHash = this.getHashedMessageToSign();
    const ecSignFunction = ((_a = this.common.customCrypto) == null ? void 0 : _a.ecsign) ?? ecsign;
    const { v, r, s } = ecSignFunction(msgHash, privateKey);
    const tx = this.addSignature(v, r, s, true);
    if (hackApplied) {
      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection);
      if (index > -1) {
        this.activeCapabilities.splice(index, 1);
      }
    }
    return tx;
  }
  /**
   * Returns an object with the JSON representation of the transaction
   */
  toJSON() {
    return {
      type: bigIntToHex(BigInt(this.type)),
      nonce: bigIntToHex(this.nonce),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: bigIntToHex(this.value),
      data: bytesToHex(this.data),
      v: this.v !== void 0 ? bigIntToHex(this.v) : void 0,
      r: this.r !== void 0 ? bigIntToHex(this.r) : void 0,
      s: this.s !== void 0 ? bigIntToHex(this.s) : void 0
    };
  }
  /**
   * Does chain ID checks on common and returns a common
   * to be used on instantiation
   * @hidden
   *
   * @param common - {@link Common} instance from tx options
   * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
   */
  _getCommon(common, chainId) {
    if (chainId !== void 0) {
      const chainIdBigInt = bytesToBigInt(toBytes(chainId));
      if (common) {
        if (common.chainId() !== chainIdBigInt) {
          const msg = this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${chainIdBigInt}, expected: ${common.chainId()}`);
          throw new Error(msg);
        }
        return common.copy();
      } else {
        if (Common.isSupportedChainId(chainIdBigInt)) {
          return new Common({ chain: chainIdBigInt });
        } else {
          return Common.custom({
            name: "custom-chain",
            networkId: chainIdBigInt,
            chainId: chainIdBigInt
          }, { baseChain: this.DEFAULT_CHAIN });
        }
      }
    } else {
      return (common == null ? void 0 : common.copy()) ?? new Common({ chain: this.DEFAULT_CHAIN });
    }
  }
  /**
   * Validates that an object with BigInt values cannot exceed the specified bit limit.
   * @param values Object containing string keys and BigInt values
   * @param bits Number of bits to check (64 or 256)
   * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
   */
  _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
    for (const [key, value] of Object.entries(values)) {
      switch (bits) {
        case 64:
          if (cannotEqual) {
            if (value !== void 0 && value >= MAX_UINT64) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
              throw new Error(msg);
            }
          } else {
            if (value !== void 0 && value > MAX_UINT64) {
              const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
              throw new Error(msg);
            }
          }
          break;
        case 256:
          if (cannotEqual) {
            if (value !== void 0 && value >= MAX_INTEGER) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
              throw new Error(msg);
            }
          } else {
            if (value !== void 0 && value > MAX_INTEGER) {
              const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
              throw new Error(msg);
            }
          }
          break;
        default: {
          const msg = this._errorMsg("unimplemented bits value");
          throw new Error(msg);
        }
      }
    }
  }
  static _validateNotArray(values) {
    const txDataKeys = [
      "nonce",
      "gasPrice",
      "gasLimit",
      "to",
      "value",
      "data",
      "v",
      "r",
      "s",
      "type",
      "baseFee",
      "maxFeePerGas",
      "chainId"
    ];
    for (const [key, value] of Object.entries(values)) {
      if (txDataKeys.includes(key)) {
        if (Array.isArray(value)) {
          throw new Error(`${key} cannot be an array`);
        }
      }
    }
  }
  /**
   * Returns the shared error postfix part for _error() method
   * tx type implementations.
   */
  _getSharedErrorPostfix() {
    let hash2 = "";
    try {
      hash2 = this.isSigned() ? bytesToHex(this.hash()) : "not available (unsigned)";
    } catch (e) {
      hash2 = "error";
    }
    let isSigned = "";
    try {
      isSigned = this.isSigned().toString();
    } catch (e) {
      hash2 = "error";
    }
    let hf = "";
    try {
      hf = this.common.hardfork();
    } catch (e) {
      hf = "error";
    }
    let postfix = `tx type=${this.type} hash=${hash2} nonce=${this.nonce} value=${this.value} `;
    postfix += `signed=${isSigned} hf=${hf}`;
    return postfix;
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/capabilities/eip1559.js
function getUpfrontCost(tx, baseFee) {
  const prio = tx.maxPriorityFeePerGas;
  const maxBase = tx.maxFeePerGas - baseFee;
  const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
  const gasPrice = inclusionFeePerGas + baseFee;
  return tx.gasLimit * gasPrice + tx.value;
}
function getEffectivePriorityFee(tx, baseFee) {
  if (baseFee === void 0 || baseFee > tx.maxFeePerGas) {
    throw new Error("Tx cannot pay baseFee");
  }
  const remainingFee = tx.maxFeePerGas - baseFee;
  return tx.maxPriorityFeePerGas < remainingFee ? tx.maxPriorityFeePerGas : remainingFee;
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/capabilities/legacy.js
function errorMsg(tx, msg) {
  return `${msg} (${tx.errorStr()})`;
}
function getDataFee(tx, extraCost) {
  if (tx.cache.dataFee && tx.cache.dataFee.hardfork === tx.common.hardfork()) {
    return tx.cache.dataFee.value;
  }
  const cost = BaseTransaction.prototype.getDataFee.bind(tx)() + (extraCost ?? 0n);
  if (Object.isFrozen(tx)) {
    tx.cache.dataFee = {
      value: cost,
      hardfork: tx.common.hardfork()
    };
  }
  return cost;
}
function hash(tx) {
  if (!tx.isSigned()) {
    const msg = errorMsg(tx, "Cannot call hash method if transaction is not signed");
    throw new Error(msg);
  }
  const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256;
  if (Object.isFrozen(tx)) {
    if (!tx.cache.hash) {
      tx.cache.hash = keccakFunction(tx.serialize());
    }
    return tx.cache.hash;
  }
  return keccakFunction(tx.serialize());
}
function validateHighS(tx) {
  const { s } = tx;
  if (tx.common.gteHardfork("homestead") && s !== void 0 && s > SECP256K1_ORDER_DIV_2) {
    const msg = errorMsg(tx, "Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
    throw new Error(msg);
  }
}
function getSenderPublicKey(tx) {
  if (tx.cache.senderPubKey !== void 0) {
    return tx.cache.senderPubKey;
  }
  const msgHash = tx.getMessageToVerifySignature();
  const { v, r, s } = tx;
  validateHighS(tx);
  try {
    const ecrecoverFunction = tx.common.customCrypto.ecrecover ?? ecrecover;
    const sender = ecrecoverFunction(msgHash, v, bigIntToUnpaddedBytes(r), bigIntToUnpaddedBytes(s), tx.supports(Capability.EIP155ReplayProtection) ? tx.common.chainId() : void 0);
    if (Object.isFrozen(tx)) {
      tx.cache.senderPubKey = sender;
    }
    return sender;
  } catch (e) {
    const msg = errorMsg(tx, "Invalid Signature");
    throw new Error(msg);
  }
}
function getEffectivePriorityFee2(gasPrice, baseFee) {
  if (baseFee !== void 0 && baseFee > gasPrice) {
    throw new Error("Tx cannot pay baseFee");
  }
  if (baseFee === void 0) {
    return gasPrice;
  }
  return gasPrice - baseFee;
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/capabilities/eip2718.js
function getHashedMessageToSign(tx) {
  const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256;
  return keccakFunction(tx.getMessageToSign());
}
function serialize(tx, base) {
  return concatBytes(txTypeBytes(tx.type), RLP.encode(base ?? tx.raw()));
}
function validateYParity(tx) {
  const { v } = tx;
  if (v !== void 0 && v !== BIGINT_0 && v !== BIGINT_1) {
    const msg = errorMsg(tx, "The y-parity of the transaction should either be 0 or 1");
    throw new Error(msg);
  }
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/capabilities/eip2930.js
function getDataFee2(tx) {
  return getDataFee(tx, BigInt(AccessLists.getDataFeeEIP2930(tx.accessList, tx.common)));
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/eip1559Transaction.js
var FeeMarketEIP1559Transaction = class _FeeMarketEIP1559Transaction extends BaseTransaction {
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * It is not recommended to use this constructor directly. Instead use
   * the static factory methods to assist in creating a Transaction object from
   * varying data types.
   */
  constructor(txData, opts = {}) {
    super({ ...txData, type: TransactionType.FeeMarketEIP1559 }, opts);
    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(1559)) {
      throw new Error("EIP-1559 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
    const accessListData = AccessLists.getAccessListData(accessList ?? []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    AccessLists.verifyAccessList(this.accessList);
    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas));
    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    validateYParity(this);
    validateHighS(this);
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Instantiate a transaction from a data dictionary.
   *
   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, v, r, s }
   *
   * Notes:
   * - `chainId` will be set automatically if not provided
   * - All parameters are optional and have some basic default values
   */
  static fromTxData(txData, opts = {}) {
    return new _FeeMarketEIP1559Transaction(txData, opts);
  }
  /**
   * Instantiate a transaction from the serialized tx.
   *
   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS])`
   */
  static fromSerializedTx(serialized, opts = {}) {
    if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.FeeMarketEIP1559)) === false) {
      throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TransactionType.FeeMarketEIP1559}, received: ${bytesToHex(serialized.subarray(0, 1))}`);
    }
    const values = RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return _FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
  }
  /**
   * Create a transaction from a values array.
   *
   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS]`
   */
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 9 && values.length !== 12) {
      throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
    return new _FeeMarketEIP1559Transaction({
      chainId: bytesToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList ?? [],
      v: v !== void 0 ? bytesToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    return getDataFee2(this);
  }
  /**
   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas
   * @param baseFee Base fee retrieved from block
   */
  getEffectivePriorityFee(baseFee) {
    return getEffectivePriorityFee(this, baseFee);
  }
  /**
   * The up front amount that an account must have for this transaction to be valid
   * @param baseFee The base fee of the block (will be set to 0 if not provided)
   */
  getUpfrontCost(baseFee = BIGINT_0) {
    return getUpfrontCost(this, baseFee);
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes of the EIP-1559 transaction, in order.
   *
   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS]`
   *
   * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
   * with {@link Block.fromValuesArray}.
   *
   * For an unsigned tx this method uses the empty Bytes values for the
   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
   * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
   */
  raw() {
    return [
      bigIntToUnpaddedBytes(this.chainId),
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),
      bigIntToUnpaddedBytes(this.maxFeePerGas),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
      this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
      this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
    ];
  }
  /**
   * Returns the serialized encoding of the EIP-1559 transaction.
   *
   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS])`
   *
   * Note that in contrast to the legacy tx serialization format this is not
   * valid RLP any more due to the raw tx type preceding and concatenated to
   * the RLP encoding of the values.
   */
  serialize() {
    return serialize(this);
  }
  /**
   * Returns the raw serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   *
   * ```javascript
   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input
   * ```
   */
  getMessageToSign() {
    return serialize(this, this.raw().slice(0, 9));
  }
  /**
   * Returns the hashed serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   */
  getHashedMessageToSign() {
    return getHashedMessageToSign(this);
  }
  /**
   * Computes a sha3-256 hash of the serialized tx.
   *
   * This method can only be used for signed txs (it throws otherwise).
   * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
   */
  hash() {
    return hash(this);
  }
  /**
   * Computes a sha3-256 hash which can be used to verify the signature
   */
  getMessageToVerifySignature() {
    return this.getHashedMessageToSign();
  }
  /**
   * Returns the public key of the sender
   */
  getSenderPublicKey() {
    return getSenderPublicKey(this);
  }
  addSignature(v, r, s, convertV = false) {
    r = toBytes(r);
    s = toBytes(s);
    const opts = { ...this.txOptions, common: this.common };
    return _FeeMarketEIP1559Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: convertV ? v - BIGINT_27 : v,
      r: bytesToBigInt(r),
      s: bytesToBigInt(s)
    }, opts);
  }
  /**
   * Returns an object with the JSON representation of the transaction
   */
  toJSON() {
    const accessListJSON = AccessLists.getAccessListJSON(this.accessList);
    const baseJson = super.toJSON();
    return {
      ...baseJson,
      chainId: bigIntToHex(this.chainId),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      accessList: accessListJSON
    };
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return errorMsg(this, msg);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/eip2930Transaction.js
var AccessListEIP2930Transaction = class _AccessListEIP2930Transaction extends BaseTransaction {
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * It is not recommended to use this constructor directly. Instead use
   * the static factory methods to assist in creating a Transaction object from
   * varying data types.
   */
  constructor(txData, opts = {}) {
    super({ ...txData, type: TransactionType.AccessListEIP2930 }, opts);
    const { chainId, accessList, gasPrice } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(2930)) {
      throw new Error("EIP-2930 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
    const accessListData = AccessLists.getAccessListData(accessList ?? []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    AccessLists.verifyAccessList(this.accessList);
    this.gasPrice = bytesToBigInt(toBytes(gasPrice));
    this._validateCannotExceedMaxInteger({
      gasPrice: this.gasPrice
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
      throw new Error(msg);
    }
    validateYParity(this);
    validateHighS(this);
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Instantiate a transaction from a data dictionary.
   *
   * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
   * v, r, s }
   *
   * Notes:
   * - `chainId` will be set automatically if not provided
   * - All parameters are optional and have some basic default values
   */
  static fromTxData(txData, opts = {}) {
    return new _AccessListEIP2930Transaction(txData, opts);
  }
  /**
   * Instantiate a transaction from the serialized tx.
   *
   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
   * signatureYParity (v), signatureR (r), signatureS (s)])`
   */
  static fromSerializedTx(serialized, opts = {}) {
    if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.AccessListEIP2930)) === false) {
      throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TransactionType.AccessListEIP2930}, received: ${bytesToHex(serialized.subarray(0, 1))}`);
    }
    const values = RLP.decode(Uint8Array.from(serialized.subarray(1)));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return _AccessListEIP2930Transaction.fromValuesArray(values, opts);
  }
  /**
   * Create a transaction from a values array.
   *
   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
   * signatureYParity (v), signatureR (r), signatureS (s)]`
   */
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 8 && values.length !== 11) {
      throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
    }
    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    const emptyAccessList = [];
    return new _AccessListEIP2930Transaction({
      chainId: bytesToBigInt(chainId),
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList ?? emptyAccessList,
      v: v !== void 0 ? bytesToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  getEffectivePriorityFee(baseFee) {
    return getEffectivePriorityFee2(this.gasPrice, baseFee);
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    return getDataFee2(this);
  }
  /**
   * The up front amount that an account must have for this transaction to be valid
   */
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes of the EIP-2930 transaction, in order.
   *
   * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
   * signatureYParity (v), signatureR (r), signatureS (s)]`
   *
   * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block
   * with {@link Block.fromValuesArray}.
   *
   * For an unsigned tx this method uses the empty Bytes values for the
   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
   * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.
   */
  raw() {
    return [
      bigIntToUnpaddedBytes(this.chainId),
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.gasPrice),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
      this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
      this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
    ];
  }
  /**
   * Returns the serialized encoding of the EIP-2930 transaction.
   *
   * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
   * signatureYParity (v), signatureR (r), signatureS (s)])`
   *
   * Note that in contrast to the legacy tx serialization format this is not
   * valid RLP any more due to the raw tx type preceding and concatenated to
   * the RLP encoding of the values.
   */
  serialize() {
    return serialize(this);
  }
  /**
   * Returns the raw serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   *
   * ```javascript
   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input
   * ```
   */
  getMessageToSign() {
    return serialize(this, this.raw().slice(0, 8));
  }
  /**
   * Returns the hashed serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   */
  getHashedMessageToSign() {
    return getHashedMessageToSign(this);
  }
  /**
   * Computes a sha3-256 hash of the serialized tx.
   *
   * This method can only be used for signed txs (it throws otherwise).
   * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
   */
  hash() {
    return hash(this);
  }
  /**
   * Computes a sha3-256 hash which can be used to verify the signature
   */
  getMessageToVerifySignature() {
    return this.getHashedMessageToSign();
  }
  /**
   * Returns the public key of the sender
   */
  getSenderPublicKey() {
    return getSenderPublicKey(this);
  }
  addSignature(v, r, s, convertV = false) {
    r = toBytes(r);
    s = toBytes(s);
    const opts = { ...this.txOptions, common: this.common };
    return _AccessListEIP2930Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: convertV ? v - BIGINT_27 : v,
      r: bytesToBigInt(r),
      s: bytesToBigInt(s)
    }, opts);
  }
  /**
   * Returns an object with the JSON representation of the transaction
   */
  toJSON() {
    const accessListJSON = AccessLists.getAccessListJSON(this.accessList);
    const baseJson = super.toJSON();
    return {
      ...baseJson,
      chainId: bigIntToHex(this.chainId),
      gasPrice: bigIntToHex(this.gasPrice),
      accessList: accessListJSON
    };
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    var _a;
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${((_a = this.accessList) == null ? void 0 : _a.length) ?? 0}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return errorMsg(this, msg);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/constants.js
var LIMIT_BLOBS_PER_TX = 6;

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/eip4844Transaction.js
var validateBlobTransactionNetworkWrapper = (blobVersionedHashes, blobs, commitments, kzgProofs, version, kzg) => {
  if (!(blobVersionedHashes.length === blobs.length && blobs.length === commitments.length)) {
    throw new Error("Number of blobVersionedHashes, blobs, and commitments not all equal");
  }
  if (blobVersionedHashes.length === 0) {
    throw new Error("Invalid transaction with empty blobs");
  }
  let isValid;
  try {
    isValid = kzg.verifyBlobKzgProofBatch(blobs, commitments, kzgProofs);
  } catch (error) {
    throw new Error(`KZG verification of blobs fail with error=${error}`);
  }
  if (!isValid) {
    throw new Error("KZG proof cannot be verified from blobs/commitments");
  }
  for (let x = 0; x < blobVersionedHashes.length; x++) {
    const computedVersionedHash = computeVersionedHash(commitments[x], version);
    if (!equalsBytes(computedVersionedHash, blobVersionedHashes[x])) {
      throw new Error(`commitment for blob at index ${x} does not match versionedHash`);
    }
  }
};
var BlobEIP4844Transaction = class _BlobEIP4844Transaction extends BaseTransaction {
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * It is not recommended to use this constructor directly. Instead use
   * the static constructors or factory methods to assist in creating a Transaction object from
   * varying data types.
   */
  constructor(txData, opts = {}) {
    var _a, _b, _c;
    super({ ...txData, type: TransactionType.BlobEIP4844 }, opts);
    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerBlobGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(1559)) {
      throw new Error("EIP-1559 not enabled on Common");
    }
    if (!this.common.isActivatedEIP(4844)) {
      throw new Error("EIP-4844 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
    const accessListData = AccessLists.getAccessListData(accessList ?? []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    AccessLists.verifyAccessList(this.accessList);
    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas));
    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    this.maxFeePerBlobGas = bytesToBigInt(toBytes((maxFeePerBlobGas ?? "") === "" ? "0x" : maxFeePerBlobGas));
    this.blobVersionedHashes = (txData.blobVersionedHashes ?? []).map((vh) => toBytes(vh));
    validateYParity(this);
    validateHighS(this);
    for (const hash2 of this.blobVersionedHashes) {
      if (hash2.length !== 32) {
        const msg = this._errorMsg("versioned hash is invalid length");
        throw new Error(msg);
      }
      if (BigInt(hash2[0]) !== this.common.param("sharding", "blobCommitmentVersionKzg")) {
        const msg = this._errorMsg("versioned hash does not start with KZG commitment version");
        throw new Error(msg);
      }
    }
    if (this.blobVersionedHashes.length > LIMIT_BLOBS_PER_TX) {
      const msg = this._errorMsg(`tx can contain at most ${LIMIT_BLOBS_PER_TX} blobs`);
      throw new Error(msg);
    } else if (this.blobVersionedHashes.length === 0) {
      const msg = this._errorMsg(`tx should contain at least one blob`);
      throw new Error(msg);
    }
    if (this.to === void 0) {
      const msg = this._errorMsg(`tx should have a "to" field and cannot be used to create contracts`);
      throw new Error(msg);
    }
    this.blobs = (_a = txData.blobs) == null ? void 0 : _a.map((blob) => toBytes(blob));
    this.kzgCommitments = (_b = txData.kzgCommitments) == null ? void 0 : _b.map((commitment) => toBytes(commitment));
    this.kzgProofs = (_c = txData.kzgProofs) == null ? void 0 : _c.map((proof) => toBytes(proof));
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts) {
    var _a, _b;
    if (((_b = (_a = opts == null ? void 0 : opts.common) == null ? void 0 : _a.customCrypto) == null ? void 0 : _b.kzg) === void 0) {
      throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");
    }
    const kzg = opts.common.customCrypto.kzg;
    if (txData.blobsData !== void 0) {
      if (txData.blobs !== void 0) {
        throw new Error("cannot have both raw blobs data and encoded blobs in constructor");
      }
      if (txData.kzgCommitments !== void 0) {
        throw new Error("cannot have both raw blobs data and KZG commitments in constructor");
      }
      if (txData.blobVersionedHashes !== void 0) {
        throw new Error("cannot have both raw blobs data and versioned hashes in constructor");
      }
      if (txData.kzgProofs !== void 0) {
        throw new Error("cannot have both raw blobs data and KZG proofs in constructor");
      }
      txData.blobs = getBlobs(txData.blobsData.reduce((acc, cur) => acc + cur));
      txData.kzgCommitments = blobsToCommitments(kzg, txData.blobs);
      txData.blobVersionedHashes = commitmentsToVersionedHashes(txData.kzgCommitments);
      txData.kzgProofs = blobsToProofs(kzg, txData.blobs, txData.kzgCommitments);
    }
    return new _BlobEIP4844Transaction(txData, opts);
  }
  /**
   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas
   * @param baseFee Base fee retrieved from block
   */
  getEffectivePriorityFee(baseFee) {
    return getEffectivePriorityFee(this, baseFee);
  }
  /**
   * Creates the minimal representation of a blob transaction from the network wrapper version.
   * The minimal representation is used when adding transactions to an execution payload/block
   * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments
   * @param opts - dictionary of {@link TxOptions}
   * @returns the "minimal" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)
   */
  static minimalFromNetworkWrapper(txData, opts) {
    var _a, _b;
    if (((_b = (_a = opts == null ? void 0 : opts.common) == null ? void 0 : _a.customCrypto) == null ? void 0 : _b.kzg) === void 0) {
      throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");
    }
    const tx = _BlobEIP4844Transaction.fromTxData({
      ...txData,
      ...{ blobs: void 0, kzgCommitments: void 0, kzgProofs: void 0 }
    }, opts);
    return tx;
  }
  /**
   * Instantiate a transaction from the serialized tx.
   *
   * Format: `0x03 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data,
   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s])`
   */
  static fromSerializedTx(serialized, opts = {}) {
    var _a, _b;
    if (((_b = (_a = opts.common) == null ? void 0 : _a.customCrypto) == null ? void 0 : _b.kzg) === void 0) {
      throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");
    }
    if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.BlobEIP4844)) === false) {
      throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${TransactionType.BlobEIP4844}, received: ${bytesToHex(serialized.subarray(0, 1))}`);
    }
    const values = RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return _BlobEIP4844Transaction.fromValuesArray(values, opts);
  }
  /**
   * Create a transaction from a values array.
   *
   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS]`
   */
  static fromValuesArray(values, opts = {}) {
    var _a, _b;
    if (((_b = (_a = opts.common) == null ? void 0 : _a.customCrypto) == null ? void 0 : _b.kzg) === void 0) {
      throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");
    }
    if (values.length !== 11 && values.length !== 14) {
      throw new Error("Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      value,
      maxFeePerBlobGas,
      v,
      r,
      s
    });
    return new _BlobEIP4844Transaction({
      chainId: bytesToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList ?? [],
      maxFeePerBlobGas,
      blobVersionedHashes,
      v: v !== void 0 ? bytesToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  /**
   * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)
   * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper
   * @param opts any TxOptions defined
   * @returns a BlobEIP4844Transaction
   */
  static fromSerializedBlobTxNetworkWrapper(serialized, opts) {
    var _a, _b;
    if (!opts || !opts.common) {
      throw new Error("common instance required to validate versioned hashes");
    }
    if (((_b = (_a = opts.common) == null ? void 0 : _a.customCrypto) == null ? void 0 : _b.kzg) === void 0) {
      throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");
    }
    if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.BlobEIP4844)) === false) {
      throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${TransactionType.BlobEIP4844}, received: ${bytesToHex(serialized.subarray(0, 1))}`);
    }
    const networkTxValues = RLP.decode(serialized.subarray(1));
    if (networkTxValues.length !== 4) {
      throw Error(`Expected 4 values in the deserialized network transaction`);
    }
    const [txValues, blobs, kzgCommitments, kzgProofs] = networkTxValues;
    const decodedTx = _BlobEIP4844Transaction.fromValuesArray(txValues, { ...opts, freeze: false });
    if (decodedTx.to === void 0) {
      throw Error("BlobEIP4844Transaction can not be send without a valid `to`");
    }
    const version = Number(opts.common.param("sharding", "blobCommitmentVersionKzg"));
    validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, blobs, kzgCommitments, kzgProofs, version, opts.common.customCrypto.kzg);
    decodedTx.blobs = blobs;
    decodedTx.kzgCommitments = kzgCommitments;
    decodedTx.kzgProofs = kzgProofs;
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(decodedTx);
    }
    return decodedTx;
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    return getDataFee2(this);
  }
  /**
   * The up front amount that an account must have for this transaction to be valid
   * @param baseFee The base fee of the block (will be set to 0 if not provided)
   */
  getUpfrontCost(baseFee = BIGINT_0) {
    return getUpfrontCost(this, baseFee);
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes of the EIP-4844 transaction, in order.
   *
   * Format: [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data,
   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s]`.
   *
   * Use {@link BlobEIP4844Transaction.serialize} to add a transaction to a block
   * with {@link Block.fromValuesArray}.
   *
   * For an unsigned tx this method uses the empty Bytes values for the
   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
   * representation for external signing use {@link BlobEIP4844Transaction.getMessageToSign}.
   */
  raw() {
    return [
      bigIntToUnpaddedBytes(this.chainId),
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),
      bigIntToUnpaddedBytes(this.maxFeePerGas),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data,
      this.accessList,
      bigIntToUnpaddedBytes(this.maxFeePerBlobGas),
      this.blobVersionedHashes,
      this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
      this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
      this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
    ];
  }
  /**
   * Returns the serialized encoding of the EIP-4844 transaction.
   *
   * Format: `0x03 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * access_list, max_fee_per_data_gas, blob_versioned_hashes, y_parity, r, s])`.
   *
   * Note that in contrast to the legacy tx serialization format this is not
   * valid RLP any more due to the raw tx type preceding and concatenated to
   * the RLP encoding of the values.
   */
  serialize() {
    return serialize(this);
  }
  /**
   * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)
   */
  serializeNetworkWrapper() {
    if (this.blobs === void 0 || this.kzgCommitments === void 0 || this.kzgProofs === void 0) {
      throw new Error("cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided");
    }
    return serialize(this, [this.raw(), this.blobs, this.kzgCommitments, this.kzgProofs]);
  }
  /**
   * Returns the raw serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   *
   * ```javascript
   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input
   * ```
   */
  getMessageToSign() {
    return serialize(this, this.raw().slice(0, 11));
  }
  /**
   * Returns the hashed serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   */
  getHashedMessageToSign() {
    return getHashedMessageToSign(this);
  }
  /**
   * Computes a sha3-256 hash of the serialized tx.
   *
   * This method can only be used for signed txs (it throws otherwise).
   * Use {@link BlobEIP4844Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
   */
  hash() {
    return hash(this);
  }
  getMessageToVerifySignature() {
    return this.getHashedMessageToSign();
  }
  /**
   * Returns the public key of the sender
   */
  getSenderPublicKey() {
    return getSenderPublicKey(this);
  }
  /**
   * Returns the EIP 4844 transaction network wrapper in JSON format similar to toJSON, including
   * blobs, commitments, and proofs fields
   * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper
   * @param opts any TxOptions defined
   * @returns JsonBlobTxNetworkWrapper with blobs, KZG commitments, and KZG proofs fields
   */
  static networkWrapperToJson(serialized, opts) {
    const tx = this.fromSerializedBlobTxNetworkWrapper(serialized, opts);
    const accessListJSON = AccessLists.getAccessListJSON(tx.accessList);
    const baseJson = tx.toJSON();
    return {
      ...baseJson,
      chainId: bigIntToHex(tx.chainId),
      maxPriorityFeePerGas: bigIntToHex(tx.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(tx.maxFeePerGas),
      accessList: accessListJSON,
      maxFeePerBlobGas: bigIntToHex(tx.maxFeePerBlobGas),
      blobVersionedHashes: tx.blobVersionedHashes.map((hash2) => bytesToHex(hash2)),
      blobs: tx.blobs.map((bytes) => bytesToHex(bytes)),
      kzgCommitments: tx.kzgCommitments.map((bytes) => bytesToHex(bytes)),
      kzgProofs: tx.kzgProofs.map((bytes) => bytesToHex(bytes))
    };
  }
  toJSON() {
    const accessListJSON = AccessLists.getAccessListJSON(this.accessList);
    const baseJson = super.toJSON();
    return {
      ...baseJson,
      chainId: bigIntToHex(this.chainId),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      accessList: accessListJSON,
      maxFeePerBlobGas: bigIntToHex(this.maxFeePerBlobGas),
      blobVersionedHashes: this.blobVersionedHashes.map((hash2) => bytesToHex(hash2))
    };
  }
  addSignature(v, r, s, convertV = false) {
    r = toBytes(r);
    s = toBytes(s);
    const opts = { ...this.txOptions, common: this.common };
    return _BlobEIP4844Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: convertV ? v - BIGINT_27 : v,
      r: bytesToBigInt(r),
      s: bytesToBigInt(s),
      maxFeePerBlobGas: this.maxFeePerBlobGas,
      blobVersionedHashes: this.blobVersionedHashes,
      blobs: this.blobs,
      kzgCommitments: this.kzgCommitments,
      kzgProofs: this.kzgProofs
    }, opts);
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return errorMsg(this, msg);
  }
  /**
   * @returns the number of blobs included with this transaction
   */
  numBlobs() {
    return this.blobVersionedHashes.length;
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/capabilities/eip7702.js
function getDataFee3(tx) {
  const eip2930Cost = BigInt(AccessLists.getDataFeeEIP2930(tx.accessList, tx.common));
  const eip7702Cost = BigInt(tx.authorizationList.length * Number(tx.common.param("gasPrices", "perAuthBaseCost")));
  return getDataFee(tx, eip2930Cost + eip7702Cost);
}

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/eip7702Transaction.js
var EOACodeEIP7702Transaction = class _EOACodeEIP7702Transaction extends BaseTransaction {
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * It is not recommended to use this constructor directly. Instead use
   * the static factory methods to assist in creating a Transaction object from
   * varying data types.
   */
  constructor(txData, opts = {}) {
    super({ ...txData, type: TransactionType.EOACodeEIP7702 }, opts);
    const { chainId, accessList, authorizationList, maxFeePerGas, maxPriorityFeePerGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(7702)) {
      throw new Error("EIP-7702 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930, 7702]);
    const accessListData = AccessLists.getAccessListData(accessList ?? []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    AccessLists.verifyAccessList(this.accessList);
    const authorizationListData = AuthorizationLists.getAuthorizationListData(authorizationList ?? []);
    this.authorizationList = authorizationListData.authorizationList;
    this.AuthorizationListJSON = authorizationListData.AuthorizationListJSON;
    AuthorizationLists.verifyAuthorizationList(this.authorizationList);
    this.maxFeePerGas = bytesToBigInt(toBytes(maxFeePerGas));
    this.maxPriorityFeePerGas = bytesToBigInt(toBytes(maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    validateYParity(this);
    validateHighS(this);
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Instantiate a transaction from a data dictionary.
   *
   * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, v, r, s }
   *
   * Notes:
   * - `chainId` will be set automatically if not provided
   * - All parameters are optional and have some basic default values
   */
  static fromTxData(txData, opts = {}) {
    return new _EOACodeEIP7702Transaction(txData, opts);
  }
  /**
   * Instantiate a transaction from the serialized tx.
   *
   * Format: `0x04 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS])`
   */
  static fromSerializedTx(serialized, opts = {}) {
    if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.EOACodeEIP7702)) === false) {
      throw new Error(`Invalid serialized tx input: not an EIP-7702 transaction (wrong tx type, expected: ${TransactionType.EOACodeEIP7702}, received: ${bytesToHex(serialized.subarray(0, 1))}`);
    }
    const values = RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return _EOACodeEIP7702Transaction.fromValuesArray(values, opts);
  }
  /**
   * Create a transaction from a values array.
   *
   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, signatureYParity, signatureR, signatureS]`
   */
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 10 && values.length !== 13) {
      throw new Error("Invalid EIP-7702 transaction. Only expecting 10 values (for unsigned tx) or 13 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, authorityList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
    return new _EOACodeEIP7702Transaction({
      chainId: bytesToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList ?? [],
      authorizationList: authorityList ?? [],
      v: v !== void 0 ? bytesToBigInt(v) : void 0,
      r,
      s
    }, opts);
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    return getDataFee3(this);
  }
  /**
   * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas
   * @param baseFee Base fee retrieved from block
   */
  getEffectivePriorityFee(baseFee) {
    return getEffectivePriorityFee(this, baseFee);
  }
  /**
   * The up front amount that an account must have for this transaction to be valid
   * @param baseFee The base fee of the block (will be set to 0 if not provided)
   */
  getUpfrontCost(baseFee = BIGINT_0) {
    return getUpfrontCost(this, baseFee);
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes of the EIP-7702 transaction, in order.
   *
   * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, authorizationList, signatureYParity, signatureR, signatureS]`
   *
   * Use {@link EOACodeEIP7702Transaction.serialize} to add a transaction to a block
   * with {@link Block.fromValuesArray}.
   *
   * For an unsigned tx this method uses the empty Bytes values for the
   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
   * representation for external signing use {@link EOACodeEIP7702Transaction.getMessageToSign}.
   */
  raw() {
    return [
      bigIntToUnpaddedBytes(this.chainId),
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),
      bigIntToUnpaddedBytes(this.maxFeePerGas),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data,
      this.accessList,
      this.authorizationList,
      this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
      this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
      this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
    ];
  }
  /**
   * Returns the serialized encoding of the EIP-7702 transaction.
   *
   * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
   * accessList, authorizationList, signatureYParity, signatureR, signatureS])`
   *
   * Note that in contrast to the legacy tx serialization format this is not
   * valid RLP any more due to the raw tx type preceding and concatenated to
   * the RLP encoding of the values.
   */
  serialize() {
    return serialize(this);
  }
  /**
   * Returns the raw serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   *
   * ```javascript
   * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input
   * ```
   */
  getMessageToSign() {
    return serialize(this, this.raw().slice(0, 10));
  }
  /**
   * Returns the hashed serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: in contrast to the legacy tx the raw message format is already
   * serialized and doesn't need to be RLP encoded any more.
   */
  getHashedMessageToSign() {
    return getHashedMessageToSign(this);
  }
  /**
   * Computes a sha3-256 hash of the serialized tx.
   *
   * This method can only be used for signed txs (it throws otherwise).
   * Use {@link EOACodeEIP7702Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
   */
  hash() {
    return hash(this);
  }
  /**
   * Computes a sha3-256 hash which can be used to verify the signature
   */
  getMessageToVerifySignature() {
    return this.getHashedMessageToSign();
  }
  /**
   * Returns the public key of the sender
   */
  getSenderPublicKey() {
    return getSenderPublicKey(this);
  }
  addSignature(v, r, s, convertV = false) {
    r = toBytes(r);
    s = toBytes(s);
    const opts = { ...this.txOptions, common: this.common };
    return _EOACodeEIP7702Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      authorizationList: this.authorizationList,
      v: convertV ? v - BIGINT_27 : v,
      r: bytesToBigInt(r),
      s: bytesToBigInt(s)
    }, opts);
  }
  /**
   * Returns an object with the JSON representation of the transaction
   */
  toJSON() {
    const accessListJSON = AccessLists.getAccessListJSON(this.accessList);
    const baseJson = super.toJSON();
    return {
      ...baseJson,
      chainId: bigIntToHex(this.chainId),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      accessList: accessListJSON,
      authorizationList: this.AuthorizationListJSON
    };
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return errorMsg(this, msg);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/legacyTransaction.js
function meetsEIP155(_v, chainId) {
  const v = Number(_v);
  const chainIdDoubled = Number(chainId) * 2;
  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
}
var LegacyTransaction = class _LegacyTransaction extends BaseTransaction {
  /**
   * This constructor takes the values, validates them, assigns them and freezes the object.
   *
   * It is not recommended to use this constructor directly. Instead use
   * the static factory methods to assist in creating a Transaction object from
   * varying data types.
   */
  constructor(txData, opts = {}) {
    super({ ...txData, type: TransactionType.Legacy }, opts);
    this.common = this._validateTxV(this.v, opts.common);
    this.keccakFunction = this.common.customCrypto.keccak256 ?? keccak256;
    this.gasPrice = bytesToBigInt(toBytes(txData.gasPrice));
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
    BaseTransaction._validateNotArray(txData);
    if (this.common.gteHardfork("spuriousDragon")) {
      if (!this.isSigned()) {
        this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      } else {
        if (meetsEIP155(this.v, this.common.chainId())) {
          this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        }
      }
    }
    const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  /**
   * Instantiate a transaction from a data dictionary.
   *
   * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
   *
   * Notes:
   * - All parameters are optional and have some basic default values
   */
  static fromTxData(txData, opts = {}) {
    return new _LegacyTransaction(txData, opts);
  }
  /**
   * Instantiate a transaction from the serialized tx.
   *
   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
   */
  static fromSerializedTx(serialized, opts = {}) {
    const values = RLP.decode(serialized);
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input. Must be array");
    }
    return this.fromValuesArray(values, opts);
  }
  /**
   * Create a transaction from a values array.
   *
   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
   */
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 6 && values.length !== 9) {
      throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
    }
    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    return new _LegacyTransaction({
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      v,
      r,
      s
    }, opts);
  }
  getEffectivePriorityFee(baseFee) {
    return getEffectivePriorityFee2(this.gasPrice, baseFee);
  }
  /**
   * Returns a Uint8Array Array of the raw Bytes of the legacy transaction, in order.
   *
   * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
   *
   * For legacy txs this is also the correct format to add transactions
   * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
   * for typed txs).
   *
   * For an unsigned tx this method returns the empty Bytes values
   * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
   * representation have a look at {@link Transaction.getMessageToSign}.
   */
  raw() {
    return [
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.gasPrice),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data,
      this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
      this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
      this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
    ];
  }
  /**
   * Returns the serialized encoding of the legacy transaction.
   *
   * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
   *
   * For an unsigned tx this method uses the empty Uint8Array values for the
   * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
   * representation for external signing use {@link Transaction.getMessageToSign}.
   */
  serialize() {
    return RLP.encode(this.raw());
  }
  /**
   * Returns the raw unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   *
   * Note: the raw message message format for the legacy tx is not RLP encoded
   * and you might need to do yourself with:
   *
   * ```javascript
   * import { RLP } from '@ethereumjs/rlp'
   * const message = tx.getMessageToSign()
   * const serializedMessage = RLP.encode(message)) // use this for the HW wallet input
   * ```
   */
  getMessageToSign() {
    const message = [
      bigIntToUnpaddedBytes(this.nonce),
      bigIntToUnpaddedBytes(this.gasPrice),
      bigIntToUnpaddedBytes(this.gasLimit),
      this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
      bigIntToUnpaddedBytes(this.value),
      this.data
    ];
    if (this.supports(Capability.EIP155ReplayProtection)) {
      message.push(bigIntToUnpaddedBytes(this.common.chainId()));
      message.push(unpadBytes(toBytes(0)));
      message.push(unpadBytes(toBytes(0)));
    }
    return message;
  }
  /**
   * Returns the hashed serialized unsigned tx, which can be used
   * to sign the transaction (e.g. for sending to a hardware wallet).
   */
  getHashedMessageToSign() {
    const message = this.getMessageToSign();
    return this.keccakFunction(RLP.encode(message));
  }
  /**
   * The amount of gas paid for the data in this tx
   */
  getDataFee() {
    return getDataFee(this);
  }
  /**
   * The up front amount that an account must have for this transaction to be valid
   */
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  /**
   * Computes a sha3-256 hash of the serialized tx.
   *
   * This method can only be used for signed txs (it throws otherwise).
   * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
   */
  hash() {
    return hash(this);
  }
  /**
   * Computes a sha3-256 hash which can be used to verify the signature
   */
  getMessageToVerifySignature() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("This transaction is not signed");
      throw new Error(msg);
    }
    return this.getHashedMessageToSign();
  }
  /**
   * Returns the public key of the sender
   */
  getSenderPublicKey() {
    return getSenderPublicKey(this);
  }
  addSignature(v, r, s, convertV = false) {
    r = toBytes(r);
    s = toBytes(s);
    if (convertV && this.supports(Capability.EIP155ReplayProtection)) {
      v += this.common.chainId() * BIGINT_2 + BIGINT_8;
    }
    const opts = { ...this.txOptions, common: this.common };
    return _LegacyTransaction.fromTxData({
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      v,
      r: bytesToBigInt(r),
      s: bytesToBigInt(s)
    }, opts);
  }
  /**
   * Returns an object with the JSON representation of the transaction.
   */
  toJSON() {
    const baseJson = super.toJSON();
    return {
      ...baseJson,
      gasPrice: bigIntToHex(this.gasPrice)
    };
  }
  /**
   * Validates tx's `v` value
   */
  _validateTxV(_v, common) {
    let chainIdBigInt;
    const v = _v !== void 0 ? Number(_v) : void 0;
    if (v !== void 0) {
      if (v < 37 && v !== 27 && v !== 28) {
        throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
      }
    }
    if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
      if (common) {
        if (!meetsEIP155(BigInt(v), common.chainId())) {
          throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
        }
      } else {
        let numSub;
        if ((v - 35) % 2 === 0) {
          numSub = 35;
        } else {
          numSub = 36;
        }
        chainIdBigInt = BigInt(v - numSub) / BIGINT_2;
      }
    }
    return this._getCommon(common, chainIdBigInt);
  }
  /**
   * Return a compact error string representation of the object
   */
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice}`;
    return errorStr;
  }
  /**
   * Internal helper function to create an annotated error message
   *
   * @param msg Base error message
   * @hidden
   */
  _errorMsg(msg) {
    return errorMsg(this, msg);
  }
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/fromRpc.js
var normalizeTxParams = (_txParams) => {
  const txParams = Object.assign({}, _txParams);
  txParams.gasLimit = toType(txParams.gasLimit ?? txParams.gas, TypeOutput.BigInt);
  txParams.data = txParams.data === void 0 ? txParams.input : txParams.data;
  txParams.gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
  txParams.value = txParams.value !== void 0 ? BigInt(txParams.value) : void 0;
  txParams.to = txParams.to !== null && txParams.to !== void 0 ? setLengthLeft(toBytes(txParams.to), 20) : null;
  txParams.v = txParams.v === "0x0" ? "0x" : txParams.v;
  txParams.r = txParams.r === "0x0" ? "0x" : txParams.r;
  txParams.s = txParams.s === "0x0" ? "0x" : txParams.s;
  if (txParams.v !== "0x" || txParams.r !== "0x" || txParams.s !== "0x") {
    txParams.v = toType(txParams.v, TypeOutput.BigInt);
  }
  return txParams;
};

// node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/tx/dist/esm/transactionFactory.js
var TransactionFactory = class _TransactionFactory {
  // It is not possible to instantiate a TransactionFactory object.
  constructor() {
  }
  /**
   * Create a transaction from a `txData` object
   *
   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
   * @param txOptions - Options to pass on to the constructor of the transaction
   */
  static fromTxData(txData, txOptions = {}) {
    if (!("type" in txData) || txData.type === void 0) {
      return LegacyTransaction.fromTxData(txData, txOptions);
    } else {
      if (isLegacyTxData(txData)) {
        return LegacyTransaction.fromTxData(txData, txOptions);
      } else if (isAccessListEIP2930TxData(txData)) {
        return AccessListEIP2930Transaction.fromTxData(txData, txOptions);
      } else if (isFeeMarketEIP1559TxData(txData)) {
        return FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
      } else if (isBlobEIP4844TxData(txData)) {
        return BlobEIP4844Transaction.fromTxData(txData, txOptions);
      } else if (isEOACodeEIP7702TxData(txData)) {
        return EOACodeEIP7702Transaction.fromTxData(txData, txOptions);
      } else {
        throw new Error(`Tx instantiation with type ${txData == null ? void 0 : txData.type} not supported`);
      }
    }
  }
  /**
   * This method tries to decode serialized data.
   *
   * @param data - The data Uint8Array
   * @param txOptions - The transaction options
   */
  static fromSerializedData(data, txOptions = {}) {
    if (data[0] <= 127) {
      switch (data[0]) {
        case TransactionType.AccessListEIP2930:
          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
        case TransactionType.FeeMarketEIP1559:
          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
        case TransactionType.BlobEIP4844:
          return BlobEIP4844Transaction.fromSerializedTx(data, txOptions);
        case TransactionType.EOACodeEIP7702:
          return EOACodeEIP7702Transaction.fromSerializedTx(data, txOptions);
        default:
          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
      }
    } else {
      return LegacyTransaction.fromSerializedTx(data, txOptions);
    }
  }
  /**
   * When decoding a BlockBody, in the transactions field, a field is either:
   * A Uint8Array (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))
   * A Uint8Array[] (Legacy Transaction)
   * This method returns the right transaction.
   *
   * @param data - A Uint8Array or Uint8Array[]
   * @param txOptions - The transaction options
   */
  static fromBlockBodyData(data, txOptions = {}) {
    if (data instanceof Uint8Array) {
      return this.fromSerializedData(data, txOptions);
    } else if (Array.isArray(data)) {
      return LegacyTransaction.fromValuesArray(data, txOptions);
    } else {
      throw new Error("Cannot decode transaction: unknown type input");
    }
  }
  /**
   *  Method to retrieve a transaction from the provider
   * @param provider - a url string for a JSON-RPC provider or an Ethers JsonRPCProvider object
   * @param txHash - Transaction hash
   * @param txOptions - The transaction options
   * @returns the transaction specified by `txHash`
   */
  static async fromJsonRpcProvider(provider, txHash, txOptions) {
    const prov = getProvider(provider);
    const txData = await fetchFromProvider(prov, {
      method: "eth_getTransactionByHash",
      params: [txHash]
    });
    if (txData === null) {
      throw new Error("No data returned from provider");
    }
    return _TransactionFactory.fromRPC(txData, txOptions);
  }
  /**
   * Method to decode data retrieved from RPC, such as `eth_getTransactionByHash`
   * Note that this normalizes some of the parameters
   * @param txData The RPC-encoded data
   * @param txOptions The transaction options
   * @returns
   */
  static async fromRPC(txData, txOptions = {}) {
    return _TransactionFactory.fromTxData(normalizeTxParams(txData), txOptions);
  }
};
export {
  AccessListEIP2930Transaction,
  BlobEIP4844Transaction,
  Capability,
  EOACodeEIP7702Transaction,
  FeeMarketEIP1559Transaction,
  LegacyTransaction,
  TransactionFactory,
  TransactionType,
  isAccessList,
  isAccessListBytes,
  isAccessListEIP2930Tx,
  isAccessListEIP2930TxData,
  isAuthorizationList,
  isAuthorizationListBytes,
  isBlobEIP4844Tx,
  isBlobEIP4844TxData,
  isEOACodeEIP7702Tx,
  isEOACodeEIP7702TxData,
  isFeeMarketEIP1559Tx,
  isFeeMarketEIP1559TxData,
  isLegacyTx,
  isLegacyTxData
};
//# sourceMappingURL=esm-UMNPDMII.js.map
