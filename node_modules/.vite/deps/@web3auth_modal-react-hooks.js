import {
  require_lodash as require_lodash2
} from "./chunk-WULWOCVO.js";
import {
  require_client
} from "./chunk-DW227P2Q.js";
import "./chunk-IYNIHSXD.js";
import {
  LOGIN_PROVIDER,
  OpenloginAdapter,
  getOpenloginDefaultOptions
} from "./chunk-HMWBIZAX.js";
import {
  require_jsx_runtime
} from "./chunk-6PF5PHNV.js";
import {
  require_react
} from "./chunk-7SNDHR3H.js";
import {
  CommonJRPCProvider
} from "./chunk-5WR3TXTD.js";
import "./chunk-EUPFMFTY.js";
import "./chunk-K6CC7U6K.js";
import {
  bowser_default
} from "./chunk-66NAV3HW.js";
import "./chunk-656XUC5S.js";
import "./chunk-2I7FAV7Q.js";
import "./chunk-ML3C5VKE.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMES,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  CHAIN_NAMESPACES,
  EVM_ADAPTERS,
  PLUGIN_NAMESPACES,
  PLUGIN_STATUS,
  SOLANA_ADAPTERS,
  SafeEventEmitter,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  fetchProjectConfig,
  get,
  getChainConfig,
  loglevel,
  post,
  require_color,
  require_lodash,
  storageAvailable
} from "./chunk-K4C2RABW.js";
import "./chunk-GJBZJ4UL.js";
import {
  TORUS_LEGACY_NETWORK,
  TORUS_SAPPHIRE_NETWORK,
  _defineProperty,
  _objectSpread2,
  require_base64url
} from "./chunk-MBKDGBSM.js";
import "./chunk-ATDVI3CM.js";
import "./chunk-CFIX2DL5.js";
import {
  __commonJS,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/lodash.clonedeep/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module) {
    module.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// node_modules/qrcode-generator/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode-generator/qrcode.js"(exports, module) {
    var qrcode = function() {
      var qrcode2 = function(typeNumber, errorCorrectionLevel) {
        var PAD0 = 236;
        var PAD1 = 17;
        var _typeNumber = typeNumber;
        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = [];
        var _this = {};
        var makeImpl = function(test, maskPattern) {
          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);
          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);
          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }
          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
          }
          mapData(_dataCache, maskPattern);
        };
        var setupPositionProbePattern = function(row, col) {
          for (var r = -1; r <= 7; r += 1) {
            if (row + r <= -1 || _moduleCount <= row + r) continue;
            for (var c = -1; c <= 7; c += 1) {
              if (col + c <= -1 || _moduleCount <= col + c) continue;
              if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        };
        var getBestMaskPattern = function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i = 0; i < 8; i += 1) {
            makeImpl(true, i);
            var lostPoint = QRUtil.getLostPoint(_this);
            if (i == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }
          return pattern;
        };
        var setupTimingPattern = function() {
          for (var r = 8; r < _moduleCount - 8; r += 1) {
            if (_modules[r][6] != null) {
              continue;
            }
            _modules[r][6] = r % 2 == 0;
          }
          for (var c = 8; c < _moduleCount - 8; c += 1) {
            if (_modules[6][c] != null) {
              continue;
            }
            _modules[6][c] = c % 2 == 0;
          }
        };
        var setupPositionAdjustPattern = function() {
          var pos = QRUtil.getPatternPosition(_typeNumber);
          for (var i = 0; i < pos.length; i += 1) {
            for (var j = 0; j < pos.length; j += 1) {
              var row = pos[i];
              var col = pos[j];
              if (_modules[row][col] != null) {
                continue;
              }
              for (var r = -2; r <= 2; r += 1) {
                for (var c = -2; c <= 2; c += 1) {
                  if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
                    _modules[row + r][col + c] = true;
                  } else {
                    _modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };
        var setupTypeNumber = function(test) {
          var bits = QRUtil.getBCHTypeNumber(_typeNumber);
          for (var i = 0; i < 18; i += 1) {
            var mod = !test && (bits >> i & 1) == 1;
            _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
          }
          for (var i = 0; i < 18; i += 1) {
            var mod = !test && (bits >> i & 1) == 1;
            _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
          }
        };
        var setupTypeInfo = function(test, maskPattern) {
          var data = _errorCorrectionLevel << 3 | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
          for (var i = 0; i < 15; i += 1) {
            var mod = !test && (bits >> i & 1) == 1;
            if (i < 6) {
              _modules[i][8] = mod;
            } else if (i < 8) {
              _modules[i + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i][8] = mod;
            }
          }
          for (var i = 0; i < 15; i += 1) {
            var mod = !test && (bits >> i & 1) == 1;
            if (i < 8) {
              _modules[8][_moduleCount - i - 1] = mod;
            } else if (i < 9) {
              _modules[8][15 - i - 1 + 1] = mod;
            } else {
              _modules[8][15 - i - 1] = mod;
            }
          }
          _modules[_moduleCount - 8][8] = !test;
        };
        var mapData = function(data, maskPattern) {
          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);
          for (var col = _moduleCount - 1; col > 0; col -= 2) {
            if (col == 6) col -= 1;
            while (true) {
              for (var c = 0; c < 2; c += 1) {
                if (_modules[row][col - c] == null) {
                  var dark = false;
                  if (byteIndex < data.length) {
                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;
                  }
                  var mask = maskFunc(row, col - c);
                  if (mask) {
                    dark = !dark;
                  }
                  _modules[row][col - c] = dark;
                  bitIndex -= 1;
                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
        var createBytes = function(buffer, rsBlocks) {
          var offset = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);
          for (var r = 0; r < rsBlocks.length; r += 1) {
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (var i = 0; i < dcdata[r].length; i += 1) {
              dcdata[r][i] = 255 & buffer.getBuffer()[i + offset];
            }
            offset += dcCount;
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i = 0; i < ecdata[r].length; i += 1) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
            }
          }
          var totalCodeCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalCodeCount += rsBlocks[i].totalCount;
          }
          var data = new Array(totalCodeCount);
          var index = 0;
          for (var i = 0; i < maxDcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < dcdata[r].length) {
                data[index] = dcdata[r][i];
                index += 1;
              }
            }
          }
          for (var i = 0; i < maxEcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < ecdata[r].length) {
                data[index] = ecdata[r][i];
                index += 1;
              }
            }
          }
          return data;
        };
        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);
          var buffer = qrBitBuffer();
          for (var i = 0; i < dataList.length; i += 1) {
            var data = dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));
            data.write(buffer);
          }
          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalDataCount += rsBlocks[i].dataCount;
          }
          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw "code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")";
          }
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }
          while (true) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD1, 8);
          }
          return createBytes(buffer, rsBlocks);
        };
        _this.addData = function(data, mode) {
          mode = mode || "Byte";
          var newData = null;
          switch (mode) {
            case "Numeric":
              newData = qrNumber(data);
              break;
            case "Alphanumeric":
              newData = qrAlphaNum(data);
              break;
            case "Byte":
              newData = qr8BitByte(data);
              break;
            case "Kanji":
              newData = qrKanji(data);
              break;
            default:
              throw "mode:" + mode;
          }
          _dataList.push(newData);
          _dataCache = null;
        };
        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw row + "," + col;
          }
          return _modules[row][col];
        };
        _this.getModuleCount = function() {
          return _moduleCount;
        };
        _this.make = function() {
          if (_typeNumber < 1) {
            var typeNumber2 = 1;
            for (; typeNumber2 < 40; typeNumber2++) {
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);
              var buffer = qrBitBuffer();
              for (var i = 0; i < _dataList.length; i++) {
                var data = _dataList[i];
                buffer.put(data.getMode(), 4);
                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));
                data.write(buffer);
              }
              var totalDataCount = 0;
              for (var i = 0; i < rsBlocks.length; i++) {
                totalDataCount += rsBlocks[i].dataCount;
              }
              if (buffer.getLengthInBits() <= totalDataCount * 8) {
                break;
              }
            }
            _typeNumber = typeNumber2;
          }
          makeImpl(false, getBestMaskPattern());
        };
        _this.createTableTag = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var qrHtml = "";
          qrHtml += '<table style="';
          qrHtml += " border-width: 0px; border-style: none;";
          qrHtml += " border-collapse: collapse;";
          qrHtml += " padding: 0px; margin: " + margin + "px;";
          qrHtml += '">';
          qrHtml += "<tbody>";
          for (var r = 0; r < _this.getModuleCount(); r += 1) {
            qrHtml += "<tr>";
            for (var c = 0; c < _this.getModuleCount(); c += 1) {
              qrHtml += '<td style="';
              qrHtml += " border-width: 0px; border-style: none;";
              qrHtml += " border-collapse: collapse;";
              qrHtml += " padding: 0px; margin: 0px;";
              qrHtml += " width: " + cellSize + "px;";
              qrHtml += " height: " + cellSize + "px;";
              qrHtml += " background-color: ";
              qrHtml += _this.isDark(r, c) ? "#000000" : "#ffffff";
              qrHtml += ";";
              qrHtml += '"/>';
            }
            qrHtml += "</tr>";
          }
          qrHtml += "</tbody>";
          qrHtml += "</table>";
          return qrHtml;
        };
        _this.createSvgTag = function(cellSize, margin, alt, title) {
          var opts = {};
          if (typeof arguments[0] == "object") {
            opts = arguments[0];
            cellSize = opts.cellSize;
            margin = opts.margin;
            alt = opts.alt;
            title = opts.title;
          }
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          alt = typeof alt === "string" ? { text: alt } : alt || {};
          alt.text = alt.text || null;
          alt.id = alt.text ? alt.id || "qrcode-description" : null;
          title = typeof title === "string" ? { text: title } : title || {};
          title.text = title.text || null;
          title.id = title.text ? title.id || "qrcode-title" : null;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var c, mc, r, mr, qrSvg = "", rect;
          rect = "l" + cellSize + ",0 0," + cellSize + " -" + cellSize + ",0 0,-" + cellSize + "z ";
          qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
          qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : "";
          qrSvg += ' viewBox="0 0 ' + size + " " + size + '" ';
          qrSvg += ' preserveAspectRatio="xMinYMin meet"';
          qrSvg += title.text || alt.text ? ' role="img" aria-labelledby="' + escapeXml([title.id, alt.id].join(" ").trim()) + '"' : "";
          qrSvg += ">";
          qrSvg += title.text ? '<title id="' + escapeXml(title.id) + '">' + escapeXml(title.text) + "</title>" : "";
          qrSvg += alt.text ? '<description id="' + escapeXml(alt.id) + '">' + escapeXml(alt.text) + "</description>" : "";
          qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
          qrSvg += '<path d="';
          for (r = 0; r < _this.getModuleCount(); r += 1) {
            mr = r * cellSize + margin;
            for (c = 0; c < _this.getModuleCount(); c += 1) {
              if (_this.isDark(r, c)) {
                mc = c * cellSize + margin;
                qrSvg += "M" + mc + "," + mr + rect;
              }
            }
          }
          qrSvg += '" stroke="transparent" fill="black"/>';
          qrSvg += "</svg>";
          return qrSvg;
        };
        _this.createDataURL = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          return createDataURL(size, size, function(x, y) {
            if (min <= x && x < max && min <= y && y < max) {
              var c = Math.floor((x - min) / cellSize);
              var r = Math.floor((y - min) / cellSize);
              return _this.isDark(r, c) ? 0 : 1;
            } else {
              return 1;
            }
          });
        };
        _this.createImgTag = function(cellSize, margin, alt) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var img = "";
          img += "<img";
          img += ' src="';
          img += _this.createDataURL(cellSize, margin);
          img += '"';
          img += ' width="';
          img += size;
          img += '"';
          img += ' height="';
          img += size;
          img += '"';
          if (alt) {
            img += ' alt="';
            img += escapeXml(alt);
            img += '"';
          }
          img += "/>";
          return img;
        };
        var escapeXml = function(s) {
          var escaped = "";
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charAt(i);
            switch (c) {
              case "<":
                escaped += "&lt;";
                break;
              case ">":
                escaped += "&gt;";
                break;
              case "&":
                escaped += "&amp;";
                break;
              case '"':
                escaped += "&quot;";
                break;
              default:
                escaped += c;
                break;
            }
          }
          return escaped;
        };
        var _createHalfASCII = function(margin) {
          var cellSize = 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          var y, x, r1, r2, p;
          var blocks = {
            "██": "█",
            "█ ": "▀",
            " █": "▄",
            "  ": " "
          };
          var blocksLastLineNoMargin = {
            "██": "▀",
            "█ ": "▀",
            " █": " ",
            "  ": " "
          };
          var ascii = "";
          for (y = 0; y < size; y += 2) {
            r1 = Math.floor((y - min) / cellSize);
            r2 = Math.floor((y + 1 - min) / cellSize);
            for (x = 0; x < size; x += 1) {
              p = "█";
              if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
                p = " ";
              }
              if (min <= x && x < max && min <= y + 1 && y + 1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
                p += " ";
              } else {
                p += "█";
              }
              ascii += margin < 1 && y + 1 >= max ? blocksLastLineNoMargin[p] : blocks[p];
            }
            ascii += "\n";
          }
          if (size % 2 && margin > 0) {
            return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join("▀");
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.createASCII = function(cellSize, margin) {
          cellSize = cellSize || 1;
          if (cellSize < 2) {
            return _createHalfASCII(margin);
          }
          cellSize -= 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          var y, x, r, p;
          var white = Array(cellSize + 1).join("██");
          var black = Array(cellSize + 1).join("  ");
          var ascii = "";
          var line = "";
          for (y = 0; y < size; y += 1) {
            r = Math.floor((y - min) / cellSize);
            line = "";
            for (x = 0; x < size; x += 1) {
              p = 1;
              if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
                p = 0;
              }
              line += p ? white : black;
            }
            for (r = 0; r < cellSize; r += 1) {
              ascii += line + "\n";
            }
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.renderTo2dContext = function(context, cellSize) {
          cellSize = cellSize || 2;
          var length = _this.getModuleCount();
          for (var row = 0; row < length; row++) {
            for (var col = 0; col < length; col++) {
              context.fillStyle = _this.isDark(row, col) ? "black" : "white";
              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
            }
          }
        };
        return _this;
      };
      qrcode2.stringToBytesFuncs = {
        "default": function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            bytes.push(c & 255);
          }
          return bytes;
        }
      };
      qrcode2.stringToBytes = qrcode2.stringToBytesFuncs["default"];
      qrcode2.createStringToBytes = function(unicodeData, numChars) {
        var unicodeMap = function() {
          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b = bin.read();
            if (b == -1) throw "eof";
            return b;
          };
          var count = 0;
          var unicodeMap2 = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b2 = read();
            var b3 = read();
            var k = String.fromCharCode(b0 << 8 | b1);
            var v = b2 << 8 | b3;
            unicodeMap2[k] = v;
            count += 1;
          }
          if (count != numChars) {
            throw count + " != " + numChars;
          }
          return unicodeMap2;
        }();
        var unknownChar = "?".charCodeAt(0);
        return function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            if (c < 128) {
              bytes.push(c);
            } else {
              var b = unicodeMap[s.charAt(i)];
              if (typeof b == "number") {
                if ((b & 255) == b) {
                  bytes.push(b);
                } else {
                  bytes.push(b >>> 8);
                  bytes.push(b & 255);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };
      var QRMode = {
        MODE_NUMBER: 1 << 0,
        MODE_ALPHA_NUM: 1 << 1,
        MODE_8BIT_BYTE: 1 << 2,
        MODE_KANJI: 1 << 3
      };
      var QRErrorCorrectionLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
      var QRMaskPattern = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var QRUtil = function() {
        var PATTERN_POSITION_TABLE = [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ];
        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
        var _this = {};
        var getBCHDigit = function(data) {
          var digit = 0;
          while (data != 0) {
            digit += 1;
            data >>>= 1;
          }
          return digit;
        };
        _this.getBCHTypeInfo = function(data) {
          var d = data << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
            d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);
          }
          return (data << 10 | d) ^ G15_MASK;
        };
        _this.getBCHTypeNumber = function(data) {
          var d = data << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
            d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);
          }
          return data << 12 | d;
        };
        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };
        _this.getMaskFunction = function(maskPattern) {
          switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
              return function(i, j) {
                return (i + j) % 2 == 0;
              };
            case QRMaskPattern.PATTERN001:
              return function(i, j) {
                return i % 2 == 0;
              };
            case QRMaskPattern.PATTERN010:
              return function(i, j) {
                return j % 3 == 0;
              };
            case QRMaskPattern.PATTERN011:
              return function(i, j) {
                return (i + j) % 3 == 0;
              };
            case QRMaskPattern.PATTERN100:
              return function(i, j) {
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
              };
            case QRMaskPattern.PATTERN101:
              return function(i, j) {
                return i * j % 2 + i * j % 3 == 0;
              };
            case QRMaskPattern.PATTERN110:
              return function(i, j) {
                return (i * j % 2 + i * j % 3) % 2 == 0;
              };
            case QRMaskPattern.PATTERN111:
              return function(i, j) {
                return (i * j % 3 + (i + j) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + maskPattern;
          }
        };
        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i = 0; i < errorCorrectLength; i += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));
          }
          return a;
        };
        _this.getLengthInBits = function(mode, type) {
          if (1 <= type && type < 10) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 10;
              case QRMode.MODE_ALPHA_NUM:
                return 9;
              case QRMode.MODE_8BIT_BYTE:
                return 8;
              case QRMode.MODE_KANJI:
                return 8;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 27) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 12;
              case QRMode.MODE_ALPHA_NUM:
                return 11;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 10;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 41) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 14;
              case QRMode.MODE_ALPHA_NUM:
                return 13;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 12;
              default:
                throw "mode:" + mode;
            }
          } else {
            throw "type:" + type;
          }
        };
        _this.getLostPoint = function(qrcode3) {
          var moduleCount = qrcode3.getModuleCount();
          var lostPoint = 0;
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {
              var sameCount = 0;
              var dark = qrcode3.isDark(row, col);
              for (var r = -1; r <= 1; r += 1) {
                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }
                for (var c = -1; c <= 1; c += 1) {
                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }
                  if (r == 0 && c == 0) {
                    continue;
                  }
                  if (dark == qrcode3.isDark(row + r, col + c)) {
                    sameCount += 1;
                  }
                }
              }
              if (sameCount > 5) {
                lostPoint += 3 + sameCount - 5;
              }
            }
          }
          ;
          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode3.isDark(row, col)) count += 1;
              if (qrcode3.isDark(row + 1, col)) count += 1;
              if (qrcode3.isDark(row, col + 1)) count += 1;
              if (qrcode3.isDark(row + 1, col + 1)) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode3.isDark(row, col) && !qrcode3.isDark(row, col + 1) && qrcode3.isDark(row, col + 2) && qrcode3.isDark(row, col + 3) && qrcode3.isDark(row, col + 4) && !qrcode3.isDark(row, col + 5) && qrcode3.isDark(row, col + 6)) {
                lostPoint += 40;
              }
            }
          }
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode3.isDark(row, col) && !qrcode3.isDark(row + 1, col) && qrcode3.isDark(row + 2, col) && qrcode3.isDark(row + 3, col) && qrcode3.isDark(row + 4, col) && !qrcode3.isDark(row + 5, col) && qrcode3.isDark(row + 6, col)) {
                lostPoint += 40;
              }
            }
          }
          var darkCount = 0;
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode3.isDark(row, col)) {
                darkCount += 1;
              }
            }
          }
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;
          return lostPoint;
        };
        return _this;
      }();
      var QRMath = function() {
        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);
        for (var i = 0; i < 8; i += 1) {
          EXP_TABLE[i] = 1 << i;
        }
        for (var i = 8; i < 256; i += 1) {
          EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];
        }
        for (var i = 0; i < 255; i += 1) {
          LOG_TABLE[EXP_TABLE[i]] = i;
        }
        var _this = {};
        _this.glog = function(n) {
          if (n < 1) {
            throw "glog(" + n + ")";
          }
          return LOG_TABLE[n];
        };
        _this.gexp = function(n) {
          while (n < 0) {
            n += 255;
          }
          while (n >= 256) {
            n -= 255;
          }
          return EXP_TABLE[n];
        };
        return _this;
      }();
      function qrPolynomial(num, shift) {
        if (typeof num.length == "undefined") {
          throw num.length + "/" + shift;
        }
        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num2 = new Array(num.length - offset + shift);
          for (var i = 0; i < num.length - offset; i += 1) {
            _num2[i] = num[i + offset];
          }
          return _num2;
        }();
        var _this = {};
        _this.getAt = function(index) {
          return _num[index];
        };
        _this.getLength = function() {
          return _num.length;
        };
        _this.multiply = function(e2) {
          var num2 = new Array(_this.getLength() + e2.getLength() - 1);
          for (var i = 0; i < _this.getLength(); i += 1) {
            for (var j = 0; j < e2.getLength(); j += 1) {
              num2[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e2.getAt(j)));
            }
          }
          return qrPolynomial(num2, 0);
        };
        _this.mod = function(e2) {
          if (_this.getLength() - e2.getLength() < 0) {
            return _this;
          }
          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e2.getAt(0));
          var num2 = new Array(_this.getLength());
          for (var i = 0; i < _this.getLength(); i += 1) {
            num2[i] = _this.getAt(i);
          }
          for (var i = 0; i < e2.getLength(); i += 1) {
            num2[i] ^= QRMath.gexp(QRMath.glog(e2.getAt(i)) + ratio);
          }
          return qrPolynomial(num2, 0).mod(e2);
        };
        return _this;
      }
      ;
      var QRRSBlock = function() {
        var RS_BLOCK_TABLE = [
          // L
          // M
          // Q
          // H
          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],
          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],
          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],
          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],
          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],
          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],
          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],
          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],
          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],
          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],
          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],
          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],
          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],
          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],
          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],
          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],
          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],
          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],
          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],
          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],
          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],
          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],
          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],
          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],
          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],
          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],
          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],
          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],
          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],
          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],
          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],
          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],
          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],
          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],
          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],
          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],
          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],
          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],
          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],
          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];
        var qrRSBlock = function(totalCount, dataCount) {
          var _this2 = {};
          _this2.totalCount = totalCount;
          _this2.dataCount = dataCount;
          return _this2;
        };
        var _this = {};
        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {
          switch (errorCorrectionLevel) {
            case QRErrorCorrectionLevel.L:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case QRErrorCorrectionLevel.M:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case QRErrorCorrectionLevel.Q:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case QRErrorCorrectionLevel.H:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {
          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);
          if (typeof rsBlock == "undefined") {
            throw "bad rs block @ typeNumber:" + typeNumber + "/errorCorrectionLevel:" + errorCorrectionLevel;
          }
          var length = rsBlock.length / 3;
          var list = [];
          for (var i = 0; i < length; i += 1) {
            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];
            for (var j = 0; j < count; j += 1) {
              list.push(qrRSBlock(totalCount, dataCount));
            }
          }
          return list;
        };
        return _this;
      }();
      var qrBitBuffer = function() {
        var _buffer = [];
        var _length = 0;
        var _this = {};
        _this.getBuffer = function() {
          return _buffer;
        };
        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
        };
        _this.put = function(num, length) {
          for (var i = 0; i < length; i += 1) {
            _this.putBit((num >>> length - i - 1 & 1) == 1);
          }
        };
        _this.getLengthInBits = function() {
          return _length;
        };
        _this.putBit = function(bit) {
          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }
          if (bit) {
            _buffer[bufIndex] |= 128 >>> _length % 8;
          }
          _length += 1;
        };
        return _this;
      };
      var qrNumber = function(data) {
        var _mode = QRMode.MODE_NUMBER;
        var _data = data;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _data.length;
        };
        _this.write = function(buffer) {
          var data2 = _data;
          var i = 0;
          while (i + 2 < data2.length) {
            buffer.put(strToNum(data2.substring(i, i + 3)), 10);
            i += 3;
          }
          if (i < data2.length) {
            if (data2.length - i == 1) {
              buffer.put(strToNum(data2.substring(i, i + 1)), 4);
            } else if (data2.length - i == 2) {
              buffer.put(strToNum(data2.substring(i, i + 2)), 7);
            }
          }
        };
        var strToNum = function(s) {
          var num = 0;
          for (var i = 0; i < s.length; i += 1) {
            num = num * 10 + chatToNum(s.charAt(i));
          }
          return num;
        };
        var chatToNum = function(c) {
          if ("0" <= c && c <= "9") {
            return c.charCodeAt(0) - "0".charCodeAt(0);
          }
          throw "illegal char :" + c;
        };
        return _this;
      };
      var qrAlphaNum = function(data) {
        var _mode = QRMode.MODE_ALPHA_NUM;
        var _data = data;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _data.length;
        };
        _this.write = function(buffer) {
          var s = _data;
          var i = 0;
          while (i + 1 < s.length) {
            buffer.put(
              getCode(s.charAt(i)) * 45 + getCode(s.charAt(i + 1)),
              11
            );
            i += 2;
          }
          if (i < s.length) {
            buffer.put(getCode(s.charAt(i)), 6);
          }
        };
        var getCode = function(c) {
          if ("0" <= c && c <= "9") {
            return c.charCodeAt(0) - "0".charCodeAt(0);
          } else if ("A" <= c && c <= "Z") {
            return c.charCodeAt(0) - "A".charCodeAt(0) + 10;
          } else {
            switch (c) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + c;
            }
          }
        };
        return _this;
      };
      var qr8BitByte = function(data) {
        var _mode = QRMode.MODE_8BIT_BYTE;
        var _data = data;
        var _bytes = qrcode2.stringToBytes(data);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _bytes.length;
        };
        _this.write = function(buffer) {
          for (var i = 0; i < _bytes.length; i += 1) {
            buffer.put(_bytes[i], 8);
          }
        };
        return _this;
      };
      var qrKanji = function(data) {
        var _mode = QRMode.MODE_KANJI;
        var _data = data;
        var stringToBytes = qrcode2.stringToBytesFuncs["SJIS"];
        if (!stringToBytes) {
          throw "sjis not supported.";
        }
        !function(c, code) {
          var test = stringToBytes(c);
          if (test.length != 2 || (test[0] << 8 | test[1]) != code) {
            throw "sjis not supported.";
          }
        }("友", 38726);
        var _bytes = stringToBytes(data);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return ~~(_bytes.length / 2);
        };
        _this.write = function(buffer) {
          var data2 = _bytes;
          var i = 0;
          while (i + 1 < data2.length) {
            var c = (255 & data2[i]) << 8 | 255 & data2[i + 1];
            if (33088 <= c && c <= 40956) {
              c -= 33088;
            } else if (57408 <= c && c <= 60351) {
              c -= 49472;
            } else {
              throw "illegal char at " + (i + 1) + "/" + c;
            }
            c = (c >>> 8 & 255) * 192 + (c & 255);
            buffer.put(c, 13);
            i += 2;
          }
          if (i < data2.length) {
            throw "illegal char at " + (i + 1);
          }
        };
        return _this;
      };
      var byteArrayOutputStream = function() {
        var _bytes = [];
        var _this = {};
        _this.writeByte = function(b) {
          _bytes.push(b & 255);
        };
        _this.writeShort = function(i) {
          _this.writeByte(i);
          _this.writeByte(i >>> 8);
        };
        _this.writeBytes = function(b, off, len) {
          off = off || 0;
          len = len || b.length;
          for (var i = 0; i < len; i += 1) {
            _this.writeByte(b[i + off]);
          }
        };
        _this.writeString = function(s) {
          for (var i = 0; i < s.length; i += 1) {
            _this.writeByte(s.charCodeAt(i));
          }
        };
        _this.toByteArray = function() {
          return _bytes;
        };
        _this.toString = function() {
          var s = "";
          s += "[";
          for (var i = 0; i < _bytes.length; i += 1) {
            if (i > 0) {
              s += ",";
            }
            s += _bytes[i];
          }
          s += "]";
          return s;
        };
        return _this;
      };
      var base64EncodeOutputStream = function() {
        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = "";
        var _this = {};
        var writeEncoded = function(b) {
          _base64 += String.fromCharCode(encode(b & 63));
        };
        var encode = function(n) {
          if (n < 0) {
          } else if (n < 26) {
            return 65 + n;
          } else if (n < 52) {
            return 97 + (n - 26);
          } else if (n < 62) {
            return 48 + (n - 52);
          } else if (n == 62) {
            return 43;
          } else if (n == 63) {
            return 47;
          }
          throw "n:" + n;
        };
        _this.writeByte = function(n) {
          _buffer = _buffer << 8 | n & 255;
          _buflen += 8;
          _length += 1;
          while (_buflen >= 6) {
            writeEncoded(_buffer >>> _buflen - 6);
            _buflen -= 6;
          }
        };
        _this.flush = function() {
          if (_buflen > 0) {
            writeEncoded(_buffer << 6 - _buflen);
            _buffer = 0;
            _buflen = 0;
          }
          if (_length % 3 != 0) {
            var padlen = 3 - _length % 3;
            for (var i = 0; i < padlen; i += 1) {
              _base64 += "=";
            }
          }
        };
        _this.toString = function() {
          return _base64;
        };
        return _this;
      };
      var base64DecodeInputStream = function(str) {
        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;
        var _this = {};
        _this.read = function() {
          while (_buflen < 8) {
            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw "unexpected end of file./" + _buflen;
            }
            var c = _str.charAt(_pos);
            _pos += 1;
            if (c == "=") {
              _buflen = 0;
              return -1;
            } else if (c.match(/^\s$/)) {
              continue;
            }
            _buffer = _buffer << 6 | decode(c.charCodeAt(0));
            _buflen += 6;
          }
          var n = _buffer >>> _buflen - 8 & 255;
          _buflen -= 8;
          return n;
        };
        var decode = function(c) {
          if (65 <= c && c <= 90) {
            return c - 65;
          } else if (97 <= c && c <= 122) {
            return c - 97 + 26;
          } else if (48 <= c && c <= 57) {
            return c - 48 + 52;
          } else if (c == 43) {
            return 62;
          } else if (c == 47) {
            return 63;
          } else {
            throw "c:" + c;
          }
        };
        return _this;
      };
      var gifImage = function(width, height) {
        var _width = width;
        var _height = height;
        var _data = new Array(width * height);
        var _this = {};
        _this.setPixel = function(x, y, pixel) {
          _data[y * _width + x] = pixel;
        };
        _this.write = function(out) {
          out.writeString("GIF87a");
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(128);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(255);
          out.writeByte(255);
          out.writeByte(255);
          out.writeString(",");
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);
          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);
          out.writeByte(lzwMinCodeSize);
          var offset = 0;
          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }
          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0);
          out.writeString(";");
        };
        var bitOutputStream = function(out) {
          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;
          var _this2 = {};
          _this2.write = function(data, length) {
            if (data >>> length != 0) {
              throw "length over";
            }
            while (_bitLength + length >= 8) {
              _out.writeByte(255 & (data << _bitLength | _bitBuffer));
              length -= 8 - _bitLength;
              data >>>= 8 - _bitLength;
              _bitBuffer = 0;
              _bitLength = 0;
            }
            _bitBuffer = data << _bitLength | _bitBuffer;
            _bitLength = _bitLength + length;
          };
          _this2.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };
          return _this2;
        };
        var getLZWRaster = function(lzwMinCodeSize) {
          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;
          var table = lzwTable();
          for (var i = 0; i < clearCode; i += 1) {
            table.add(String.fromCharCode(i));
          }
          table.add(String.fromCharCode(clearCode));
          table.add(String.fromCharCode(endCode));
          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);
          bitOut.write(clearCode, bitLength);
          var dataIndex = 0;
          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;
          while (dataIndex < _data.length) {
            var c = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;
            if (table.contains(s + c)) {
              s = s + c;
            } else {
              bitOut.write(table.indexOf(s), bitLength);
              if (table.size() < 4095) {
                if (table.size() == 1 << bitLength) {
                  bitLength += 1;
                }
                table.add(s + c);
              }
              s = c;
            }
          }
          bitOut.write(table.indexOf(s), bitLength);
          bitOut.write(endCode, bitLength);
          bitOut.flush();
          return byteOut.toByteArray();
        };
        var lzwTable = function() {
          var _map = {};
          var _size = 0;
          var _this2 = {};
          _this2.add = function(key) {
            if (_this2.contains(key)) {
              throw "dup key:" + key;
            }
            _map[key] = _size;
            _size += 1;
          };
          _this2.size = function() {
            return _size;
          };
          _this2.indexOf = function(key) {
            return _map[key];
          };
          _this2.contains = function(key) {
            return typeof _map[key] != "undefined";
          };
          return _this2;
        };
        return _this;
      };
      var createDataURL = function(width, height, getPixel) {
        var gif = gifImage(width, height);
        for (var y = 0; y < height; y += 1) {
          for (var x = 0; x < width; x += 1) {
            gif.setPixel(x, y, getPixel(x, y));
          }
        }
        var b = byteArrayOutputStream();
        gif.write(b);
        var base64 = base64EncodeOutputStream();
        var bytes = b.toByteArray();
        for (var i = 0; i < bytes.length; i += 1) {
          base64.writeByte(bytes[i]);
        }
        base64.flush();
        return "data:image/gif;base64," + base64;
      };
      return qrcode2;
    }();
    !function() {
      qrcode.stringToBytesFuncs["UTF-8"] = function(s) {
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i = 0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 128) utf8.push(charcode);
            else if (charcode < 2048) {
              utf8.push(
                192 | charcode >> 6,
                128 | charcode & 63
              );
            } else if (charcode < 55296 || charcode >= 57344) {
              utf8.push(
                224 | charcode >> 12,
                128 | charcode >> 6 & 63,
                128 | charcode & 63
              );
            } else {
              i++;
              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
              utf8.push(
                240 | charcode >> 18,
                128 | charcode >> 12 & 63,
                128 | charcode >> 6 & 63,
                128 | charcode & 63
              );
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };
    }();
    (function(factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      }
    })(function() {
      return qrcode;
    });
  }
});

// node_modules/react-qrcode-logo/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-qrcode-logo/dist/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var isEqual = require_lodash2();
    var qrGenerator = require_qrcode();
    var React = require_react();
    var QRCode2 = (
      /** @class */
      function(_super) {
        __extends(QRCode3, _super);
        function QRCode3(props) {
          var _this = _super.call(this, props) || this;
          _this.canvasRef = React.createRef();
          return _this;
        }
        QRCode3.prototype.download = function(fileType, fileName) {
          if (this.canvasRef.current) {
            var mimeType = void 0;
            switch (fileType) {
              case "jpg":
                mimeType = "image/jpeg";
                break;
              case "webp":
                mimeType = "image/webp";
                break;
              case "png":
              default:
                mimeType = "image/png";
                break;
            }
            var url = this.canvasRef.current.toDataURL(mimeType, 1);
            var link = document.createElement("a");
            link.download = fileName !== null && fileName !== void 0 ? fileName : "react-qrcode-logo";
            link.href = url;
            link.click();
          }
        };
        QRCode3.prototype.utf16to8 = function(str) {
          var out = "", i, c;
          var len = str.length;
          for (i = 0; i < len; i++) {
            c = str.charCodeAt(i);
            if (c >= 1 && c <= 127) {
              out += str.charAt(i);
            } else if (c > 2047) {
              out += String.fromCharCode(224 | c >> 12 & 15);
              out += String.fromCharCode(128 | c >> 6 & 63);
              out += String.fromCharCode(128 | c >> 0 & 63);
            } else {
              out += String.fromCharCode(192 | c >> 6 & 31);
              out += String.fromCharCode(128 | c >> 0 & 63);
            }
          }
          return out;
        };
        QRCode3.prototype.drawRoundedSquare = function(lineWidth, x, y, size, color, radii, fill, ctx) {
          ctx.lineWidth = lineWidth;
          ctx.fillStyle = color;
          ctx.strokeStyle = color;
          y += lineWidth / 2;
          x += lineWidth / 2;
          size -= lineWidth;
          if (!Array.isArray(radii)) {
            radii = [radii, radii, radii, radii];
          }
          radii = radii.map(function(r) {
            r = Math.min(r, size / 2);
            return r < 0 ? 0 : r;
          });
          var rTopLeft = radii[0] || 0;
          var rTopRight = radii[1] || 0;
          var rBottomRight = radii[2] || 0;
          var rBottomLeft = radii[3] || 0;
          ctx.beginPath();
          ctx.moveTo(x + rTopLeft, y);
          ctx.lineTo(x + size - rTopRight, y);
          if (rTopRight)
            ctx.quadraticCurveTo(x + size, y, x + size, y + rTopRight);
          ctx.lineTo(x + size, y + size - rBottomRight);
          if (rBottomRight)
            ctx.quadraticCurveTo(x + size, y + size, x + size - rBottomRight, y + size);
          ctx.lineTo(x + rBottomLeft, y + size);
          if (rBottomLeft)
            ctx.quadraticCurveTo(x, y + size, x, y + size - rBottomLeft);
          ctx.lineTo(x, y + rTopLeft);
          if (rTopLeft)
            ctx.quadraticCurveTo(x, y, x + rTopLeft, y);
          ctx.closePath();
          ctx.stroke();
          if (fill) {
            ctx.fill();
          }
        };
        QRCode3.prototype.drawPositioningPattern = function(ctx, cellSize, offset, row, col, color, radii) {
          if (radii === void 0) {
            radii = [0, 0, 0, 0];
          }
          var lineWidth = Math.ceil(cellSize);
          var radiiOuter;
          var radiiInner;
          if (typeof radii !== "number" && !Array.isArray(radii)) {
            radiiOuter = radii.outer || 0;
            radiiInner = radii.inner || 0;
          } else {
            radiiOuter = radii;
            radiiInner = radiiOuter;
          }
          var colorOuter;
          var colorInner;
          if (typeof color !== "string") {
            colorOuter = color.outer;
            colorInner = color.inner;
          } else {
            colorOuter = color;
            colorInner = color;
          }
          var y = row * cellSize + offset;
          var x = col * cellSize + offset;
          var size = cellSize * 7;
          this.drawRoundedSquare(lineWidth, x, y, size, colorOuter, radiiOuter, false, ctx);
          size = cellSize * 3;
          y += cellSize * 2;
          x += cellSize * 2;
          this.drawRoundedSquare(lineWidth, x, y, size, colorInner, radiiInner, true, ctx);
        };
        ;
        QRCode3.prototype.isInPositioninZone = function(col, row, zones) {
          return zones.some(function(zone) {
            return row >= zone.row && row <= zone.row + 7 && col >= zone.col && col <= zone.col + 7;
          });
        };
        QRCode3.prototype.transformPixelLengthIntoNumberOfCells = function(pixelLength, cellSize) {
          return pixelLength / cellSize;
        };
        QRCode3.prototype.isCoordinateInImage = function(col, row, dWidthLogo, dHeightLogo, dxLogo, dyLogo, cellSize, logoImage) {
          if (logoImage) {
            var numberOfCellsMargin = 2;
            var firstRowOfLogo = this.transformPixelLengthIntoNumberOfCells(dxLogo, cellSize);
            var firstColumnOfLogo = this.transformPixelLengthIntoNumberOfCells(dyLogo, cellSize);
            var logoWidthInCells = this.transformPixelLengthIntoNumberOfCells(dWidthLogo, cellSize) - 1;
            var logoHeightInCells = this.transformPixelLengthIntoNumberOfCells(dHeightLogo, cellSize) - 1;
            return row >= firstRowOfLogo - numberOfCellsMargin && row <= firstRowOfLogo + logoWidthInCells + numberOfCellsMargin && col >= firstColumnOfLogo - numberOfCellsMargin && col <= firstColumnOfLogo + logoHeightInCells + numberOfCellsMargin;
          } else {
            return false;
          }
        };
        QRCode3.prototype.shouldComponentUpdate = function(nextProps) {
          return !isEqual(this.props, nextProps);
        };
        QRCode3.prototype.componentDidMount = function() {
          this.update();
        };
        QRCode3.prototype.componentDidUpdate = function() {
          this.update();
        };
        QRCode3.prototype.update = function() {
          var _a;
          var _b = this.props, value = _b.value, ecLevel = _b.ecLevel, enableCORS = _b.enableCORS, bgColor = _b.bgColor, fgColor = _b.fgColor, logoImage = _b.logoImage, logoOpacity = _b.logoOpacity, logoOnLoad = _b.logoOnLoad, removeQrCodeBehindLogo = _b.removeQrCodeBehindLogo, qrStyle = _b.qrStyle, eyeRadius = _b.eyeRadius, eyeColor = _b.eyeColor, logoPaddingStyle = _b.logoPaddingStyle;
          var size = +this.props.size;
          var quietZone = +this.props.quietZone;
          var logoWidth = this.props.logoWidth ? +this.props.logoWidth : 0;
          var logoHeight = this.props.logoHeight ? +this.props.logoHeight : 0;
          var logoPadding = this.props.logoPadding ? +this.props.logoPadding : 0;
          var qrCode = qrGenerator(0, ecLevel);
          qrCode.addData(this.utf16to8(value));
          qrCode.make();
          var canvas = (_a = this.canvasRef) === null || _a === void 0 ? void 0 : _a.current;
          var ctx = canvas.getContext("2d");
          var canvasSize = size + 2 * quietZone;
          var length = qrCode.getModuleCount();
          var cellSize = size / length;
          var scale = window.devicePixelRatio || 1;
          canvas.height = canvas.width = canvasSize * scale;
          ctx.scale(scale, scale);
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, canvasSize, canvasSize);
          var offset = quietZone;
          var positioningZones = [
            { row: 0, col: 0 },
            { row: 0, col: length - 7 },
            { row: length - 7, col: 0 }
          ];
          ctx.strokeStyle = fgColor;
          if (qrStyle === "dots") {
            ctx.fillStyle = fgColor;
            var radius = cellSize / 2;
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  ctx.beginPath();
                  ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius / 100 * 75, 0, 2 * Math.PI, false);
                  ctx.closePath();
                  ctx.fill();
                }
              }
            }
          } else if (qrStyle === "fluid") {
            var radius = Math.ceil(cellSize / 2);
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  var roundedCorners = [false, false, false, false];
                  if (row > 0 && !qrCode.isDark(row - 1, col) && (col > 0 && !qrCode.isDark(row, col - 1)))
                    roundedCorners[0] = true;
                  if (row > 0 && !qrCode.isDark(row - 1, col) && (col < length - 1 && !qrCode.isDark(row, col + 1)))
                    roundedCorners[1] = true;
                  if (row < length - 1 && !qrCode.isDark(row + 1, col) && (col < length - 1 && !qrCode.isDark(row, col + 1)))
                    roundedCorners[2] = true;
                  if (row < length - 1 && !qrCode.isDark(row + 1, col) && (col > 0 && !qrCode.isDark(row, col - 1)))
                    roundedCorners[3] = true;
                  var w = Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize);
                  var h = Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize);
                  ctx.fillStyle = fgColor;
                  ctx.beginPath();
                  ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius, 0, 2 * Math.PI, false);
                  ctx.closePath();
                  ctx.fill();
                  if (!roundedCorners[0])
                    ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w / 2, h / 2);
                  if (!roundedCorners[1])
                    ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset, w / 2, h / 2);
                  if (!roundedCorners[2])
                    ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);
                  if (!roundedCorners[3])
                    ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);
                }
              }
            }
          } else {
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  ctx.fillStyle = fgColor;
                  var w = Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize);
                  var h = Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize);
                  ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w, h);
                }
              }
            }
          }
          for (var i = 0; i < 3; i++) {
            var _c = positioningZones[i], row = _c.row, col = _c.col;
            var radii = eyeRadius;
            var color = void 0;
            if (Array.isArray(radii)) {
              radii = radii[i];
            }
            if (typeof radii == "number") {
              radii = [radii, radii, radii, radii];
            }
            if (!eyeColor) {
              color = fgColor;
            } else {
              if (Array.isArray(eyeColor)) {
                color = eyeColor[i];
              } else {
                color = eyeColor;
              }
            }
            this.drawPositioningPattern(ctx, cellSize, offset, row, col, color, radii);
          }
          if (logoImage) {
            var image_1 = new Image();
            if (enableCORS) {
              image_1.crossOrigin = "Anonymous";
            }
            image_1.onload = function(e2) {
              ctx.save();
              var dWidthLogo = logoWidth || size * 0.2;
              var dHeightLogo = logoHeight || dWidthLogo;
              var dxLogo = (size - dWidthLogo) / 2;
              var dyLogo = (size - dHeightLogo) / 2;
              if (removeQrCodeBehindLogo || logoPadding) {
                ctx.beginPath();
                ctx.strokeStyle = bgColor;
                ctx.fillStyle = bgColor;
                var dWidthLogoPadding = dWidthLogo + 2 * logoPadding;
                var dHeightLogoPadding = dHeightLogo + 2 * logoPadding;
                var dxLogoPadding = dxLogo + offset - logoPadding;
                var dyLogoPadding = dyLogo + offset - logoPadding;
                if (logoPaddingStyle === "circle") {
                  var dxCenterLogoPadding = dxLogoPadding + dWidthLogoPadding / 2;
                  var dyCenterLogoPadding = dyLogoPadding + dHeightLogoPadding / 2;
                  ctx.ellipse(dxCenterLogoPadding, dyCenterLogoPadding, dWidthLogoPadding / 2, dHeightLogoPadding / 2, 0, 0, 2 * Math.PI);
                  ctx.stroke();
                  ctx.fill();
                } else {
                  ctx.fillRect(dxLogoPadding, dyLogoPadding, dWidthLogoPadding, dHeightLogoPadding);
                }
              }
              ctx.globalAlpha = logoOpacity;
              ctx.drawImage(image_1, dxLogo + offset, dyLogo + offset, dWidthLogo, dHeightLogo);
              ctx.restore();
              if (logoOnLoad) {
                logoOnLoad(e2);
              }
            };
            image_1.src = logoImage;
          }
        };
        QRCode3.prototype.render = function() {
          var _a;
          var qrSize = +this.props.size + 2 * +this.props.quietZone;
          return React.createElement("canvas", { id: (_a = this.props.id) !== null && _a !== void 0 ? _a : "react-qrcode-logo", height: qrSize, width: qrSize, style: __assign({ height: qrSize + "px", width: qrSize + "px" }, this.props.style), ref: this.canvasRef });
        };
        QRCode3.defaultProps = {
          value: "https://reactjs.org/",
          ecLevel: "M",
          enableCORS: false,
          size: 150,
          quietZone: 10,
          bgColor: "#FFFFFF",
          fgColor: "#000000",
          logoOpacity: 1,
          qrStyle: "squares",
          eyeRadius: [0, 0, 0],
          logoPaddingStyle: "square"
        };
        return QRCode3;
      }(React.Component)
    );
    exports.QRCode = QRCode2;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/@web3auth/no-modal/dist/noModal.esm.js
var import_lodash = __toESM(require_lodash3());
var import_lodash2 = __toESM(require_lodash());
var ADAPTER_CACHE_KEY = "Web3Auth-cachedAdapter";
var Web3AuthNoModal = class extends SafeEventEmitter {
  constructor(options) {
    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;
    super();
    _defineProperty(this, "coreOptions", void 0);
    _defineProperty(this, "connectedAdapterName", null);
    _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
    _defineProperty(this, "cachedAdapter", null);
    _defineProperty(this, "walletAdapters", {});
    _defineProperty(this, "commonJRPCProvider", null);
    _defineProperty(this, "plugins", {});
    _defineProperty(this, "storage", "localStorage");
    if (!options.clientId) throw WalletInitializationError.invalidParams("Please provide a valid clientId in constructor");
    if (options.enableLogging) loglevel.enableAll();
    else loglevel.setLevel("error");
    if (!options.privateKeyProvider && !options.chainConfig) {
      throw WalletInitializationError.invalidParams("Please provide chainConfig or privateKeyProvider");
    }
    options.chainConfig = options.chainConfig || options.privateKeyProvider.currentChainConfig;
    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams("Please provide a valid chainNamespace in chainConfig");
    if (options.storageKey === "session") this.storage = "sessionStorage";
    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;
    this.coreOptions = _objectSpread2(_objectSpread2({}, options), {}, {
      chainConfig: _objectSpread2(_objectSpread2({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)
    });
    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);
  }
  get connected() {
    return Boolean(this.connectedAdapterName);
  }
  get provider() {
    if (this.status !== ADAPTER_STATUS.NOT_READY && this.commonJRPCProvider) {
      return this.commonJRPCProvider;
    }
    return null;
  }
  set provider(_) {
    throw new Error("Not implemented");
  }
  async init() {
    this.commonJRPCProvider = await CommonJRPCProvider.getProviderInstance({
      chainConfig: this.coreOptions.chainConfig
    });
    let projectConfig;
    try {
      projectConfig = await fetchProjectConfig(this.coreOptions.clientId, this.coreOptions.web3AuthNetwork);
    } catch (e2) {
      loglevel.error("Failed to fetch project configurations", e2);
      throw WalletInitializationError.notReady("failed to fetch project configurations", e2);
    }
    const initPromises = Object.keys(this.walletAdapters).map(async (adapterName) => {
      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]);
      if (!this.walletAdapters[adapterName].chainConfigProxy) {
        const providedChainConfig = this.coreOptions.chainConfig;
        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
        this.walletAdapters[adapterName].setAdapterSettings({
          chainConfig: providedChainConfig,
          sessionTime: this.coreOptions.sessionTime,
          clientId: this.coreOptions.clientId,
          web3AuthNetwork: this.coreOptions.web3AuthNetwork,
          useCoreKitKey: this.coreOptions.useCoreKitKey
        });
      } else {
        this.walletAdapters[adapterName].setAdapterSettings({
          sessionTime: this.coreOptions.sessionTime,
          clientId: this.coreOptions.clientId,
          web3AuthNetwork: this.coreOptions.web3AuthNetwork,
          useCoreKitKey: this.coreOptions.useCoreKitKey
        });
      }
      if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
        const openloginAdapter = this.walletAdapters[adapterName];
        const {
          whitelabel
        } = projectConfig;
        this.coreOptions.uiConfig = (0, import_lodash2.default)((0, import_lodash.default)(whitelabel), this.coreOptions.uiConfig);
        if (!this.coreOptions.uiConfig.mode) this.coreOptions.uiConfig.mode = "light";
        const {
          sms_otp_enabled: smsOtpEnabled,
          whitelist
        } = projectConfig;
        if (smsOtpEnabled !== void 0) {
          openloginAdapter.setAdapterSettings({
            loginConfig: {
              [LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
                showOnModal: smsOtpEnabled,
                showOnDesktop: smsOtpEnabled,
                showOnMobile: smsOtpEnabled,
                showOnSocialBackupFactor: smsOtpEnabled
              }
            }
          });
        }
        if (whitelist) {
          openloginAdapter.setAdapterSettings({
            originData: whitelist.signed_urls
          });
        }
        if (this.coreOptions.privateKeyProvider) {
          if (openloginAdapter.currentChainNamespace !== this.coreOptions.privateKeyProvider.currentChainConfig.chainNamespace) {
            throw WalletInitializationError.incompatibleChainNameSpace("private key provider is not compatible with provided chainNamespace for openlogin adapter");
          }
          openloginAdapter.setAdapterSettings({
            privateKeyProvider: this.coreOptions.privateKeyProvider
          });
        }
        openloginAdapter.setAdapterSettings({
          whiteLabel: this.coreOptions.uiConfig
        });
        if (!openloginAdapter.privateKeyProvider) {
          throw WalletInitializationError.invalidParams("privateKeyProvider is required for openlogin adapter");
        }
      } else if (adapterName === WALLET_ADAPTERS.WALLET_CONNECT_V2) {
        const walletConnectAdapter = this.walletAdapters[adapterName];
        const {
          wallet_connect_enabled: walletConnectEnabled,
          wallet_connect_project_id: walletConnectProjectId
        } = projectConfig;
        if (walletConnectEnabled === false) {
          throw WalletInitializationError.invalidParams("Please enable wallet connect v2 addon on dashboard");
        }
        if (!walletConnectProjectId) throw WalletInitializationError.invalidParams("Invalid wallet connect project id. Please configure it on the dashboard");
        walletConnectAdapter.setAdapterSettings({
          adapterSettings: {
            walletConnectInitOptions: {
              projectId: walletConnectProjectId
            }
          }
        });
      }
      return this.walletAdapters[adapterName].init({
        autoConnect: this.cachedAdapter === adapterName
      }).catch((e2) => loglevel.error(e2, adapterName));
    });
    await Promise.all(initPromises);
    if (this.status === ADAPTER_STATUS.NOT_READY) {
      this.status = ADAPTER_STATUS.READY;
      this.emit(ADAPTER_EVENTS.READY);
    }
  }
  getAdapter(adapterName) {
    return this.walletAdapters[adapterName] || null;
  }
  configureAdapter(adapter) {
    this.checkInitRequirements();
    const providedChainConfig = this.coreOptions.chainConfig;
    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams("Please provide chainNamespace in chainConfig");
    const adapterAlreadyExists = this.walletAdapters[adapter.name];
    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(`Wallet adapter for ${adapter.name} already exists`);
    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(`This wallet adapter belongs to ${adapter.adapterNamespace} which is incompatible with currently used namespace: ${providedChainConfig.chainNamespace}`);
    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {
      adapter.setAdapterSettings({
        chainConfig: providedChainConfig
      });
    }
    this.walletAdapters[adapter.name] = adapter;
    return this;
  }
  clearCache() {
    if (!storageAvailable(this.storage)) return;
    window[this.storage].removeItem(ADAPTER_CACHE_KEY);
    this.cachedAdapter = null;
  }
  async addChain(chainConfig) {
    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) return this.walletAdapters[this.connectedAdapterName].addChain(chainConfig);
    if (this.commonJRPCProvider) {
      return this.commonJRPCProvider.addChain(chainConfig);
    }
    throw WalletInitializationError.notReady(`No wallet is ready`);
  }
  async switchChain(params) {
    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) return this.walletAdapters[this.connectedAdapterName].switchChain(params);
    if (this.commonJRPCProvider) {
      return this.commonJRPCProvider.switchChain(params);
    }
    throw WalletInitializationError.notReady(`No wallet is ready`);
  }
  /**
   * Connect to a specific wallet adapter
   * @param walletName - Key of the walletAdapter to use.
   */
  async connectTo(walletName, loginParams) {
    if (!this.walletAdapters[walletName] || !this.commonJRPCProvider) throw WalletInitializationError.notFound(`Please add wallet adapter for ${walletName} wallet, before connecting`);
    const provider = await this.walletAdapters[walletName].connect(loginParams);
    this.commonJRPCProvider.updateProviderEngineProxy(provider.provider || provider);
    return this.provider;
  }
  async logout(options = {
    cleanup: false
  }) {
    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    await this.walletAdapters[this.connectedAdapterName].disconnect(options);
  }
  async getUserInfo() {
    loglevel.debug("Getting user info", this.status, this.connectedAdapterName);
    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    return this.walletAdapters[this.connectedAdapterName].getUserInfo();
  }
  async enableMFA(loginParams) {
    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    if (this.connectedAdapterName !== WALLET_ADAPTERS.OPENLOGIN) throw WalletLoginError.unsupportedOperation(`EnableMFA is not supported for this adapter.`);
    return this.walletAdapters[this.connectedAdapterName].enableMFA(loginParams);
  }
  async authenticateUser() {
    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    return this.walletAdapters[this.connectedAdapterName].authenticateUser();
  }
  addPlugin(plugin) {
    if (this.plugins[plugin.name]) throw WalletInitializationError.duplicateAdapterError(`Plugin ${plugin.name} already exist`);
    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(`This plugin belongs to ${plugin.pluginNamespace} namespace which is incompatible with currently used namespace: ${this.coreOptions.chainConfig.chainNamespace}`);
    this.plugins[plugin.name] = plugin;
    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {
      this.connectToPlugins({
        adapter: this.connectedAdapterName
      });
    }
    return this;
  }
  getPlugin(name) {
    return this.plugins[name] || null;
  }
  subscribeToAdapterEvents(walletAdapter) {
    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async (data) => {
      if (!this.commonJRPCProvider) throw WalletInitializationError.notFound(`CommonJrpcProvider not found`);
      const {
        provider
      } = data;
      this.commonJRPCProvider.updateProviderEngineProxy(provider.provider || provider);
      this.status = ADAPTER_STATUS.CONNECTED;
      this.connectedAdapterName = data.adapter;
      this.cacheWallet(data.adapter);
      loglevel.debug("connected", this.status, this.connectedAdapterName);
      this.connectToPlugins(data);
      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread2({}, data));
    });
    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async (data) => {
      this.status = ADAPTER_STATUS.READY;
      if (storageAvailable(this.storage)) {
        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);
        if (this.connectedAdapterName === cachedAdapter) {
          this.clearCache();
        }
      }
      loglevel.debug("disconnected", this.status, this.connectedAdapterName);
      await Promise.all(Object.values(this.plugins).map((plugin) => {
        return plugin.disconnect().catch((error) => {
          if (error.code === 5211) {
            return;
          }
          loglevel.error(error);
        });
      }));
      this.connectedAdapterName = null;
      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);
    });
    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, (data) => {
      this.status = ADAPTER_STATUS.CONNECTING;
      this.emit(ADAPTER_EVENTS.CONNECTING, data);
      loglevel.debug("connecting", this.status, this.connectedAdapterName);
    });
    walletAdapter.on(ADAPTER_EVENTS.ERRORED, (data) => {
      this.status = ADAPTER_STATUS.ERRORED;
      this.clearCache();
      this.emit(ADAPTER_EVENTS.ERRORED, data);
      loglevel.debug("errored", this.status, this.connectedAdapterName);
    });
    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (data) => {
      loglevel.debug("adapter data updated", data);
      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);
    });
    walletAdapter.on(ADAPTER_EVENTS.CACHE_CLEAR, (data) => {
      loglevel.debug("adapter cache clear", data);
      if (storageAvailable(this.storage)) {
        this.clearCache();
      }
    });
  }
  checkInitRequirements() {
    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady("Already pending connection");
    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady("Already connected");
    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady("Adapter is already initialized");
  }
  cacheWallet(walletName) {
    if (!storageAvailable(this.storage)) return;
    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);
    this.cachedAdapter = walletName;
  }
  connectToPlugins(data) {
    Object.values(this.plugins).map(async (plugin) => {
      try {
        if (!plugin.SUPPORTED_ADAPTERS.includes(data.adapter)) {
          return;
        }
        if (plugin.status === PLUGIN_STATUS.CONNECTED) return;
        const {
          openloginInstance
        } = this.walletAdapters[this.connectedAdapterName];
        const {
          options,
          sessionId,
          sessionNamespace
        } = openloginInstance || {};
        await plugin.initWithWeb3Auth(this, options.whiteLabel);
        await plugin.connect({
          sessionId,
          sessionNamespace
        });
      } catch (error) {
        if (error.code === 5211) {
          return;
        }
        loglevel.error(error);
      }
    });
  }
};

// node_modules/@web3auth/ui/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_base64url = __toESM(require_base64url());
var import_color = __toESM(require_color());
function storageAvailable2(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (err) {
    const error = err;
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededError" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
var MemoryStore = class {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(key) {
    return this.store.get(key) || null;
  }
  setItem(key, value) {
    this.store.set(key, value);
  }
  removeItem(key) {
    this.store.delete(key);
  }
};
var BrowserStorage = class {
  constructor(storeKey, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey;
    try {
      if (!storage.getItem(storeKey)) {
        this.resetStore();
      }
    } catch (error) {
    }
  }
  static getInstance(key) {
    let storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(key)) {
      let storage;
      if (storageKey === "local" && storageAvailable2("localStorage")) {
        storage = window.localStorage;
      } else if (storageKey === "session" && storageAvailable2("sessionStorage")) {
        storage = window.sessionStorage;
      } else {
        storage = new MemoryStore();
      }
      this.instanceMap.set(key, new this(key, storage));
    }
    return this.instanceMap.get(key);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const currStore = this.getStore();
    this.storage.removeItem(this._storeKey);
    return currStore;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(key) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  set(key, value) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
var OPENLOGIN_NETWORK = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);
var LOGIN_PROVIDER2 = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  FARCASTER: "farcaster",
  EMAIL_PASSWORDLESS: "email_passwordless",
  SMS_PASSWORDLESS: "sms_passwordless",
  WEBAUTHN: "webauthn",
  JWT: "jwt"
};
var LANGUAGES = {
  en: "en",
  ja: "ja",
  ko: "ko",
  de: "de",
  zh: "zh",
  es: "es",
  fr: "fr",
  pt: "pt",
  nl: "nl",
  tr: "tr"
};
var LANGUAGE_MAP = {
  en: "english",
  ja: "japanese",
  ko: "korean",
  de: "german",
  zh: "mandarin",
  es: "spanish",
  fr: "french",
  pt: "portuguese",
  nl: "dutch",
  tr: "turkish"
};
function getColorsList() {
  let colorsAmount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
  let colorsShiftAmount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;
  let mixColor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "black";
  let rotate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  let saturation = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 20;
  let mainColor = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#0346ff";
  const colorsList = [];
  let step;
  for (step = 0; step < colorsAmount; step += 1) {
    colorsList.push((0, import_color.default)(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix((0, import_color.default)(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());
  }
  return colorsList;
}
function generateWhiteLabelTheme(primary) {
  const darkSet = getColorsList(3, 50, "black", 0, 20, primary);
  const lightSet = getColorsList(6, 85, "white", 0, 20, primary);
  return [...darkSet.reverse(), primary, ...lightSet];
}
function applyWhiteLabelTheme(rootElement, theme) {
  if (theme.primary) {
    const themeSet = generateWhiteLabelTheme(theme.primary);
    rootElement.style.setProperty("--app-primary-900", themeSet[0]);
    rootElement.style.setProperty("--app-primary-800", themeSet[1]);
    rootElement.style.setProperty("--app-primary-700", themeSet[2]);
    rootElement.style.setProperty("--app-primary-600", themeSet[3]);
    rootElement.style.setProperty("--app-primary-500", themeSet[4]);
    rootElement.style.setProperty("--app-primary-400", themeSet[5]);
    rootElement.style.setProperty("--app-primary-300", themeSet[6]);
    rootElement.style.setProperty("--app-primary-200", themeSet[7]);
    rootElement.style.setProperty("--app-primary-100", themeSet[8]);
    rootElement.style.setProperty("--app-primary-50", themeSet[9]);
  }
  if (theme.onPrimary) {
    rootElement.style.setProperty("--app-on-primary", theme.onPrimary);
  }
}

// node_modules/@web3auth/ui/dist/index.js
var import_client = __toESM(require_client());
var import_lodash3 = __toESM(require_lodash3());
var import_lodash4 = __toESM(require_lodash());
var import_react9 = __toESM(require_react());

// node_modules/react-i18next/dist/es/Trans.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/TransWithoutContext.js
var import_react = __toESM(require_react(), 1);

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_void_elements = __toESM(require_void_elements());

// node_modules/react-i18next/dist/es/utils.js
var warn = (...args) => {
  if (console == null ? void 0 : console.warn) {
    if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
};
var alreadyWarned = {};
var warnOnce = (...args) => {
  if (isString(args[0]) && alreadyWarned[args[0]]) return;
  if (isString(args[0])) alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn(...args);
};
var loadedClb = (i18n, cb) => () => {
  if (i18n.isInitialized) {
    cb();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb();
    };
    i18n.on("initialized", initialized);
  }
};
var loadNamespaces = (i18n, ns, cb) => {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
};
var loadLanguages = (i18n, lng, ns, cb) => {
  if (isString(ns)) ns = [ns];
  ns.forEach((n) => {
    if (i18n.options.ns.indexOf(n) < 0) i18n.options.ns.push(n);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
};
var hasLoadedNamespace = (ns, i18n, options = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance3, loadNotPending) => {
      var _a;
      if (((_a = options.bindI18n) == null ? void 0 : _a.indexOf("languageChanging")) > -1 && i18nInstance3.services.backendConnector.backend && i18nInstance3.isLanguageChangingTo && !loadNotPending(i18nInstance3.isLanguageChangingTo, ns)) return false;
    }
  });
};
var isString = (obj) => typeof obj === "string";
var isObject = (obj) => typeof obj === "object" && obj !== null;

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = (m) => htmlEntities[m];
var unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);

// node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
var setDefaults = (options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
};
var getDefaults = () => defaultOptions;

// node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
var setI18n = (instance2) => {
  i18nInstance = instance2;
};
var getI18n = () => i18nInstance;

// node_modules/react-i18next/dist/es/context.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};

// node_modules/react-i18next/dist/es/context.js
var I18nContext = (0, import_react2.createContext)();
var ReportNamespaces = class {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      var _a;
      (_a = this.usedNamespaces)[ns] ?? (_a[ns] = true);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
};

// node_modules/react-i18next/dist/es/useTranslation.js
var import_react4 = __toESM(require_react(), 1);
var usePrevious = (value, ignore) => {
  const ref = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    ref.current = ignore ? ref.current : value;
  }, [value, ignore]);
  return ref.current;
};
var alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
var useMemoizedT = (i18n, language, namespace, keyPrefix) => (0, import_react4.useCallback)(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);
var useTranslation = (ns, props = {}) => {
  var _a, _b, _c, _d;
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react4.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k, optsOrDefaultValue) => {
      if (isString(optsOrDefaultValue)) return optsOrDefaultValue;
      if (isObject(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
      return Array.isArray(k) ? k[k.length - 1] : k;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if ((_a = i18n.options.react) == null ? void 0 : _a.wait) warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || ((_b = i18n.options) == null ? void 0 : _b.defaultNS);
  namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"];
  (_d = (_c = i18n.reportNamespaces).addUsedNamespaces) == null ? void 0 : _d.call(_c, namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n) => hasLoadedNamespace(n, i18n, i18nOptions));
  const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const getT = () => memoGetT;
  const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const [t2, setT] = (0, import_react4.useState)(getT);
  let joinedNS = namespaces.join();
  if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = (0, import_react4.useRef)(true);
  (0, import_react4.useEffect)(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getNewT);
    }
    const boundReset = () => {
      if (isMounted.current) setT(getNewT);
    };
    if (bindI18n) i18n == null ? void 0 : i18n.on(bindI18n, boundReset);
    if (bindI18nStore) i18n == null ? void 0 : i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (i18n) bindI18n == null ? void 0 : bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset));
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]);
  (0, import_react4.useEffect)(() => {
    if (isMounted.current && ready) {
      setT(getT);
    }
  }, [i18n, keyPrefix, ready]);
  const ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve());
    }
  });
};

// node_modules/react-i18next/dist/es/withTranslation.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/withSSR.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/useSSR.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (typeof args[0] === "string") args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
var defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
var copy = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || typeof object === "string";
var getLastOfPath = (object, path, Empty) => {
  const stack = typeof path !== "string" ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e2 = `${p[p.length - 1]}.${e2}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e2}`] = newValue;
};
var pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  return obj[k];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = function(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path]) return obj[path];
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => {
  if (code && code.indexOf("_") > 0) return code.replace("_", "-");
  return code;
};
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (typeof key === "string" && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || typeof key !== "string") return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (typeof resources[m] === "string" || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1") return {
      ...{},
      ...this.getResource(lng, ns)
    };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class _Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string") namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey) copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = _Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string") keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (typeof fallbacks === "string") fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: (n) => Number(n > 1),
  2: (n) => Number(n != 1),
  3: (n) => 0,
  4: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  5: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),
  6: (n) => Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),
  7: (n) => Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  8: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),
  9: (n) => Number(n >= 2),
  10: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),
  11: (n) => Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),
  12: (n) => Number(n % 10 != 1 || n % 100 == 11),
  13: (n) => Number(n !== 0),
  14: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),
  15: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),
  16: (n) => Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),
  17: (n) => Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),
  18: (n) => Number(n == 0 ? 0 : n == 1 ? 1 : 2),
  19: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),
  20: (n) => Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),
  21: (n) => Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),
  22: (n) => Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var createRules = () => {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l) => {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
};
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
        const type = options.ordinal ? "ordinal" : "cardinal";
        const cacheKey = JSON.stringify({
          cleanedCode,
          type
        });
        if (cacheKey in this.pluralRulesCache) {
          return this.pluralRulesCache[cacheKey];
        }
        const rule = new Intl.PluralRules(cleanedCode, {
          type
        });
        this.pluralRulesCache[cacheKey] = rule;
        return rule;
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1) return "";
      if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
var deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && typeof key === "string") {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && typeof value !== "string") return value;
      if (typeof value !== "string") value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
var Formatter = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
var removePending = (q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string") namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
var get2 = () => ({
  debug: false,
  initImmediate: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (typeof args[1] === "string") ret.defaultValue = args[1];
    if (typeof args[2] === "string") ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
var transformOptions = (options) => {
  if (typeof options.ns === "string") options.ns = [options.ns];
  if (typeof options.fallbackLng === "string") options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string") options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
};
var noop = () => {
};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var I18n = class _I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get2();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (typeof ns === "string") ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string") lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get2());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new _I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace2 = instance.hasLoadedNamespace;
var loadNamespaces2 = instance.loadNamespaces;
var loadLanguages2 = instance.loadLanguages;

// node_modules/@web3auth/ui/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
var import_react_qrcode_logo = __toESM(require_dist());
var import_classnames = __toESM(require_classnames());
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var OPENLOGIN_PROVIDERS = Object.values(LOGIN_PROVIDER2).filter((x) => x !== LOGIN_PROVIDER2.WEBAUTHN && x !== LOGIN_PROVIDER2.JWT);
var OPENLOGIN_PROVIDERS_NAMES = OPENLOGIN_PROVIDERS.reduce((acc, x) => {
  if (x === "email_passwordless") acc[x] = "Email";
  else if (x === "sms_passwordless") acc[x] = "Mobile";
  else acc[x] = capitalizeFirstLetter(x);
  return acc;
}, {});
var LOGIN_MODAL_EVENTS = {
  INIT_EXTERNAL_WALLETS: "INIT_EXTERNAL_WALLETS",
  LOGIN: "LOGIN",
  DISCONNECT: "DISCONNECT",
  MODAL_VISIBILITY: "MODAL_VISIBILITY"
};
var MODAL_STATUS = {
  INITIALIZED: "initialized",
  CONNECTED: "connected",
  CONNECTING: "connecting",
  ERRORED: "errored"
};
var DEFAULT_LOGO_LIGHT = "https://images.web3auth.io/web3auth-logo-w.svg";
var DEFAULT_LOGO_DARK = "https://images.web3auth.io/web3auth-logo-w-light.svg";
var WALLET_CONNECT_LOGO = "https://images.web3auth.io/login-wallet-connect.svg";
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap");\n/*! tailwindcss v3.4.9 | MIT License | https://tailwindcss.com*/.w3a-parent-container *,.w3a-parent-container :after,.w3a-parent-container :before{border:0 solid;box-sizing:border-box}.w3a-parent-container :after,.w3a-parent-container :before{--tw-content:""}.w3a-parent-container :host,.w3a-parent-container html{-webkit-text-size-adjust:100%;font-feature-settings:normal;-webkit-tap-highlight-color:transparent;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;tab-size:4}.w3a-parent-container body{line-height:inherit;margin:0}.w3a-parent-container hr{border-top-width:1px;color:inherit;height:0}.w3a-parent-container abbr:where([title]){text-decoration:underline dotted}.w3a-parent-container h1,.w3a-parent-container h2,.w3a-parent-container h3,.w3a-parent-container h4,.w3a-parent-container h5,.w3a-parent-container h6{font-size:inherit;font-weight:inherit}.w3a-parent-container a{color:inherit;text-decoration:inherit}.w3a-parent-container b,.w3a-parent-container strong{font-weight:bolder}.w3a-parent-container code,.w3a-parent-container kbd,.w3a-parent-container pre,.w3a-parent-container samp{font-feature-settings:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em;font-variation-settings:normal}.w3a-parent-container small{font-size:80%}.w3a-parent-container sub,.w3a-parent-container sup{font-size:75%;line-height:0;position:relative;vertical-align:initial}.w3a-parent-container sub{bottom:-.25em}.w3a-parent-container sup{top:-.5em}.w3a-parent-container table{border-collapse:collapse;border-color:inherit;text-indent:0}.w3a-parent-container button,.w3a-parent-container input,.w3a-parent-container optgroup,.w3a-parent-container select,.w3a-parent-container textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}.w3a-parent-container button,.w3a-parent-container select{text-transform:none}.w3a-parent-container button,.w3a-parent-container input:where([type=button]),.w3a-parent-container input:where([type=reset]),.w3a-parent-container input:where([type=submit]){-webkit-appearance:button;background-color:initial;background-image:none}.w3a-parent-container :-moz-focusring{outline:auto}.w3a-parent-container :-moz-ui-invalid{box-shadow:none}.w3a-parent-container progress{vertical-align:initial}.w3a-parent-container ::-webkit-inner-spin-button,.w3a-parent-container ::-webkit-outer-spin-button{height:auto}.w3a-parent-container [type=search]{-webkit-appearance:textfield;outline-offset:-2px}.w3a-parent-container ::-webkit-search-decoration{-webkit-appearance:none}.w3a-parent-container ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.w3a-parent-container summary{display:list-item}.w3a-parent-container blockquote,.w3a-parent-container dd,.w3a-parent-container dl,.w3a-parent-container figure,.w3a-parent-container h1,.w3a-parent-container h2,.w3a-parent-container h3,.w3a-parent-container h4,.w3a-parent-container h5,.w3a-parent-container h6,.w3a-parent-container hr,.w3a-parent-container p,.w3a-parent-container pre{margin:0}.w3a-parent-container fieldset{margin:0;padding:0}.w3a-parent-container legend{padding:0}.w3a-parent-container menu,.w3a-parent-container ol,.w3a-parent-container ul{list-style:none;margin:0;padding:0}.w3a-parent-container dialog{padding:0}.w3a-parent-container textarea{resize:vertical}.w3a-parent-container input::placeholder,.w3a-parent-container textarea::placeholder{color:#9ca3af;opacity:1}.w3a-parent-container [role=button],.w3a-parent-container button{cursor:pointer}.w3a-parent-container :disabled{cursor:default}.w3a-parent-container audio,.w3a-parent-container canvas,.w3a-parent-container embed,.w3a-parent-container iframe,.w3a-parent-container img,.w3a-parent-container object,.w3a-parent-container svg,.w3a-parent-container video{display:block;vertical-align:middle}.w3a-parent-container img,.w3a-parent-container video{height:auto;max-width:100%}.w3a-parent-container [hidden]{display:none}.w3a-parent-container{--app-on-primary:#fff;--app-primary-50:#ebf5ff;--app-primary-100:#e1effe;--app-primary-200:#c3ddfd;--app-primary-300:#a4cafe;--app-primary-400:#76a9fa;--app-primary-500:#3f83f8;--app-primary-600:#0346ff;--app-primary-700:#1a56db;--app-primary-800:#1e429f;--app-primary-900:#233876;--app-gray-50:#f9fafb;--app-gray-100:#f3f4f6;--app-gray-200:#e5e7eb;--app-gray-300:#d1d5db;--app-gray-400:#9ca3af;--app-gray-500:#6b7280;--app-gray-600:#4b5563;--app-gray-700:#374151;--app-gray-800:#1f2a37;--app-gray-900:#111928;--app-blue-50:#ebf5ff;--app-blue-100:#e1effe;--app-blue-200:#c3ddfd;--app-blue-300:#a4cafe;--app-blue-400:#76a9fa;--app-blue-500:#3f83f8;--app-blue-600:#0346ff;--app-blue-700:#1a56db;--app-blue-800:#1e429f;--app-blue-900:#233876;--app-red-50:#fdf2f2;--app-red-100:#fde8e8;--app-red-200:#fbd5d5;--app-red-300:#f8b4b4;--app-red-400:#f98080;--app-red-500:#f05252;--app-red-600:#e02424;--app-red-700:#c81e1e;--app-red-800:#9b1c1c;--app-red-900:#771d1d;--app-green-50:#f3faf7;--app-green-100:#def7ec;--app-green-200:#bcf0da;--app-green-300:#84e1bc;--app-green-400:#31c48d;--app-green-500:#0e9f6e;--app-green-600:#057a55;--app-green-700:#046c4e;--app-green-800:#03543f;--app-green-900:#014737;--app-yellow-50:#fdfdea;--app-yellow-100:#fdf6b2;--app-yellow-200:#fce96a;--app-yellow-300:#faca15;--app-yellow-400:#e3a008;--app-yellow-500:#c27803;--app-yellow-600:#9f580a;--app-yellow-700:#8e4b10;--app-yellow-800:#723b13;--app-yellow-900:#633112;--app-success:#30cca4;--app-warning:#fbc94a;--app-error:#fb4a61;--app-info:#d4d4d4;--app-white:#fff;--app-black:#000}.w3a-parent-container *,.w3a-parent-container :after,.w3a-parent-container :before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.w3a-parent-container ::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.w3a-parent-container .container{width:100%}@media (min-width:380px){.w3a-parent-container .container{max-width:380px}}@media (min-width:440px){.w3a-parent-container .container{max-width:440px}}@media (min-width:570px){.w3a-parent-container .container{max-width:570px}}@media (min-width:640px){.w3a-parent-container .container{max-width:640px}}@media (min-width:768px){.w3a-parent-container .container{max-width:768px}}@media (min-width:840px){.w3a-parent-container .container{max-width:840px}}@media (min-width:1024px){.w3a-parent-container .container{max-width:1024px}}@media (min-width:1280px){.w3a-parent-container .container{max-width:1280px}}@media (min-width:1536px){.w3a-parent-container .container{max-width:1536px}}.w3a-parent-container .absolute{position:absolute}.w3a-parent-container .relative{position:relative}.w3a-parent-container .left-20{left:5rem}.w3a-parent-container .left-8{left:2rem}.w3a-parent-container .top-4{top:1rem}.w3a-parent-container .z-20{z-index:20}.w3a-parent-container .col-span-2{grid-column:span 2/span 2}.w3a-parent-container .col-span-3{grid-column:span 3/span 3}.w3a-parent-container .col-span-6{grid-column:span 6/span 6}.w3a-parent-container .-mb-2{margin-bottom:-.5rem}.w3a-parent-container .-ml-\\[100px\\]{margin-left:-100px}.w3a-parent-container .mb-1{margin-bottom:.25rem}.w3a-parent-container .mb-4{margin-bottom:1rem}.w3a-parent-container .mb-5{margin-bottom:1.25rem}.w3a-parent-container .ml-2{margin-left:.5rem}.w3a-parent-container .ml-\\[3px\\]{margin-left:3px}.w3a-parent-container .mt-4{margin-top:1rem}.w3a-parent-container .block{display:block}.w3a-parent-container .flex{display:flex}.w3a-parent-container .hidden{display:none}.w3a-parent-container .h-3{height:.75rem}.w3a-parent-container .h-4{height:1rem}.w3a-parent-container .w-3{width:.75rem}.w3a-parent-container .w-\\[270px\\]{width:270px}.w3a-parent-container .w-\\[300px\\]{width:300px}.w3a-parent-container .w-full{width:100%}.w3a-parent-container .-translate-x-16{--tw-translate-x:-4rem}.w3a-parent-container .-translate-x-16,.w3a-parent-container .rotate-45{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .rotate-45{--tw-rotate:45deg}.w3a-parent-container .cursor-pointer{cursor:pointer}.w3a-parent-container .flex-col{flex-direction:column}.w3a-parent-container .items-center{align-items:center}.w3a-parent-container .justify-center{justify-content:center}.w3a-parent-container .gap-2{gap:.5rem}.w3a-parent-container .rounded-full{border-radius:9999px}.w3a-parent-container .rounded-md{border-radius:.375rem}.w3a-parent-container .bg-app-gray-50{background-color:var(--app-gray-50)}.w3a-parent-container .p-2{padding:.5rem}.w3a-parent-container .p-4{padding:1rem}.w3a-parent-container .text-left{text-align:left}.w3a-parent-container .text-center{text-align:center}.w3a-parent-container .text-right{text-align:right}.w3a-parent-container .text-sm{font-size:.875rem;line-height:1.25rem}.w3a-parent-container .text-xs{font-size:.75rem;line-height:1rem}.w3a-parent-container .font-medium{font-weight:500}.w3a-parent-container .font-normal{font-weight:400}.w3a-parent-container .leading-none{line-height:1}.w3a-parent-container .text-app-gray-300{color:var(--app-gray-300)}.w3a-parent-container .text-app-gray-400{color:var(--app-gray-400)}.w3a-parent-container .text-app-gray-500{color:var(--app-gray-500)}.w3a-parent-container .text-app-gray-900{color:var(--app-gray-900)}.w3a-parent-container .text-app-white{color:var(--app-white)}.w3a-parent-container .shadow-lg{--tw-shadow:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.w3a-parent-container input[type=number]::-webkit-inner-spin-button,.w3a-parent-container input[type=number]::-webkit-outer-spin-button{appearance:none}.w3a-parent-container #w3a-modal{align-items:center;box-sizing:border-box;display:flex;font-family:Inter;inset:0;justify-content:center;padding:1rem;position:fixed}.w3a-parent-container #w3a-modal.w3a-modal--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-modal__inner{--tw-shadow:0px 4px 16px #00000014;--tw-shadow-colored:0px 4px 16px var(--tw-shadow-color);background-color:var(--app-white);border-color:var(--app-gray-100);border-radius:32px;border-width:1px;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow);display:flex;flex-direction:column;max-height:95%;max-width:392px;min-height:630px;opacity:0;overflow-x:hidden;overflow-y:hidden;position:relative;width:100%}.w3a-parent-container #w3a-modal .w3a-modal__inner:is(.dark *){background-color:var(--app-gray-800);border-color:var(--app-gray-800)}.w3a-parent-container #w3a-modal .w3a-modal__inner{transform:scale(0);transform-origin:center center;transition:all .15s cubic-bezier(.92,0,1,.67)}.w3a-parent-container #w3a-modal .w3a-modal__inner.w3a-modal__inner--active{opacity:1;transform:scale(1);transform-origin:center center;transition:all .15s cubic-bezier(0,.73,.71,1)}.w3a-parent-container #w3a-modal .w3a-modal__header{padding:.5rem 2rem;position:relative}.w3a-parent-container #w3a-modal .w3a-modal__content{overflow-y:auto;padding:1rem 2rem}.w3a-parent-container #w3a-modal .w3a-modal__footer{align-items:center;justify-content:center;margin-top:auto;padding:1rem 2rem;text-align:center}.w3a-parent-container #w3a-modal .w3a-header{align-items:center;display:flex;padding-top:2rem}.w3a-parent-container #w3a-modal .w3a-header__logo{margin-bottom:1rem}.w3a-parent-container #w3a-modal .w3a-header__logo img{height:auto;width:2.5rem}.w3a-parent-container #w3a-modal .w3a-header__title{color:var(--app-gray-900);font-size:1.25rem;font-weight:700;line-height:1.75rem}.w3a-parent-container #w3a-modal .w3a-header__title:is(.dark *){color:var(--app-white)}.w3a-parent-container #w3a-modal div.w3a-header__subtitle{align-items:center;color:var(--app-gray-500);display:flex;font-size:.875rem;font-weight:400;line-height:1.25rem}.w3a-parent-container #w3a-modal div.w3a-header__subtitle:is(.dark *){color:var(--app-gray-400)}.w3a-parent-container #w3a-modal div.w3a-header__subtitle img{height:14px;margin-left:.25rem;width:14px}.w3a-parent-container #w3a-modal button.w3a-header__button{border-width:0;cursor:pointer;padding:0;position:absolute;right:1.75rem;top:1.25rem}.w3a-parent-container #w3a-modal button.w3a-header__button:active,.w3a-parent-container #w3a-modal button.w3a-header__button:focus{outline-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal button.w3a-header__button:focus:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal button.w3a-header__button:active:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal div.w3a-social__policy{color:var(--app-gray-500);font-size:.75rem;font-weight:500;line-height:1rem;margin-top:1rem;text-align:left}.w3a-parent-container #w3a-modal div.w3a-social__policy:is(.dark *){color:var(--app-gray-400)}.w3a-parent-container #w3a-modal .w3a-group{margin-bottom:1rem}.w3a-parent-container #w3a-modal .w3a-group:last-child{margin-bottom:0}.w3a-parent-container #w3a-modal .w3ajs-passwordless div.w3a-group__title{align-items:center;display:flex}.w3a-parent-container #w3a-modal .w3ajs-passwordless div.w3a-group__title img{height:14px;margin-left:.25rem;width:14px}.w3a-parent-container #w3a-modal .w3a-group.w3a-group--email-hidden,.w3a-parent-container #w3a-modal .w3a-group.w3a-group--ext-wallet-hidden,.w3a-parent-container #w3a-modal .w3a-group.w3a-group--hidden,.w3a-parent-container #w3a-modal .w3a-group.w3a-group--social-hidden{display:none}.w3a-parent-container #w3a-modal div.w3a-group__title{color:var(--app-gray-900);font-size:.875rem;font-weight:500;line-height:1.25rem;margin-bottom:.5rem}.w3a-parent-container #w3a-modal div.w3a-group__title:is(.dark *){color:var(--app-white)}.w3a-parent-container #w3a-modal ul.w3a-adapter-list{column-gap:.5rem;display:grid;grid-template-columns:repeat(6,minmax(0,1fr));max-height:500px;overflow-y:hidden;padding:1px;row-gap:1rem;transition:max-height .35s;transition-timing-function:cubic-bezier(.92,0,.74,1)}.w3a-parent-container #w3a-modal ul.w3a-adapter-list.w3a-adapter-list--shrink{max-height:108px;transition:max-height .3s;transition-timing-function:cubic-bezier(0,.73,.71,1)}.w3a-parent-container #w3a-modal ul.w3a-adapter-list.w3a-adapter-list--hidden{display:none}.w3a-parent-container #w3a-modal li.w3a-adapter-item{list-style-type:none}.w3a-parent-container #w3a-modal li.w3a-adapter-item--full{grid-column:span 6/span 6}.w3a-parent-container #w3a-modal .w3a-adapter-item--hide{display:none}.w3a-parent-container #w3a-modal .w3a-external-toggle{display:block}.w3a-parent-container #w3a-modal .w3a-external-toggle.w3a-external-toggle--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-external-container{display:block;margin-bottom:0}.w3a-parent-container #w3a-modal .w3a-external-container.w3a-external-container--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-external-group{display:flex;flex-wrap:wrap;gap:.75rem;margin-bottom:1rem}.w3a-parent-container #w3a-modal .w3a-external-group__left{flex-grow:1}.w3a-parent-container #w3a-modal button.w3a-external-back{align-items:center;background-image:none;border-width:0;color:var(--app-gray-500);cursor:pointer;display:inline-flex;margin-bottom:.5rem;padding:0}.w3a-parent-container #w3a-modal button.w3a-external-back:active,.w3a-parent-container #w3a-modal button.w3a-external-back:focus{outline-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal button.w3a-external-back:is(.dark *){color:var(--app-gray-400)}.w3a-parent-container #w3a-modal button.w3a-external-back:focus:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal button.w3a-external-back:active:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-external-back .w3a-group__title{color:var(--app-gray-400);margin-bottom:0;margin-left:5px}.w3a-parent-container #w3a-modal .w3a-external-loader{display:flex;justify-content:center}.w3a-parent-container #w3a-modal .w3a-wallet-connect{display:block;margin-bottom:1rem;text-align:center}.w3a-parent-container #w3a-modal .w3a-wallet-connect.w3a-wallet-connect--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container{background-color:var(--app-white);border-radius:10px;color:var(--app-gray-500);font-size:.625rem;margin-left:auto;margin-right:auto;min-width:250px;padding:1rem .75rem;width:fit-content}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container:is(.dark *){color:var(--app-gray-400)}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container-android,.w3a-parent-container #w3a-modal .w3a-wallet-connect__container-desktop{margin:auto}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container-btn-group{display:flex;gap:18px}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container-ios{box-sizing:border-box;column-gap:1.25rem;display:flex;flex-wrap:wrap;padding:0 0 1.75rem;row-gap:30px}.w3a-parent-container #w3a-modal .w3a-wallet-connect-qr{margin:1rem}.w3a-parent-container #w3a-modal .w3a-wallet-connect-qr>canvas,.w3a-parent-container #w3a-modal .w3a-wallet-connect-qr>svg{margin:auto}.w3a-parent-container #w3a-modal .w3a-wallet-connect__container-android a{text-decoration-line:none}.w3a-parent-container #w3a-modal .w3a-wallet-connect__logo>img{margin:0 auto 1rem;width:115px}.w3a-parent-container #w3a-modal .w3a-footer{align-items:center;color:var(--app-gray-400);display:flex;font-size:.75rem;justify-content:center;line-height:1rem}.w3a-parent-container #w3a-modal .w3a-footer__links a:active,.w3a-parent-container #w3a-modal .w3a-footer__links a:focus{outline-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal .w3a-footer__links a:focus:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-footer__links a:active:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-footer__links span{margin:0 4px}.w3a-parent-container #w3a-modal.w3a-modal--light .w3a-footer__links a:focus-visible{outline:1px solid #0f1222}.w3a-parent-container #w3a-modal.w3a-modal--light .w3a-external-back:focus-visible{outline:1px solid #0f1222}.w3a-parent-container #w3a-modal .hover-icon{display:none;transition:display .15s;transition-timing-function:cubic-bezier(0,.54,.63,.99)}.w3a-parent-container #w3a-modal .w3a-text-field{background-color:var(--app-gray-50);border-color:var(--app-gray-300);border-radius:9999px;border-width:1px;color:var(--app-gray-900);font-size:.875rem;line-height:1.25rem;margin-top:.5rem;padding:.75rem 1.5rem}.w3a-parent-container #w3a-modal .w3a-text-field::placeholder{color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .w3a-text-field{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000);outline-width:0}.w3a-parent-container #w3a-modal .w3a-text-field:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);border-color:#0000;box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .w3a-text-field:disabled{cursor:not-allowed}.w3a-parent-container #w3a-modal .w3a-text-field:disabled::placeholder{color:var(--app-gray-400)}.w3a-parent-container #w3a-modal .w3a-text-field:is(.dark *){background-color:var(--app-gray-600);border-color:var(--app-gray-500);color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-text-field:is(.dark *)::placeholder{color:var(--app-gray-400)}.w3a-parent-container #w3a-modal .w3a-text-field:focus:is(.dark *){--tw-ring-color:var(--app-primary-500);border-color:#0000}.w3a-parent-container #w3a-modal .w3a-text-field:disabled:is(.dark *)::placeholder{color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .w3a-text-field{line-height:1.25em}.w3a-parent-container #w3a-modal .w3a-text-field--country-code{display:flex;justify-content:space-between;padding-left:1rem;padding-right:1rem;width:100%}.w3a-parent-container #w3a-modal .w3a-text-field--number{appearance:none}.w3a-parent-container #w3a-modal .w3a-sms-field--error{color:var(--app-red-500);font-size:.875rem;line-height:1.25rem;margin-bottom:.5rem;margin-left:.375rem;margin-top:-.5rem}.w3a-parent-container #w3a-container #w3a-modal input.w3a-text-field:-webkit-autofill,.w3a-parent-container #w3a-container #w3a-modal input.w3a-text-field:-webkit-autofill:active,.w3a-parent-container #w3a-container #w3a-modal input.w3a-text-field:-webkit-autofill:focus,.w3a-parent-container #w3a-container #w3a-modal input.w3a-text-field:-webkit-autofill:hover{--tw-shadow:0 0 0 30px #f9fafb inset;--tw-shadow-colored:inset 0 0 0 30px var(--tw-shadow-color);-webkit-text-fill-color:#111928!important;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container #w3a-container.dark #w3a-modal input.w3a-text-field:-webkit-autofill,.w3a-parent-container #w3a-container.dark #w3a-modal input.w3a-text-field:-webkit-autofill:active,.w3a-parent-container #w3a-container.dark #w3a-modal input.w3a-text-field:-webkit-autofill:focus,.w3a-parent-container #w3a-container.dark #w3a-modal input.w3a-text-field:-webkit-autofill:hover{--tw-shadow:0 0 0 30px #374151 inset;--tw-shadow-colored:inset 0 0 0 30px var(--tw-shadow-color);-webkit-text-fill-color:#fff!important;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container #w3a-modal .w3a-button{background-color:var(--app-gray-100);border-radius:9999px;color:var(--app-gray-900);font-size:1rem;font-weight:500;line-height:1.5rem;padding:.75rem 1.5rem}.w3a-parent-container #w3a-modal .w3a-button:hover{background-color:var(--app-gray-300)}.w3a-parent-container #w3a-modal .w3a-button:focus{background-color:var(--app-gray-100);color:var(--app-gray-700);outline-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal .w3a-button:active{outline-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal .w3a-button:disabled{background-color:var(--app-gray-50);color:var(--app-gray-300)}.w3a-parent-container #w3a-modal .w3a-button:is(.dark *){background-color:var(--app-gray-900);color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-button:hover:is(.dark *){background-color:var(--app-gray-800)}.w3a-parent-container #w3a-modal .w3a-button:focus:is(.dark *){background-color:var(--app-gray-900);color:var(--app-white);outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-button:active:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-button:disabled:is(.dark *){--tw-bg-opacity:1;background-color:rgb(59 69 85/var(--tw-bg-opacity));color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .w3a-button--primary{background-color:var(--app-primary-600);color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-button--primary:hover{background-color:var(--app-primary-800)}.w3a-parent-container #w3a-modal .w3a-button--primary:focus{background-color:var(--app-primary-600);color:var(--app-white);outline-color:var(--app-primary-300)}.w3a-parent-container #w3a-modal .w3a-button--primary:active{outline-color:var(--app-primary-300)}.w3a-parent-container #w3a-modal .w3a-button--primary:disabled{--tw-text-opacity:1;background-color:var(--app-primary-200);color:rgb(235 245 255/var(--tw-text-opacity))}.w3a-parent-container #w3a-modal .w3a-button--primary:is(.dark *){background-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .w3a-button--primary:hover:is(.dark *){background-color:var(--app-primary-800)}.w3a-parent-container #w3a-modal .w3a-button--primary:focus:is(.dark *){background-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .w3a-button--primary:disabled:is(.dark *){--tw-bg-opacity:1;background-color:rgb(45 72 116/var(--tw-bg-opacity));color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .w3a-button--login{align-items:center;display:inline-flex;height:2.75rem;justify-content:center}.w3a-parent-container #w3a-modal button.w3a-button--login:hover>.hover-icon{display:block;transition:display .15s;transition-timing-function:cubic-bezier(0,.54,.63,.99)}.w3a-parent-container #w3a-modal button.w3a-button--login:hover>.image-icon{display:none;transition:display .15s;transition-timing-function:cubic-bezier(0,.54,.63,.99)}.w3a-parent-container #w3a-modal button.w3a-button-expand{color:var(--app-primary-600);font-size:.875rem;height:auto;line-height:1.25rem;margin-left:auto;margin-top:1rem;width:auto}.w3a-parent-container #w3a-modal button.w3a-button-expand:hover{color:var(--app-primary-800)}.w3a-parent-container #w3a-modal button.w3a-button-expand:focus-visible{outline-color:var(--app-gray-50);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal button.w3a-button-expand:is(.dark *){color:var(--app-primary-500)}.w3a-parent-container #w3a-modal button.w3a-button-expand:hover:is(.dark *){color:var(--app-primary-400)}.w3a-parent-container #w3a-modal button.w3a-button-expand:focus-visible:is(.dark *){outline-color:var(--app-gray-400);outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .w3a-sms-field__container{display:grid;gap:.5rem;grid-template-columns:repeat(12,minmax(0,1fr))}.w3a-parent-container #w3a-modal .w3a-sms-field__code-selected{display:flex}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown{height:185px;position:absolute;width:120px;z-index:10}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-bottom-width:calc(1px*var(--tw-divide-y-reverse));border-color:var(--app-gray-100);border-top-width:calc(1px*(1 - var(--tw-divide-y-reverse)))}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown{--tw-shadow:0px 4px 16px #00000014;--tw-shadow-colored:0px 4px 16px var(--tw-shadow-color);background-color:var(--app-white);border-radius:.5rem;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow);overflow-y:scroll}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown:is(.dark *){background-color:var(--app-gray-700)}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown{transform:translateY(-230px)}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown ul{color:var(--app-gray-700);font-size:.875rem;line-height:1.25rem;padding-bottom:.5rem;padding-top:.5rem}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown ul:is(.dark *){color:var(--app-gray-200)}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown li{cursor:pointer;padding:0}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown li:hover{background-color:var(--app-gray-100)}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown li:hover:is(.dark *){background-color:var(--app-gray-900);color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown li button{height:100%;padding:.5rem 1rem;text-align:left;width:100%}.w3a-parent-container #w3a-modal .w3a-sms-field__code-dropdown li button div{align-items:center;display:flex}.w3a-parent-container #w3a-modal .w3a-sms-field__code{grid-column:span 5/span 5}.w3a-parent-container #w3a-modal .w3a-sms-field__number{grid-column:span 7/span 7}.w3a-parent-container #w3a-modal .w3a-modal__loader{background-color:var(--app-white);display:flex;inset:0;justify-content:center;position:absolute;z-index:10}.w3a-parent-container #w3a-modal .w3a-modal__loader:is(.dark *){background-color:var(--app-gray-800)}.w3a-parent-container #w3a-modal .w3a-modal__loader.w3a-modal__loader--hidden{display:none}.w3a-parent-container #w3a-modal .w3a-modal__loader-content{display:flex;flex-direction:column;position:relative;text-align:center}.w3a-parent-container #w3a-modal .w3a-modal__loader-info{align-items:center;display:flex;flex-direction:column;flex-grow:1;justify-content:center;padding:0 30px}.w3a-parent-container #w3a-modal .w3a-spinner-label{color:var(--app-primary-600);font-size:1rem;font-weight:500;line-height:1.5rem;margin-top:10px}.w3a-parent-container #w3a-modal .w3a-spinner-label:is(.dark *){color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .w3a-spinner-message{color:var(--app-gray-500);font-size:1rem;line-height:1.5rem;margin-top:10px}.w3a-parent-container #w3a-modal .w3a-spinner-message:first-letter{text-transform:capitalize}.w3a-parent-container #w3a-modal .w3a-spinner-message:is(.dark *){color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-spinner-message.w3a-spinner-message--error{color:var(--app-red-500)}.w3a-parent-container #w3a-modal .w3a-spinner-power{--tw-text-opacity:1;color:rgb(183 184 189/var(--tw-text-opacity));font-size:.75rem;line-height:1rem;margin-top:auto}.w3a-parent-container #w3a-modal .w3a-spinner-power>img{display:inline;height:2rem;width:auto}.w3a-parent-container #w3a-modal .w3a-spinner{display:inline-flex;height:60px;position:relative;width:60px}.w3a-parent-container #w3a-modal .w3a-spinner__spinner{position:absolute}@keyframes spin{to{transform:rotate(1turn)}}.w3a-parent-container #w3a-modal .w3a-spinner__spinner{animation:spin 1s linear infinite;background-image:conic-gradient(from 0deg at 50% 50%,var(--app-primary-600) 0,#e5e7ebcc 90deg,#e5e7ebcc 270deg,var(--app-primary-600) 1turn);background-position:0 0;background-size:100% 100%;border-radius:100vw;display:inline-block;height:100%;-webkit-mask:radial-gradient(farthest-side,#000 98%,#0000) center/85% 85% no-repeat,linear-gradient(#000 0 0);-webkit-mask-composite:destination-out;mask:radial-gradient(farthest-side,#000 98%,#0000) center/85% 85% no-repeat,linear-gradient(#000 0 0);mask-composite:exclude;width:100%}.w3a-parent-container .dark #w3a-modal .w3a-spinner__spinner{background-image:conic-gradient(from 0deg at 50% 50%,var(--app-primary-500) 0,#e5e7eb33 90deg,#e5e7eb33 270deg,var(--app-primary-500) 1turn)}.w3a-parent-container #w3a-modal .w3a-modal__loader-bridge{align-items:center;display:flex;justify-content:center;margin-bottom:14px}.w3a-parent-container #w3a-modal .w3a-modal__loader-bridge-message{color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .w3a-modal__loader-bridge-message:first-letter{text-transform:capitalize}.w3a-parent-container #w3a-modal .w3a-modal__loader-bridge-message:is(.dark *){color:var(--app-white)}.w3a-parent-container #w3a-modal .w3a-modal__loader-app-logo{display:flex;padding:.5rem}.w3a-parent-container #w3a-modal .w3a-modal__loader-app-logo img{height:auto;max-height:72px;max-width:72px;width:72px}.w3a-parent-container #w3a-modal .w3a-modal__loader-social-logo{align-items:center;background-color:var(--app-gray-100);border-radius:9999px;display:flex;height:72px;justify-content:center;width:72px}.w3a-parent-container #w3a-modal .w3a-modal__loader-social-logo:is(.dark *){background-color:var(--app-gray-50)}.w3a-parent-container #w3a-modal .w3a-modal__loader-social-logo img{height:4rem;width:4rem}.w3a-parent-container #w3a-modal .w3a-modal__loader-adapter img{height:auto;width:84px}.w3a-parent-container #w3a-modal .w3a-modal__connector{align-items:center;display:flex}.w3a-parent-container .w3a-modal__connector-beat{display:inline-block;height:80px;position:relative;width:80px}.w3a-parent-container .w3a-modal__connector-beat div{animation-timing-function:cubic-bezier(0,1,1,0);background:grey;border-radius:50%;height:13px;position:absolute;top:33px;width:13px}.w3a-parent-container .w3a-modal__connector-beat div:first-child{animation:beat1 2.4s infinite;left:8px}.w3a-parent-container .w3a-modal__connector-beat div:nth-child(2){animation:beat2 2.4s infinite;left:8px}.w3a-parent-container .w3a-modal__connector-beat div:nth-child(3){animation:beat3 2.4s infinite;left:8px}.w3a-parent-container .w3a-modal__connector-beat div:nth-child(4){animation:beat4 2.4s infinite;left:32px}.w3a-parent-container .w3a-modal__connector-beat div:nth-child(5){animation:beat5 2.4s infinite;left:56px}@keyframes beat1{0%{transform:scale(0)}25%{transform:scale(0)}50%{transform:scale(1)}75%{transform:scale(0)}to{transform:scale(0)}}@keyframes beat2{0%{transform:scale(0)}25%{transform:scale(1)}50%{transform:translate(24px)}75%{transform:translate(0)}to{transform:translate(0) scale(0)}}@keyframes beat3{0%{transform:translate(0)}25%{transform:translate(24px)}50%{transform:translate(48px)}75%{transform:translate(24px)}to{transform:translate(0)}}@keyframes beat4{0%{transform:translate(0)}25%{transform:translate(24px)}50%{transform:translate(24px) scale(0)}75%{transform:translate(24px) scale(1)}to{transform:translate(0)}}@keyframes beat5{0%{transform:scale(1)}25%{transform:scale(0)}50%{transform:scale(0)}75%{transform:scale(0)}to{transform:scale(1)}}.w3a-parent-container .group:hover .group-hover\\:flex{display:flex}.w3a-parent-container .dark\\:block:is(.dark *){display:block}.w3a-parent-container .dark\\:hidden:is(.dark *){display:none}.w3a-parent-container .dark\\:bg-app-gray-600:is(.dark *){background-color:var(--app-gray-600)}.w3a-parent-container .dark\\:text-app-gray-400:is(.dark *){color:var(--app-gray-400)}.w3a-parent-container .dark\\:text-app-gray-500:is(.dark *){color:var(--app-gray-500)}.w3a-parent-container .dark\\:text-app-white:is(.dark *){color:var(--app-white)}';
styleInject(css_248z$1);
var modal = {
  "adapter-loader.message": "Verify your {{adapter}} account to continue",
  "adapter-loader.message1": "Verify your {{adapter}}",
  "adapter-loader.message2": "account to continue",
  "errors-invalid-number-email": "Invalid Email or Phone Number",
  "errors-invalid-number": "Invalid Phone Number",
  "errors-invalid-email": "Invalid Email",
  "errors-required": "Required",
  "external.back": "Back",
  "external.connect": "Connect with Wallet",
  "external.continue": "Continue with external wallet",
  "external.no-wallets-found": "No wallets found",
  "external.title": "External Wallet",
  "external.walletconnect-connect": "Connect",
  "external.walletconnect-copy": "Click on the QR Code to copy to clipboard",
  "external.walletconnect-subtitle": "Scan the QR code with a WalletConnect-compatible wallet",
  "footer.message": "Self-custodial login by",
  "footer.message-new": "Self-custody via",
  "footer.policy": "Privacy Policy",
  "footer.terms": "Terms of Use",
  "footer.terms-service": "Terms of Service",
  "footer.version": "Version",
  "header-subtitle": "Select one of the following options to continue",
  "header-subtitle-name": "Your {{appName}} wallet with one click",
  "header-subtitle-new": "Your blockchain wallet with one click",
  "header-title": "Sign in",
  "header-tooltip-desc": "The wallet serves as an account to store and manage your digital assets on the blockchain.",
  "header-tooltip-title": "Wallet",
  "network.add-request": "This site is requesting to add a network",
  "network.cancel": "Cancel",
  "network.from": "From",
  "network.proceed": "Proceed",
  "network.switch-request": "This site is requesting to switch networks",
  "network.to": "To",
  "popup.phone-body": "Your country code will be detected automatically, but if you're using a phone number from a different country, you'll need to enter the correct country code manually.",
  "popup.phone-header": "Phone number and country code",
  "social.continue": "Continue with",
  "social.continueCustom": "Continue with {{adapter}}",
  "social.email": "Email",
  "social.email-continue": "Continue with Email",
  "social.email-new": "name@example.com",
  "social.passwordless-cta": "Continue",
  "social.passwordless-login": "Login",
  "social.passwordless-title": "Email or Phone",
  "social.phone": "Phone",
  "social.policy": "We do not store any data related to your social logins.",
  "social.sms": "Mobile",
  "social.sms-continue": "Continue with Mobile",
  "social.sms-invalid-number": "Invalid phone number",
  "social.sms-placeholder-text": "E.g.:",
  "social.view-less": "View less",
  "social.view-more": "View more",
  "social.view-less-socials": "View less socials",
  "social.view-more-socials": "View more socials",
  "passkey.haveExisting": "Have an existing passkey?",
  "passkey.use": "I have a passkey",
  "passkey.or": "or",
  "passkey.register-title": "Register Passkey",
  "passkey.register-desc": "With passkeys, you can verify your identity through your face, fingerprint, or security keys.",
  "passkey.learn-more": "Learn more",
  "passkey.add": "Add Passkey",
  "post-loading.connected": "You are connected with your account",
  "post-loading.something-wrong": "Something went wrong!"
};
var en = {
  modal
};
var i18nInstance2 = instance.createInstance();
i18nInstance2.use(initReactI18next).init({
  resources: {
    en: {
      translation: en
    }
  },
  lng: "en",
  fallbackLng: "en",
  interpolation: {
    escapeValue: false
  },
  debug: false,
  react: {
    useSuspense: true
  }
});
function SelfCustodyViaWeb3Auth() {
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "flex items-center gap-2 justify-center p-2",
    children: [(0, import_jsx_runtime.jsx)("div", {
      className: "text-xs text-app-gray-300 dark:text-app-gray-500",
      children: t2("modal.footer.message-new")
    }), (0, import_jsx_runtime.jsx)("img", {
      height: "16",
      src: "https://images.web3auth.io/web3auth-footer-logo-light.svg",
      alt: "Web3Auth Logo Light",
      className: "h-4 block dark:hidden"
    }), (0, import_jsx_runtime.jsx)("img", {
      height: "16",
      src: "https://images.web3auth.io/web3auth-footer-logo-dark.svg",
      alt: "Web3Auth Logo Dark",
      className: "h-4 hidden dark:block"
    })]
  });
}
function Footer() {
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3a-modal__footer",
    children: (0, import_jsx_runtime.jsx)("div", {
      className: "w3a-footer",
      children: (0, import_jsx_runtime.jsx)("div", {
        children: (0, import_jsx_runtime.jsx)("div", {
          children: (0, import_jsx_runtime.jsx)(SelfCustodyViaWeb3Auth, {})
        })
      })
    })
  });
}
var icons = {
  "arrow-left": {
    image: "https://images.web3auth.io/circle-arrow-left.svg"
  },
  close: {
    image: "https://images.web3auth.io/close.svg"
  },
  "expand-light": {
    image: "https://images.web3auth.io/expand-light.svg"
  },
  expand: {
    image: "https://images.web3auth.io/expand.svg"
  },
  connected: {
    image: "https://images.web3auth.io/connected.svg"
  },
  "information-circle-light": {
    image: "https://images.web3auth.io/information-circle-light.svg"
  },
  "information-circle": {
    image: "https://images.web3auth.io/information-circle.svg"
  }
};
function Icon(props) {
  const {
    iconName,
    iconTitle = "",
    height = "auto",
    width = "auto"
  } = props;
  return icons[iconName] ? (0, import_jsx_runtime.jsx)("img", {
    className: iconTitle ? "cursor-pointer" : "",
    height,
    width,
    src: icons[iconName].image,
    alt: iconName,
    title: iconTitle
  }) : null;
}
function Image$1(props) {
  const {
    hoverImageId,
    imageId,
    isButton = false,
    height = "auto",
    width = "auto"
  } = props;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)("img", {
      src: `https://images.web3auth.io/${imageId}.svg`,
      height,
      width,
      alt: imageId,
      className: "image-icon"
    }), isButton ? (0, import_jsx_runtime.jsx)("img", {
      src: `https://images.web3auth.io/${hoverImageId}.svg`,
      height,
      width,
      alt: hoverImageId,
      className: "hover-icon"
    }) : null]
  });
}
var closeIcon$1 = (0, import_jsx_runtime.jsx)(Icon, {
  iconName: "close"
});
function DetailedLoader(props) {
  const {
    adapter,
    appLogo,
    message,
    modalStatus,
    adapterName,
    onClose
  } = props;
  const providerIcon = adapter === "twitter" ? (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: "login-x-dark"
  }) : (0, import_jsx_runtime.jsx)(Image$1, {
    imageId: `login-${adapter}`
  });
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  (0, import_react9.useEffect)(() => {
    loglevel.debug("adapter loader re-rendering");
    if (modalStatus === MODAL_STATUS.CONNECTED) {
      setTimeout(() => {
        onClose();
      }, 3e3);
    }
  }, [modalStatus, onClose]);
  return modalStatus !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-modal-loader w3a-modal__loader",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-modal__loader-content",
      children: [(0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-modal__loader-info",
        children: [modalStatus === MODAL_STATUS.CONNECTING && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsxs)("div", {
            className: "w3a-modal__loader-bridge",
            children: [(0, import_jsx_runtime.jsxs)("div", {
              className: "w3a-modal__loader-app-logo",
              children: [(0, import_jsx_runtime.jsx)("img", {
                src: appLogo,
                className: "block dark:hidden",
                alt: ""
              }), (0, import_jsx_runtime.jsx)("img", {
                src: appLogo,
                className: "hidden dark:block",
                alt: ""
              })]
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__connector",
              children: (0, import_jsx_runtime.jsxs)("div", {
                className: "w3a-modal__connector-beat",
                children: [(0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {})]
              })
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__loader-social-logo",
              children: providerIcon
            })]
          }), (0, import_jsx_runtime.jsxs)("div", {
            children: [(0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__loader-bridge-message",
              children: t2("modal.adapter-loader.message1", {
                adapter: adapterName
              })
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "w3a-modal__loader-bridge-message",
              children: t2("modal.adapter-loader.message2", {
                adapter: adapterName
              })
            })]
          })]
        }), modalStatus === ADAPTER_STATUS.CONNECTED && (0, import_jsx_runtime.jsxs)("div", {
          className: "flex flex-col items-center",
          children: [(0, import_jsx_runtime.jsx)(Icon, {
            iconName: "connected"
          }), (0, import_jsx_runtime.jsx)("div", {
            className: "w3ajs-modal-loader__message w3a-spinner-message mt-4",
            children: message
          })]
        }), modalStatus === ADAPTER_STATUS.ERRORED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message w3a-spinner-message--error",
          children: message
        })]
      }), (0, import_jsx_runtime.jsx)(Footer, {})]
    }), (modalStatus === ADAPTER_STATUS.CONNECTED || modalStatus === ADAPTER_STATUS.ERRORED) && (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      className: "w3a-header__button w3ajs-loader-close-btn",
      onClick: onClose,
      children: closeIcon$1
    })]
  }) : null;
}
var css_248z = ".w3a-parent-container #w3a-modal button.t-btn,.w3a-parent-container a.t-btn{align-items:center;display:flex;justify-content:center;transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-timing-function:linear}.w3a-parent-container #w3a-modal button.t-btn:not(.t-btn-text):disabled,.w3a-parent-container a.t-btn:not(.t-btn-text):disabled{background-color:var(--app-gray-300);border-width:0;color:var(--app-gray-400)}.w3a-parent-container #w3a-modal button.t-btn:not(.t-btn-text):hover:disabled,.w3a-parent-container a.t-btn:not(.t-btn-text):hover:disabled{background-color:var(--app-gray-300);border-color:var(--app-gray-300);color:var(--app-gray-400)}.w3a-parent-container #w3a-modal button.t-btn:not(.t-btn-text):active:disabled,.w3a-parent-container a.t-btn:not(.t-btn-text):active:disabled{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-offset-width:0px;background-color:var(--app-gray-300);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000);outline-width:0}.w3a-parent-container #w3a-modal button.t-btn:not(.t-btn-text):disabled:is(.dark *),.w3a-parent-container a.t-btn:not(.t-btn-text):disabled:is(.dark *){background-color:var(--app-gray-700);color:var(--app-gray-600)}.w3a-parent-container #w3a-modal .size-xs{font-size:.75rem;height:32px;line-height:1rem;padding:.5rem .75rem}.w3a-parent-container #w3a-modal .size-sm{font-size:.875rem;height:36px;line-height:1.25rem;padding:.5rem .75rem}.w3a-parent-container #w3a-modal .size-md{font-size:.875rem;height:42px;line-height:1.25rem;padding:.625rem 1.25rem}.w3a-parent-container #w3a-modal .size-lg{font-size:1rem;height:48px;line-height:1.5rem;padding:.75rem 1.25rem}.w3a-parent-container #w3a-modal .size-xl{font-size:1rem;height:52px;line-height:1.5rem;padding:.875rem 1.5rem}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary{background-color:var(--app-primary-600);color:var(--app-on-primary);outline:2px solid #0000;outline-offset:2px}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:hover{background-color:var(--app-primary-700)}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:focus-visible{outline-color:var(--app-primary-600);outline-offset:1px;outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:active{background-color:var(--app-primary-600);outline-color:var(--app-primary-600);outline-offset:1px;outline-style:solid;outline-width:1px}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:is(.dark *){background-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:hover:is(.dark *){background-color:var(--app-primary-400)}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:focus-visible:is(.dark *){outline-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-primary:active:is(.dark *){background-color:var(--app-primary-500);outline-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary{background-color:initial;border-color:var(--app-gray-500);border-width:1px;color:var(--app-gray-600);outline:2px solid #0000;outline-offset:2px}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:hover{background-color:var(--app-gray-200)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:focus-visible{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);background-color:initial;border-color:var(--app-primary-600);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);background-color:initial;border-color:var(--app-primary-600);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:is(.dark *){border-color:var(--app-gray-300);color:var(--app-white)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:hover:is(.dark *){background-color:var(--app-gray-700)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:focus-visible:is(.dark *){--tw-ring-color:var(--app-primary-500);background-color:initial;border-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-secondary:active:is(.dark *){--tw-ring-color:var(--app-primary-500);background-color:initial;border-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary{background-color:var(--app-gray-200);color:var(--app-gray-800)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:hover{background-color:var(--app-gray-300)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:focus-visible{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);background-color:var(--app-gray-200);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:is(.dark *){background-color:var(--app-gray-500);color:var(--app-white)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:hover:is(.dark *){background-color:var(--app-gray-400)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:focus-visible:is(.dark *){--tw-ring-color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-tertiary:active:is(.dark *){--tw-ring-color:var(--app-primary-500);background-color:var(--app-gray-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text{color:var(--app-primary-600)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:hover{color:var(--app-primary-800);text-decoration-line:underline}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:focus-visible{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:var(--app-primary-600);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000);color:var(--app-primary-600)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:disabled{color:var(--app-gray-400);text-decoration-line:none}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:is(.dark *){color:var(--app-primary-500)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:hover:is(.dark *){color:var(--app-primary-400)}.w3a-parent-container #w3a-modal .t-btn.t-btn-text:disabled:is(.dark *){color:var(--app-gray-600)}.w3a-parent-container #w3a-modal .btn-link{text-decoration-line:none}.w3a-parent-container #w3a-modal button.t-btn:hover>.hover-icon{display:block;transition:display .15s;transition-timing-function:cubic-bezier(0,.54,.63,.99)}.w3a-parent-container #w3a-modal button.t-btn:hover>.image-icon{display:none;transition:display .15s;transition-timing-function:cubic-bezier(0,.54,.63,.99)}";
styleInject(css_248z);
function Button(props) {
  const {
    variant = "primary",
    onClick,
    children,
    title,
    className,
    style,
    size = "md",
    disabled,
    type = "button"
  } = props;
  const sizeClass = `size-${size}`;
  return (0, import_jsx_runtime.jsx)("button", {
    disabled,
    type,
    className: `t-btn t-btn-${variant} rounded-full ${sizeClass} ${className}`,
    onClick,
    title,
    style,
    children
  });
}
var Button$1 = (0, import_react9.memo)(Button);
var closeIcon = (0, import_jsx_runtime.jsx)(Icon, {
  iconName: "close"
});
function Loader(props) {
  const {
    message,
    modalStatus,
    label,
    onClose,
    canEmit = true
  } = props;
  (0, import_react9.useEffect)(() => {
    loglevel.debug("loader re-rendering");
    if (modalStatus === MODAL_STATUS.CONNECTED && canEmit) {
      setTimeout(() => {
        onClose();
      }, 3e3);
    }
  }, [canEmit, modalStatus, onClose]);
  return modalStatus !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-modal-loader w3a-modal__loader",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-modal__loader-content",
      children: [(0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-modal__loader-info",
        children: [modalStatus === MODAL_STATUS.CONNECTING && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__spinner w3a-spinner",
          children: (0, import_jsx_runtime.jsx)("div", {
            className: "w3a-spinner__spinner"
          })
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__label w3a-spinner-label",
          children: label
        }), modalStatus === ADAPTER_STATUS.CONNECTED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message",
          children: message
        }), modalStatus === ADAPTER_STATUS.ERRORED && (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-modal-loader__message w3a-spinner-message w3a-spinner-message--error",
          children: message
        })]
      }), (0, import_jsx_runtime.jsx)(Footer, {})]
    }), (modalStatus === ADAPTER_STATUS.CONNECTED || modalStatus === ADAPTER_STATUS.ERRORED) && (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      className: "w3a-header__button w3ajs-loader-close-btn",
      onClick: onClose,
      children: closeIcon
    })]
  }) : null;
}
function WalletConnect(props) {
  const {
    walletConnectUri
  } = props;
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-wallet-connect w3a-wallet-connect",
    children: (0, import_jsx_runtime.jsx)("div", {
      className: "w3ajs-wallet-connect__container w3a-wallet-connect__container",
      children: (0, import_jsx_runtime.jsxs)("div", {
        className: "w3a-wallet-connect__container-desktop",
        children: [(0, import_jsx_runtime.jsx)("div", {
          children: t2("modal.external.walletconnect-subtitle")
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3ajs-wallet-connect-qr w3a-wallet-connect-qr",
          tabIndex: 0,
          role: "button",
          onClick: () => (0, import_copy_to_clipboard.default)(walletConnectUri),
          onKeyDown: () => (0, import_copy_to_clipboard.default)(walletConnectUri),
          children: (0, import_jsx_runtime.jsx)(import_react_qrcode_logo.QRCode, {
            size: 200,
            eyeRadius: 5,
            qrStyle: "dots",
            removeQrCodeBehindLogo: true,
            logoImage: WALLET_CONNECT_LOGO,
            value: walletConnectUri
          })
        }), (0, import_jsx_runtime.jsx)("div", {
          children: t2("modal.external.walletconnect-copy")
        })]
      })
    })
  });
}
var WalletConnect$1 = (0, import_react9.memo)(WalletConnect);
function formatIOSMobile(params) {
  const encodedUri = encodeURIComponent(params.uri);
  if (params.universalLink) {
    return `${params.universalLink}/wc?uri=${encodedUri}`;
  }
  if (params.deepLink) {
    return `${params.deepLink}${params.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}`;
  }
  return "";
}
function formatMobileRegistryEntry(entry, walletConnectUri, os, platform = "mobile") {
  const universalLink = entry[platform].universal || "";
  const deepLink = entry[platform].native || "";
  return {
    name: entry.name || "",
    logo: entry.logo || "",
    universalLink,
    deepLink,
    href: os === bowser_default.OS_MAP.iOS ? formatIOSMobile({
      uri: walletConnectUri,
      universalLink,
      deepLink
    }) : walletConnectUri
  };
}
function formatMobileRegistry(registry, walletConnectUri, os, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, walletConnectUri, os, platform));
}
function ExternalWallet(props) {
  const {
    hideExternalWallets,
    handleExternalWalletClick,
    config = {},
    walletConnectUri,
    showBackButton,
    modalStatus,
    wcAdapters
  } = props;
  const [isLoaded, setIsLoaded] = (0, import_react9.useState)(true);
  const [adapterVisibilityMap, setAdapterVisibilityMap] = (0, import_react9.useState)({});
  const [externalButtons, setExternalButtons] = (0, import_react9.useState)([]);
  const deviceType = (0, import_react9.useMemo)(() => {
    const browser = bowser_default.getParser(window.navigator.userAgent);
    return browser.getPlatformType();
  }, []);
  const deviceDetails = (0, import_react9.useMemo)(() => {
    const browser = bowser_default.getParser(window.navigator.userAgent);
    return {
      platform: browser.getPlatformType(),
      os: browser.getOSName()
    };
  }, []);
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  (0, import_react9.useEffect)(() => {
    var _config$walletConnect;
    loglevel.debug("loaded external wallets", config, walletConnectUri, deviceType);
    const walletConnectAdapterName = WALLET_ADAPTERS.WALLET_CONNECT_V2;
    const wcAvailable = (((_config$walletConnect = config[walletConnectAdapterName]) === null || _config$walletConnect === void 0 ? void 0 : _config$walletConnect.showOnModal) || false) !== false;
    if (wcAvailable && !walletConnectUri) {
      setIsLoaded(false);
      handleExternalWalletClick({
        adapter: walletConnectAdapterName
      });
    } else if (Object.keys(config).length > 0) {
      setIsLoaded(true);
    }
    const canShowMap = {};
    Object.keys(config).forEach((adapter) => {
      const adapterConfig = config[adapter];
      if (!adapterConfig.showOnModal) {
        canShowMap[adapter] = false;
        return;
      }
      if (deviceType === "desktop" && adapterConfig.showOnDesktop) {
        canShowMap[adapter] = true;
        return;
      }
      if ((deviceType === "mobile" || deviceType === "tablet") && adapterConfig.showOnMobile) {
        canShowMap[adapter] = true;
        return;
      }
      canShowMap[adapter] = false;
    });
    setAdapterVisibilityMap(canShowMap);
  }, [config, handleExternalWalletClick, walletConnectUri, deviceType]);
  (0, import_react9.useEffect)(() => {
    const buttons = [];
    if (deviceDetails.platform === bowser_default.PLATFORMS_MAP.mobile) {
      let mobileLinks = formatMobileRegistry(wcAdapters, walletConnectUri, deviceDetails.os, deviceDetails.platform);
      if (deviceDetails.os === bowser_default.OS_MAP.iOS) {
        var _window$ethereum;
        if ((_window$ethereum = window.ethereum) !== null && _window$ethereum !== void 0 && _window$ethereum.isMetaMask) {
          mobileLinks = mobileLinks.filter((x) => x.name !== "MetaMask");
        }
        buttons.push(...mobileLinks.map((link) => ({
          name: link.name,
          href: link.href,
          logo: link.logo,
          isLink: true,
          block: false
        })));
      } else if (mobileLinks.length > 0) {
        buttons.push({
          name: "WalletConnect",
          href: mobileLinks[0].href,
          logo: WALLET_CONNECT_LOGO,
          isLink: true,
          block: true
        });
      }
    }
    const adapterBtns = Object.keys(config).filter((adapter) => ![WALLET_ADAPTERS.WALLET_CONNECT_V2].includes(adapter) && adapterVisibilityMap[adapter]).map((adapter) => ({
      name: adapter,
      isLink: false,
      block: false
    }));
    if (adapterBtns.length === 1 && deviceDetails.os !== bowser_default.OS_MAP.iOS) adapterBtns[0].block = true;
    buttons.push(...adapterBtns);
    setExternalButtons(buttons);
  }, [wcAdapters, config, deviceDetails.os, deviceDetails.platform, walletConnectUri, adapterVisibilityMap]);
  return (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-external-wallet w3a-group",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-external-container w3ajs-external-container",
      children: [showBackButton && (0, import_jsx_runtime.jsxs)("button", {
        type: "button",
        className: "w3a-external-back w3ajs-external-back",
        onClick: () => hideExternalWallets(),
        children: [(0, import_jsx_runtime.jsx)(Icon, {
          iconName: "arrow-left"
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3a-group__title",
          children: t2("modal.external.back")
        })]
      }), !isLoaded && (0, import_jsx_runtime.jsx)(Loader, {
        modalStatus: MODAL_STATUS.CONNECTING,
        canEmit: false
      }), Object.keys(config).map((adapter) => {
        if (walletConnectUri && deviceDetails.platform === bowser_default.PLATFORMS_MAP.desktop && [WALLET_ADAPTERS.WALLET_CONNECT_V2].includes(adapter)) {
          return (0, import_jsx_runtime.jsx)(WalletConnect$1, {
            walletConnectUri
          }, adapter);
        }
        return null;
      }), modalStatus === MODAL_STATUS.INITIALIZED && (externalButtons.length > 0 ? (0, import_jsx_runtime.jsx)("ul", {
        className: "w3a-adapter-list w3ajs-wallet-adapters",
        children: externalButtons.map((button) => {
          var _config$button$name, _config$button$name2;
          const providerIcon = button.isLink ? (0, import_jsx_runtime.jsx)("img", {
            src: button.logo,
            height: "auto",
            width: "auto",
            alt: `login-${button.name}`
          }) : (0, import_jsx_runtime.jsx)(Image$1, {
            imageId: `login-${button.name}`,
            hoverImageId: `login-${button.name}`,
            height: "32",
            width: "32",
            isButton: true
          });
          const isBlock = externalButtons.length === 1 || button.block;
          const label = isBlock ? (0, import_jsx_runtime.jsx)("p", {
            className: "ml-2 text-left",
            children: ((_config$button$name = config[button.name]) === null || _config$button$name === void 0 ? void 0 : _config$button$name.label) || button.name
          }) : "";
          return (0, import_jsx_runtime.jsx)("li", {
            className: [`w3a-adapter-item`, isBlock ? "w3a-adapter-item--full" : "col-span-2"].join(" "),
            children: button.isLink ? (0, import_jsx_runtime.jsx)("a", {
              href: button.href,
              rel: "noopener noreferrer",
              target: "_blank",
              children: (0, import_jsx_runtime.jsxs)(Button$1, {
                type: "button",
                variant: "tertiary",
                className: "w-full",
                children: [providerIcon, label]
              })
            }, button.name) : (0, import_jsx_runtime.jsxs)(Button$1, {
              variant: "tertiary",
              type: "button",
              onClick: () => handleExternalWalletClick({
                adapter: button.name
              }),
              className: "w-full",
              title: ((_config$button$name2 = config[button.name]) === null || _config$button$name2 === void 0 ? void 0 : _config$button$name2.label) || button.name,
              children: [providerIcon, label]
            })
          }, button.name);
        })
      }) : (0, import_jsx_runtime.jsx)("div", {
        className: "mt-4 text-center text-sm font-normal text-app-gray-500 dark:text-app-gray-400",
        children: t2("modal.external.no-wallets-found")
      }))]
    })
  });
}
var ThemedContext = (0, import_react9.createContext)({
  isDark: true
  // default value
});
function Header(props) {
  const {
    isDark
  } = (0, import_react9.useContext)(ThemedContext);
  const {
    onClose,
    appLogo,
    appName
  } = props;
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const headerLogo = [DEFAULT_LOGO_DARK, DEFAULT_LOGO_LIGHT].includes(appLogo) ? "" : appLogo;
  const subtitle = t2("modal.header-subtitle-name", {
    appName
  });
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3a-modal__header",
    children: [(0, import_jsx_runtime.jsx)("div", {
      className: "w3a-header",
      children: (0, import_jsx_runtime.jsxs)("div", {
        children: [headerLogo && (0, import_jsx_runtime.jsx)("div", {
          className: "w3a-header__logo",
          children: (0, import_jsx_runtime.jsx)("img", {
            src: headerLogo,
            alt: ""
          })
        }), (0, import_jsx_runtime.jsx)("div", {
          className: "w3a-header__title",
          children: t2("modal.header-title")
        }), (0, import_jsx_runtime.jsxs)("div", {
          className: "w3a-header__subtitle",
          children: [subtitle, (0, import_jsx_runtime.jsxs)("div", {
            className: "relative flex flex-col items-center group cursor-pointer",
            children: [(0, import_jsx_runtime.jsx)(Icon, {
              iconName: `information-circle${isDark ? "-light" : ""}`
            }), (0, import_jsx_runtime.jsxs)("div", {
              className: "absolute top-4 z-20 flex-col items-center hidden mb-5 group-hover:flex",
              children: [(0, import_jsx_runtime.jsx)("div", {
                className: "w-3 h-3 ml-[3px] -mb-2 rotate-45 bg-app-gray-50 dark:bg-app-gray-600"
              }), (0, import_jsx_runtime.jsxs)("div", {
                className: `relative p-4 w-[270px] -translate-x-16 text-xs leading-none text-app-white rounded-md bg-app-gray-50 dark:bg-app-gray-600 shadow-lg ${subtitle.length > 34 ? "-ml-[100px]" : ""}`,
                children: [(0, import_jsx_runtime.jsx)("div", {
                  className: "text-xs font-medium mb-1 text-app-gray-900 dark:text-app-white",
                  children: t2("modal.header-tooltip-title")
                }), (0, import_jsx_runtime.jsx)("div", {
                  className: "text-xs text-app-gray-400",
                  children: t2("modal.header-tooltip-desc")
                })]
              })]
            })]
          })]
        })]
      })
    }), (0, import_jsx_runtime.jsx)("button", {
      type: "button",
      onClick: onClose,
      className: "w3a-header__button w3ajs-close-btn",
      children: (0, import_jsx_runtime.jsx)(Icon, {
        iconName: "close"
      })
    })]
  });
}
var memoizedHeader = (0, import_react9.memo)(Header, (prevProps, nextProps) => {
  if (prevProps.appLogo !== nextProps.appLogo) {
    return true;
  }
  return false;
});
memoizedHeader.displayName = "Header";
var getAdapterSocialLogins = (adapterName, loginMethodsConfig = {}) => {
  const finalLoginMethodsConfig = {};
  if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
    OPENLOGIN_PROVIDERS.forEach((loginMethod) => {
      const currentLoginMethodConfig = loginMethodsConfig[loginMethod] || {
        name: OPENLOGIN_PROVIDERS_NAMES[loginMethod],
        showOnMobile: true,
        showOnModal: true,
        showOnDesktop: true
      };
      finalLoginMethodsConfig[loginMethod] = _objectSpread2({}, currentLoginMethodConfig);
    });
    loglevel.debug("OpenLogin login method ui config", finalLoginMethodsConfig);
  } else {
    throw WalletInitializationError.invalidParams(`${adapterName} is not a valid adapter`);
  }
  return finalLoginMethodsConfig;
};
var passwordlessBackendUrl = "https://api-passwordless.web3auth.io";
var getUserCountry = async () => {
  try {
    const result = await get(`${passwordlessBackendUrl}/api/v3/user/location`);
    if (result && result.data.country) return {
      country: result.data.country,
      dialCode: result.data.dial_code
    };
    return null;
  } catch (error) {
    loglevel.error("error getting user country", error);
    return null;
  }
};
var validatePhoneNumber = async (phoneNumber) => {
  try {
    const result = await post(`${passwordlessBackendUrl}/api/v3/phone_number/validate`, {
      phone_number: phoneNumber
    });
    if (result && result.success) return result.parsed_number;
    return false;
  } catch (error) {
    loglevel.error("error validating phone number", error);
    if (error.status === 400) {
      return false;
    }
    return true;
  }
};
var getUserLanguage = (defaultLanguage) => {
  let userLanguage = defaultLanguage;
  if (!userLanguage) {
    const browserLanguage = typeof window !== "undefined" ? window.navigator.userLanguage || window.navigator.language || "en-US" : "en-US";
    userLanguage = browserLanguage.split("-")[0];
  }
  return Object.prototype.hasOwnProperty.call(LANGUAGE_MAP, userLanguage) ? userLanguage : LANGUAGES.en;
};
function SocialLoginPasswordless(props) {
  const {
    handleSocialLoginClick,
    adapter,
    isPrimaryBtn,
    isEmailVisible,
    isSmsVisible
  } = props;
  const {
    isDark
  } = (0, import_react9.useContext)(ThemedContext);
  const [fieldValue, setFieldValue] = (0, import_react9.useState)("");
  const [countryCode, setCountryCode] = (0, import_react9.useState)("");
  const [isValidInput, setIsValidInput] = (0, import_react9.useState)(null);
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const handleFormSubmit = async (e2) => {
    e2.preventDefault();
    const value = fieldValue;
    if (isEmailVisible) {
      const isEmailValid = value.match(/^([\w.%+-]+)@([\w-]+\.)+([\w]{2,})$/i);
      if (isEmailValid) {
        return handleSocialLoginClick({
          adapter,
          loginParams: {
            loginProvider: LOGIN_PROVIDER2.EMAIL_PASSWORDLESS,
            login_hint: value,
            name: "Email"
          }
        });
      }
    }
    if (isSmsVisible) {
      const number = value.startsWith("+") ? value : `${countryCode}${value}`;
      const result = await validatePhoneNumber(number);
      if (result) {
        return handleSocialLoginClick({
          adapter,
          loginParams: {
            loginProvider: LOGIN_PROVIDER2.SMS_PASSWORDLESS,
            login_hint: typeof result === "string" ? result : number,
            name: "Mobile"
          }
        });
      }
    }
    setIsValidInput(false);
    return void 0;
  };
  (0, import_react9.useEffect)(() => {
    const getLocation = async () => {
      const result = await getUserCountry();
      if (result && result.dialCode) {
        setCountryCode(result.dialCode);
      }
    };
    if (isSmsVisible) getLocation();
  }, [isSmsVisible]);
  const handleInputChange = (e2) => {
    setFieldValue(e2.target.value);
    if (isValidInput === false) setIsValidInput(null);
  };
  const title = (0, import_react9.useMemo)(() => {
    if (isEmailVisible && isSmsVisible) return "modal.social.passwordless-title";
    if (isEmailVisible) return "modal.social.email";
    return "modal.social.phone";
  }, [isEmailVisible, isSmsVisible]);
  const placeholder = (0, import_react9.useMemo)(() => {
    if (isEmailVisible && isSmsVisible) return "+(00)123456/name@example.com";
    if (isEmailVisible) return "name@example.com";
    return "+(00)123456";
  }, [isEmailVisible, isSmsVisible]);
  const invalidInputErrorMessage = (0, import_react9.useMemo)(() => {
    if (isEmailVisible && isSmsVisible) return "modal.errors-invalid-number-email";
    if (isEmailVisible) return "modal.errors-invalid-email";
    return "modal.errors-invalid-number";
  }, [isEmailVisible, isSmsVisible]);
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-passwordless w3a-group w3a-group--passwordless",
    children: [(0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-group__title",
      children: [t2(title), isSmsVisible && (0, import_jsx_runtime.jsxs)("div", {
        className: "relative flex flex-col items-center cursor-pointer group",
        children: [(0, import_jsx_runtime.jsx)(Icon, {
          iconName: `information-circle${isDark ? "-light" : ""}`
        }), (0, import_jsx_runtime.jsxs)("div", {
          className: "absolute z-20 flex-col items-center hidden mb-5 top-4 group-hover:flex",
          children: [(0, import_jsx_runtime.jsx)("div", {
            className: "w-3 h-3 ml-[3px] -mb-2 rotate-45 bg-app-gray-50 dark:bg-app-gray-600"
          }), (0, import_jsx_runtime.jsxs)("div", {
            className: `relative p-4 w-[300px] text-xs leading-none text-app-white rounded-md bg-app-gray-50 dark:bg-app-gray-600 shadow-lg ${isSmsVisible && !isEmailVisible ? "left-20" : "left-8"}`,
            children: [(0, import_jsx_runtime.jsx)("div", {
              className: "mb-1 text-xs font-medium text-app-gray-900 dark:text-app-white",
              children: t2("modal.popup.phone-header")
            }), (0, import_jsx_runtime.jsx)("div", {
              className: "text-xs text-app-gray-400",
              children: t2("modal.popup.phone-body")
            })]
          })]
        })]
      })]
    }), (0, import_jsx_runtime.jsxs)("form", {
      className: "w3ajs-passwordless-form",
      onSubmit: (e2) => handleFormSubmit(e2),
      children: [(0, import_jsx_runtime.jsx)("input", {
        className: "w-full mb-4 w3a-text-field",
        name: "passwordless-input",
        required: true,
        placeholder: `${t2("modal.social.sms-placeholder-text")} ${placeholder}`,
        onFocus: (e2) => {
          e2.target.placeholder = "";
        },
        onBlur: (e2) => {
          e2.target.placeholder = `${t2("modal.social.sms-placeholder-text")} ${placeholder}`;
        },
        onChange: (e2) => handleInputChange(e2)
      }), isValidInput === false && (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-sms-field--error",
        children: t2(invalidInputErrorMessage)
      }), (0, import_jsx_runtime.jsx)(Button$1, {
        variant: isPrimaryBtn ? "primary" : "tertiary",
        disabled: fieldValue === "",
        className: "w-full",
        type: "submit",
        children: t2("modal.social.passwordless-cta")
      })]
    })]
  });
}
function getProviderIcon(method, isDark, isPrimaryBtn) {
  const imageId = method === LOGIN_PROVIDER2.TWITTER ? `login-twitter-x${isDark ? "-light" : "-dark"}` : `login-${method}${isDark ? "-light" : "-dark"}`;
  const hoverId = method === LOGIN_PROVIDER2.APPLE || method === LOGIN_PROVIDER2.GITHUB || method === LOGIN_PROVIDER2.TWITTER ? imageId : `login-${method}-active`;
  if (isPrimaryBtn) {
    return (0, import_jsx_runtime.jsx)(Image$1, {
      width: "20",
      imageId: hoverId,
      hoverImageId: hoverId,
      isButton: true
    });
  }
  return (0, import_jsx_runtime.jsx)(Image$1, {
    width: "20",
    imageId,
    hoverImageId: hoverId,
    isButton: true
  });
}
function SocialLogins(props) {
  const [canShowMore, setCanShowMore] = (0, import_react9.useState)(false);
  const [isExpanded, setIsExpanded] = (0, import_react9.useState)(false);
  const {
    socialLoginsConfig = {
      loginMethods: {},
      loginMethodsOrder: [],
      adapter: "",
      uiConfig: {}
    },
    handleSocialLoginClick
  } = props;
  const {
    isDark
  } = (0, import_react9.useContext)(ThemedContext);
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const expandClickHandler = () => {
    setIsExpanded(!isExpanded);
  };
  (0, import_react9.useEffect)(() => {
    const maxOptions = Object.keys(socialLoginsConfig.loginMethods).filter((loginMethodKey) => {
      return socialLoginsConfig.loginMethods[loginMethodKey].showOnModal;
    });
    setCanShowMore(maxOptions.length > 4);
  }, [socialLoginsConfig.loginMethods]);
  const adapterListClass = (0, import_classnames.default)("w3a-adapter-list", "w3ajs-socials-adapters", !isExpanded ? " w3a-adapter-list--shrink" : "");
  const adapterButtonClass = (0, import_classnames.default)("w3a-button-expand", "w3ajs-button-expand", isExpanded ? "w3a-button--rotate" : "");
  const adapterExpandText = isExpanded ? t2("modal.social.view-less") : t2("modal.social.view-more");
  const loginMethodsCount = Object.keys(socialLoginsConfig.loginMethods).length + 1;
  const restrictedLoginMethods = [LOGIN_PROVIDER2.WEBAUTHN, LOGIN_PROVIDER2.JWT, LOGIN_PROVIDER2.SMS_PASSWORDLESS, LOGIN_PROVIDER2.EMAIL_PASSWORDLESS];
  return (0, import_jsx_runtime.jsxs)("div", {
    className: "w3ajs-social-logins w3a-group",
    children: [(0, import_jsx_runtime.jsx)("ul", {
      className: adapterListClass,
      children: Object.keys(socialLoginsConfig.loginMethods).map((method) => {
        var _socialLoginsConfig$u, _socialLoginsConfig$u2;
        const name = capitalizeFirstLetter(socialLoginsConfig.loginMethods[method].name || method);
        const orderIndex = socialLoginsConfig.loginMethodsOrder.indexOf(method) + 1;
        const order = orderIndex || Object.keys(socialLoginsConfig.loginMethods).length + 1;
        const isMainOption = socialLoginsConfig.loginMethods[method].mainOption;
        const isPrimaryBtn = (socialLoginsConfig === null || socialLoginsConfig === void 0 || (_socialLoginsConfig$u = socialLoginsConfig.uiConfig) === null || _socialLoginsConfig$u === void 0 ? void 0 : _socialLoginsConfig$u.primaryButton) === "socialLogin" && order === 1;
        const providerIcon = getProviderIcon(method, isDark, isPrimaryBtn);
        if (socialLoginsConfig.loginMethods[method].showOnModal === false || restrictedLoginMethods.includes(method)) {
          return null;
        }
        const loginMethodSpan = (0, import_classnames.default)("w3a-adapter-item", (socialLoginsConfig === null || socialLoginsConfig === void 0 || (_socialLoginsConfig$u2 = socialLoginsConfig.uiConfig) === null || _socialLoginsConfig$u2 === void 0 ? void 0 : _socialLoginsConfig$u2.loginGridCol) === 2 ? "col-span-3" : "col-span-2");
        if (isMainOption || order === 1) {
          return (0, import_jsx_runtime.jsx)("li", {
            className: "col-span-6 w3a-adapter-item",
            style: {
              order
            },
            children: (0, import_jsx_runtime.jsxs)(Button$1, {
              variant: "secondary",
              onClick: () => handleSocialLoginClick({
                adapter: socialLoginsConfig.adapter,
                loginParams: {
                  loginProvider: method,
                  name,
                  login_hint: ""
                }
              }),
              className: "w-full",
              title: name,
              children: [providerIcon, (0, import_jsx_runtime.jsx)("p", {
                className: "ml-2",
                children: t2("modal.social.continueCustom", {
                  adapter: name
                })
              })]
            })
          }, method);
        }
        return (0, import_jsx_runtime.jsx)("li", {
          className: loginMethodSpan,
          style: {
            order: order + loginMethodsCount
          },
          children: (0, import_jsx_runtime.jsx)(Button$1, {
            variant: "secondary",
            onClick: () => handleSocialLoginClick({
              adapter: socialLoginsConfig.adapter,
              loginParams: {
                loginProvider: method,
                name,
                login_hint: ""
              }
            }),
            className: "w-full",
            title: name,
            children: providerIcon
          })
        }, method);
      })
    }), (0, import_jsx_runtime.jsx)("div", {
      className: "w3a-social__policy",
      children: t2("modal.social.policy")
    }), canShowMore && (0, import_jsx_runtime.jsx)("div", {
      className: "text-right",
      children: (0, import_jsx_runtime.jsx)("button", {
        type: "button",
        className: adapterButtonClass,
        onClick: expandClickHandler,
        children: (0, import_jsx_runtime.jsx)("span", {
          className: "w3ajs-button-expand-text",
          children: adapterExpandText
        })
      })
    })]
  });
}
loglevel.enableAll();
function Modal(props) {
  var _modalState$socialLog, _modalState$socialLog2, _modalState$socialLog5, _modalState$socialLog7, _modalState$socialLog9, _modalState$socialLog10;
  const [modalTransitionClasses, setModalTransitionClasses] = (0, import_react9.useState)(["w3a-modal__inner"]);
  const [modalState, setModalState] = (0, import_react9.useState)({
    externalWalletsVisibility: false,
    status: MODAL_STATUS.INITIALIZED,
    hasExternalWallets: false,
    externalWalletsInitialized: false,
    modalVisibility: false,
    modalVisibilityDelayed: false,
    postLoadingMessage: "",
    walletConnectUri: "",
    socialLoginsConfig: {
      loginMethods: {},
      loginMethodsOrder: [],
      adapter: "",
      uiConfig: {}
    },
    externalWalletsConfig: {},
    detailedLoaderAdapter: "",
    detailedLoaderAdapterName: "",
    showExternalWalletsOnly: false,
    wcAdapters: []
  });
  const [t2] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    stateListener,
    appLogo,
    appName,
    handleSocialLoginClick,
    handleExternalWalletClick,
    handleShowExternalWallets,
    closeModal
  } = props;
  (0, import_react9.useEffect)(() => {
    stateListener.emit("MOUNTED");
    stateListener.on("STATE_UPDATED", (newModalState) => {
      loglevel.debug("state updated", newModalState);
      setModalState((prevState) => {
        const mergedState = (0, import_lodash3.default)((0, import_lodash4.default)(prevState, newModalState));
        return mergedState;
      });
    });
  }, [stateListener]);
  (0, import_react9.useEffect)(() => {
    let timeOutId;
    if (modalState.modalVisibility) {
      setModalState((prevState) => {
        return _objectSpread2(_objectSpread2({}, prevState), {}, {
          modalVisibilityDelayed: modalState.modalVisibility
        });
      });
      timeOutId = window.setTimeout(() => {
        setModalTransitionClasses(["w3a-modal__inner", modalState.modalVisibility ? "w3a-modal__inner--active" : ""]);
      }, 100);
    } else {
      setModalTransitionClasses(["w3a-modal__inner", modalState.modalVisibility ? "w3a-modal__inner--active" : ""]);
      timeOutId = window.setTimeout(() => {
        setModalState((prevState) => {
          return _objectSpread2(_objectSpread2({}, prevState), {}, {
            modalVisibilityDelayed: modalState.modalVisibility
          });
        });
      }, 250);
    }
    return () => {
      clearTimeout(timeOutId);
    };
  }, [modalState.modalVisibility]);
  const onCloseLoader = (0, import_react9.useCallback)(() => {
    if (modalState.status === MODAL_STATUS.CONNECTED) {
      closeModal();
    }
    if (modalState.status === MODAL_STATUS.ERRORED) {
      setModalState((prevState) => {
        return _objectSpread2(_objectSpread2({}, prevState), {}, {
          modalVisibility: true,
          status: MODAL_STATUS.INITIALIZED
        });
      });
    }
  }, [closeModal, modalState.status]);
  const preHandleExternalWalletClick = (0, import_react9.useCallback)((params) => {
    const {
      adapter
    } = params;
    setModalState((prevState) => {
      return _objectSpread2(_objectSpread2({}, prevState), {}, {
        detailedLoaderAdapter: adapter,
        detailedLoaderAdapterName: ADAPTER_NAMES[adapter]
      });
    });
    handleExternalWalletClick(params);
  }, [handleExternalWalletClick]);
  const preHandleSocialWalletClick = (params) => {
    const {
      loginParams
    } = params;
    setModalState((prevState) => {
      return _objectSpread2(_objectSpread2({}, prevState), {}, {
        detailedLoaderAdapter: loginParams.loginProvider,
        detailedLoaderAdapterName: loginParams.name
      });
    });
    handleSocialLoginClick(params);
  };
  const isEmailPrimary = ((_modalState$socialLog = modalState.socialLoginsConfig) === null || _modalState$socialLog === void 0 || (_modalState$socialLog = _modalState$socialLog.uiConfig) === null || _modalState$socialLog === void 0 ? void 0 : _modalState$socialLog.primaryButton) === "emailLogin";
  const isExternalPrimary = ((_modalState$socialLog2 = modalState.socialLoginsConfig) === null || _modalState$socialLog2 === void 0 || (_modalState$socialLog2 = _modalState$socialLog2.uiConfig) === null || _modalState$socialLog2 === void 0 ? void 0 : _modalState$socialLog2.primaryButton) === "externalLogin";
  const externalWalletButton = (0, import_jsx_runtime.jsx)("div", {
    className: "w3ajs-external-wallet w3a-group",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: "w3a-external-toggle w3ajs-external-toggle",
      children: [(0, import_jsx_runtime.jsx)("div", {
        className: "w3a-group__title",
        children: t2("modal.external.title")
      }), (0, import_jsx_runtime.jsx)(Button$1, {
        variant: isExternalPrimary ? "primary" : "tertiary",
        type: "button",
        className: "w-full w3ajs-external-toggle__button",
        onClick: () => {
          handleShowExternalWallets(modalState.externalWalletsInitialized);
          setModalState((prevState) => {
            return _objectSpread2(_objectSpread2({}, prevState), {}, {
              externalWalletsVisibility: true
            });
          });
        },
        children: t2("modal.external.connect")
      })]
    })
  });
  const areSocialLoginsVisible = (0, import_react9.useMemo)(() => {
    var _modalState$socialLog3, _modalState$socialLog4;
    if (modalState.showExternalWalletsOnly) return false;
    if (Object.keys(((_modalState$socialLog3 = modalState.socialLoginsConfig) === null || _modalState$socialLog3 === void 0 ? void 0 : _modalState$socialLog3.loginMethods) || {}).length === 0) return false;
    const isAnySocialLoginVisible = Object.entries(((_modalState$socialLog4 = modalState.socialLoginsConfig) === null || _modalState$socialLog4 === void 0 ? void 0 : _modalState$socialLog4.loginMethods) || {}).some(([k, v]) => k !== LOGIN_PROVIDER2.EMAIL_PASSWORDLESS && v.showOnModal !== false);
    if (isAnySocialLoginVisible) return true;
    return false;
  }, [modalState.showExternalWalletsOnly, (_modalState$socialLog5 = modalState.socialLoginsConfig) === null || _modalState$socialLog5 === void 0 ? void 0 : _modalState$socialLog5.loginMethods]);
  loglevel.info("modal state", modalState, areSocialLoginsVisible);
  const isEmailPasswordlessLoginVisible = (0, import_react9.useMemo)(() => {
    var _modalState$socialLog6;
    return (_modalState$socialLog6 = modalState.socialLoginsConfig) === null || _modalState$socialLog6 === void 0 || (_modalState$socialLog6 = _modalState$socialLog6.loginMethods[LOGIN_PROVIDER2.EMAIL_PASSWORDLESS]) === null || _modalState$socialLog6 === void 0 ? void 0 : _modalState$socialLog6.showOnModal;
  }, [(_modalState$socialLog7 = modalState.socialLoginsConfig) === null || _modalState$socialLog7 === void 0 ? void 0 : _modalState$socialLog7.loginMethods]);
  const isSmsPasswordlessLoginVisible = (0, import_react9.useMemo)(() => {
    var _modalState$socialLog8;
    return (_modalState$socialLog8 = modalState.socialLoginsConfig) === null || _modalState$socialLog8 === void 0 || (_modalState$socialLog8 = _modalState$socialLog8.loginMethods[LOGIN_PROVIDER2.SMS_PASSWORDLESS]) === null || _modalState$socialLog8 === void 0 ? void 0 : _modalState$socialLog8.showOnModal;
  }, [(_modalState$socialLog9 = modalState.socialLoginsConfig) === null || _modalState$socialLog9 === void 0 ? void 0 : _modalState$socialLog9.loginMethods]);
  return modalState.modalVisibilityDelayed && (0, import_jsx_runtime.jsx)("div", {
    id: "w3a-modal",
    className: "w3a-modal",
    children: (0, import_jsx_runtime.jsxs)("div", {
      className: modalTransitionClasses.join(" "),
      children: [(0, import_jsx_runtime.jsx)(memoizedHeader, {
        onClose: closeModal,
        appLogo,
        appName
      }), modalState.status !== MODAL_STATUS.INITIALIZED ? (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-modal__content w3ajs-content",
        children: (0, import_jsx_runtime.jsx)(DetailedLoader, {
          onClose: onCloseLoader,
          appLogo,
          modalStatus: modalState.status,
          message: t2(modalState.postLoadingMessage),
          adapter: modalState.detailedLoaderAdapter,
          adapterName: modalState.detailedLoaderAdapterName
        })
      }) : (0, import_jsx_runtime.jsx)("div", {
        className: "w3a-modal__content w3ajs-content",
        children: (areSocialLoginsVisible || isEmailPasswordlessLoginVisible || isSmsPasswordlessLoginVisible) && !modalState.externalWalletsVisibility ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [areSocialLoginsVisible ? (0, import_jsx_runtime.jsx)(SocialLogins, {
            handleSocialLoginClick: (params) => preHandleSocialWalletClick(params),
            socialLoginsConfig: modalState.socialLoginsConfig
          }) : null, (isEmailPasswordlessLoginVisible || isSmsPasswordlessLoginVisible) && (0, import_jsx_runtime.jsx)(SocialLoginPasswordless, {
            isEmailVisible: isEmailPasswordlessLoginVisible,
            isSmsVisible: isSmsPasswordlessLoginVisible,
            adapter: (_modalState$socialLog10 = modalState.socialLoginsConfig) === null || _modalState$socialLog10 === void 0 ? void 0 : _modalState$socialLog10.adapter,
            handleSocialLoginClick: (params) => preHandleSocialWalletClick(params),
            isPrimaryBtn: isEmailPrimary
          }), modalState.hasExternalWallets && externalWalletButton]
        }) : (0, import_jsx_runtime.jsx)(ExternalWallet, {
          modalStatus: modalState.status,
          showBackButton: areSocialLoginsVisible || isEmailPasswordlessLoginVisible || isSmsPasswordlessLoginVisible,
          handleExternalWalletClick: preHandleExternalWalletClick,
          walletConnectUri: modalState.walletConnectUri,
          wcAdapters: modalState.wcAdapters,
          config: modalState.externalWalletsConfig,
          hideExternalWallets: () => setModalState((prevState) => {
            return _objectSpread2(_objectSpread2({}, prevState), {}, {
              externalWalletsVisibility: false
            });
          })
        })
      }), (0, import_jsx_runtime.jsx)(Footer, {})]
    })
  });
}
function createWrapper(parentZIndex) {
  const existingWrapper = document.getElementById("w3a-parent-container");
  if (existingWrapper) existingWrapper.remove();
  const parent = document.createElement("section");
  parent.classList.add("w3a-parent-container");
  parent.setAttribute("id", "w3a-parent-container");
  parent.style.zIndex = parentZIndex;
  parent.style.position = "relative";
  const wrapper = document.createElement("section");
  wrapper.setAttribute("id", "w3a-container");
  parent.appendChild(wrapper);
  document.body.appendChild(parent);
  return wrapper;
}
var LoginModal = class extends SafeEventEmitter {
  constructor(_uiConfig) {
    super();
    _defineProperty(this, "uiConfig", void 0);
    _defineProperty(this, "stateEmitter", void 0);
    _defineProperty(this, "initModal", async () => {
      const darkState = {
        isDark: this.isDark
      };
      const useLang = this.uiConfig.defaultLanguage || LANGUAGES.en;
      if (useLang === LANGUAGES.de) {
        import("./german-BhRxrMye-CHPGMFXR.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.ja) {
        import("./japanese-Bvuydikq-MJSLKQFI.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.ko) {
        import("./korean-M7bd51ut-ND7AIJGC.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.zh) {
        import("./mandarin-CYSJAgXi-FXMTMIGH.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.es) {
        import("./spanish-Bji0Db1n-KCNS3KKI.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.fr) {
        import("./french-C9hScp8b-4B3L7HLF.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.pt) {
        import("./portuguese-CZTBs7Nm-O4NSZR42.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.nl) {
        import("./dutch-DA4bfNTp-RJJWTVE3.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      } else if (useLang === LANGUAGES.tr) {
        import("./turkish-BD7WDb-q-ACTWG4UR.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          loglevel.error(error);
        });
      }
      return new Promise((resolve) => {
        var _this$uiConfig;
        this.stateEmitter.once("MOUNTED", () => {
          loglevel.info("rendered");
          this.setState({
            status: MODAL_STATUS.INITIALIZED
          });
          return resolve();
        });
        const container = createWrapper(this.uiConfig.modalZIndex);
        if (darkState.isDark) {
          container.classList.add("dark");
        } else {
          container.classList.remove("dark");
        }
        const root = (0, import_client.createRoot)(container);
        root.render((0, import_jsx_runtime.jsx)(ThemedContext.Provider, {
          value: darkState,
          children: (0, import_jsx_runtime.jsx)(Modal, {
            closeModal: this.closeModal,
            stateListener: this.stateEmitter,
            handleShowExternalWallets: this.handleShowExternalWallets,
            handleExternalWalletClick: this.handleExternalWalletClick,
            handleSocialLoginClick: this.handleSocialLoginClick,
            appLogo: darkState.isDark ? this.uiConfig.logoDark : this.uiConfig.logoLight,
            appName: this.uiConfig.appName
          })
        }));
        if ((_this$uiConfig = this.uiConfig) !== null && _this$uiConfig !== void 0 && _this$uiConfig.theme) {
          const rootElement = document.getElementById("w3a-parent-container");
          applyWhiteLabelTheme(rootElement, this.uiConfig.theme);
        }
      });
    });
    _defineProperty(this, "addSocialLogins", (adapter, loginMethods, loginMethodsOrder, uiConfig) => {
      this.setState({
        socialLoginsConfig: {
          adapter,
          loginMethods,
          loginMethodsOrder,
          uiConfig
        }
      });
      loglevel.info("addSocialLogins", adapter, loginMethods, loginMethodsOrder, uiConfig);
    });
    _defineProperty(this, "addWalletLogins", (externalWalletsConfig, options) => {
      this.setState({
        externalWalletsConfig,
        externalWalletsInitialized: true,
        showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly),
        externalWalletsVisibility: true
      });
    });
    _defineProperty(this, "open", () => {
      this.setState({
        modalVisibility: true
      });
      this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, true);
    });
    _defineProperty(this, "closeModal", () => {
      this.setState({
        modalVisibility: false,
        externalWalletsVisibility: false
      });
      this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, false);
    });
    _defineProperty(this, "initExternalWalletContainer", () => {
      this.setState({
        hasExternalWallets: true
      });
    });
    _defineProperty(this, "handleShowExternalWallets", (status) => {
      this.emit(LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, {
        externalWalletsInitialized: status
      });
    });
    _defineProperty(this, "handleExternalWalletClick", (params) => {
      loglevel.info("external wallet clicked", params);
      const {
        adapter
      } = params;
      this.emit(LOGIN_MODAL_EVENTS.LOGIN, {
        adapter
      });
    });
    _defineProperty(this, "handleSocialLoginClick", (params) => {
      loglevel.info("social login clicked", params);
      const {
        adapter,
        loginParams
      } = params;
      this.emit(LOGIN_MODAL_EVENTS.LOGIN, {
        adapter,
        loginParams: {
          loginProvider: loginParams.loginProvider,
          login_hint: loginParams.login_hint,
          name: loginParams.name
        }
      });
    });
    _defineProperty(this, "setState", (newState) => {
      this.stateEmitter.emit("STATE_UPDATED", newState);
    });
    _defineProperty(this, "updateWalletConnect", (walletConnectUri, wcAdapters) => {
      if (!walletConnectUri) return;
      this.setState({
        walletConnectUri,
        wcAdapters
      });
    });
    _defineProperty(this, "handleAdapterData", (adapterData) => {
      if (adapterData.adapterName === WALLET_ADAPTERS.WALLET_CONNECT_V2) {
        const walletConnectData = adapterData.data;
        this.updateWalletConnect(walletConnectData.uri, walletConnectData.extensionAdapters);
      }
    });
    _defineProperty(this, "subscribeCoreEvents", (listener) => {
      listener.on(ADAPTER_EVENTS.CONNECTING, (data) => {
        loglevel.info("connecting with adapter", data);
        if ((data === null || data === void 0 ? void 0 : data.adapter) !== WALLET_ADAPTERS.WALLET_CONNECT_V2) {
          this.setState({
            status: MODAL_STATUS.CONNECTING
          });
        }
      });
      listener.on(ADAPTER_EVENTS.CONNECTED, (data) => {
        loglevel.debug("connected with adapter", data);
        if (!data.reconnected) {
          this.setState({
            status: MODAL_STATUS.CONNECTED,
            modalVisibility: true,
            postLoadingMessage: "modal.post-loading.connected"
          });
        } else {
          this.setState({
            status: MODAL_STATUS.CONNECTED
          });
        }
      });
      listener.on(ADAPTER_EVENTS.ERRORED, (error) => {
        loglevel.error("error", error, error.message);
        if (error.code === 5e3) {
          if (this.uiConfig.displayErrorsOnModal) this.setState({
            modalVisibility: true,
            postLoadingMessage: error.message || "modal.post-loading.something-wrong",
            status: MODAL_STATUS.ERRORED
          });
          else this.setState({
            modalVisibility: false
          });
        } else {
          this.setState({
            modalVisibility: true,
            status: MODAL_STATUS.INITIALIZED
          });
        }
      });
      listener.on(ADAPTER_EVENTS.DISCONNECTED, () => {
        this.setState({
          status: MODAL_STATUS.INITIALIZED,
          externalWalletsVisibility: false
        });
      });
      listener.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, (adapterData) => {
        this.handleAdapterData(adapterData);
      });
    });
    this.uiConfig = _uiConfig;
    if (!_uiConfig.logoDark) this.uiConfig.logoDark = DEFAULT_LOGO_DARK;
    if (!_uiConfig.logoLight) this.uiConfig.logoLight = DEFAULT_LOGO_LIGHT;
    if (!_uiConfig.mode) this.uiConfig.mode = "light";
    if (!_uiConfig.modalZIndex) this.uiConfig.modalZIndex = "99998";
    if (typeof _uiConfig.displayErrorsOnModal === "undefined") this.uiConfig.displayErrorsOnModal = true;
    if (!_uiConfig.appName) this.uiConfig.appName = "Web3Auth";
    if (!_uiConfig.loginGridCol) this.uiConfig.loginGridCol = 3;
    if (!_uiConfig.primaryButton) this.uiConfig.primaryButton = "socialLogin";
    if (!_uiConfig.defaultLanguage) this.uiConfig.defaultLanguage = getUserLanguage(_uiConfig.defaultLanguage);
    this.stateEmitter = new SafeEventEmitter();
    this.subscribeCoreEvents(this.uiConfig.adapterListener);
  }
  get isDark() {
    return this.uiConfig.mode === "dark" || this.uiConfig.mode === "auto" && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
};

// node_modules/@web3auth/modal/dist/modal.esm.js
var import_lodash5 = __toESM(require_lodash3());
var import_lodash6 = __toESM(require_lodash());
var defaultSolanaDappModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.SOLANA,
  adapters: {
    [SOLANA_ADAPTERS.TORUS_SOLANA]: {
      label: "Torus Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [SOLANA_ADAPTERS.OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [SOLANA_ADAPTERS.PHANTOM]: {
      label: "Phantom",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
var defaultEvmDappModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.EIP155,
  adapters: {
    [EVM_ADAPTERS.TORUS_EVM]: {
      label: "Torus Wallet",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [EVM_ADAPTERS.METAMASK]: {
      label: "MetaMask",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [EVM_ADAPTERS.OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    },
    [EVM_ADAPTERS.WALLET_CONNECT_V2]: {
      label: "Wallet Connect",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
var defaultSolanaWalletModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.SOLANA,
  adapters: {
    [SOLANA_ADAPTERS.OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
var defaultEvmWalletModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.EIP155,
  adapters: {
    [EVM_ADAPTERS.OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
var defaultOtherModalConfig = {
  chainNamespace: CHAIN_NAMESPACES.OTHER,
  adapters: {
    [EVM_ADAPTERS.OPENLOGIN]: {
      label: "OpenLogin",
      showOnModal: true,
      showOnMobile: true,
      showOnDesktop: true
    }
  }
};
var Web3Auth = class extends Web3AuthNoModal {
  constructor(options) {
    super(options);
    _defineProperty(this, "loginModal", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "modalConfig", defaultOtherModalConfig);
    this.options = _objectSpread2({}, options);
    if (!this.options.uiConfig) this.options.uiConfig = {};
    if (!this.coreOptions.privateKeyProvider) throw WalletInitializationError.invalidParams("privateKeyProvider is required");
  }
  setModalConfig(modalConfig) {
    super.checkInitRequirements();
    this.modalConfig = modalConfig;
  }
  async initModal(params) {
    super.checkInitRequirements();
    let projectConfig;
    try {
      projectConfig = await fetchProjectConfig(this.options.clientId, this.options.web3AuthNetwork);
    } catch (e2) {
      loglevel.error("Failed to fetch project configurations", e2);
      throw WalletInitializationError.notReady("failed to fetch project configurations", e2);
    }
    const {
      whitelabel
    } = projectConfig;
    this.options.uiConfig = (0, import_lodash6.default)((0, import_lodash5.default)(whitelabel), this.options.uiConfig);
    if (!this.options.uiConfig.defaultLanguage) this.options.uiConfig.defaultLanguage = getUserLanguage(this.options.uiConfig.defaultLanguage);
    if (!this.options.uiConfig.mode) this.options.uiConfig.mode = "light";
    this.loginModal = new LoginModal(_objectSpread2(_objectSpread2({}, this.options.uiConfig), {}, {
      adapterListener: this
    }));
    this.subscribeToLoginModalEvents();
    const {
      sms_otp_enabled: smsOtpEnabled,
      whitelist
    } = projectConfig;
    if (smsOtpEnabled !== void 0) {
      var _params;
      const adapterConfig = {
        [WALLET_ADAPTERS.OPENLOGIN]: {
          label: WALLET_ADAPTERS.OPENLOGIN,
          loginMethods: {
            [LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
              name: LOGIN_PROVIDER.SMS_PASSWORDLESS,
              showOnModal: smsOtpEnabled,
              showOnDesktop: smsOtpEnabled,
              showOnMobile: smsOtpEnabled
            }
          }
        }
      };
      if (!((_params = params) !== null && _params !== void 0 && _params.modalConfig)) params = {
        modalConfig: {}
      };
      params.modalConfig = (0, import_lodash6.default)((0, import_lodash5.default)(params.modalConfig), adapterConfig);
    }
    await this.loginModal.initModal();
    const providedChainConfig = this.options.chainConfig;
    const allAdapters = [.../* @__PURE__ */ new Set([...Object.keys(this.modalConfig.adapters || {}), ...Object.keys(this.walletAdapters)])];
    const adapterConfigurationPromises = allAdapters.map(async (adapterName) => {
      var _this$modalConfig$ada, _params2, _this$modalConfig$ada2, _this$modalConfig$ada3;
      let adapterConfig = ((_this$modalConfig$ada = this.modalConfig.adapters) === null || _this$modalConfig$ada === void 0 ? void 0 : _this$modalConfig$ada[adapterName]) || {
        label: adapterName.split("-").map(capitalizeFirstLetter).join(" "),
        showOnModal: true,
        showOnMobile: true,
        showOnDesktop: true
      };
      if ((_params2 = params) !== null && _params2 !== void 0 && (_params2 = _params2.modalConfig) !== null && _params2 !== void 0 && _params2[adapterName]) {
        adapterConfig = _objectSpread2(_objectSpread2({}, adapterConfig), params.modalConfig[adapterName]);
      }
      this.modalConfig.adapters[adapterName] = adapterConfig;
      const adapter = this.walletAdapters[adapterName];
      loglevel.debug("adapter config", adapterName, (_this$modalConfig$ada2 = this.modalConfig.adapters) === null || _this$modalConfig$ada2 === void 0 ? void 0 : _this$modalConfig$ada2[adapterName].showOnModal, adapter);
      if (!adapter && (_this$modalConfig$ada3 = this.modalConfig.adapters) !== null && _this$modalConfig$ada3 !== void 0 && _this$modalConfig$ada3[adapterName].showOnModal) {
        if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
          var _this$coreOptions$cha;
          const defaultOptions2 = getOpenloginDefaultOptions();
          const {
            clientId,
            useCoreKitKey,
            chainConfig,
            web3AuthNetwork,
            sessionTime,
            privateKeyProvider
          } = this.coreOptions;
          const finalChainConfig = _objectSpread2(_objectSpread2({}, getChainConfig(providedChainConfig.chainNamespace, (_this$coreOptions$cha = this.coreOptions.chainConfig) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.chainId)), chainConfig);
          if (!privateKeyProvider) {
            throw WalletInitializationError.invalidParams("privateKeyProvider is required");
          }
          const finalOpenloginAdapterSettings = _objectSpread2(_objectSpread2({}, defaultOptions2.adapterSettings), {}, {
            clientId,
            network: web3AuthNetwork,
            whiteLabel: this.options.uiConfig
          });
          if (smsOtpEnabled !== void 0) {
            finalOpenloginAdapterSettings.loginConfig = {
              [LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
                showOnModal: smsOtpEnabled,
                showOnDesktop: smsOtpEnabled,
                showOnMobile: smsOtpEnabled,
                showOnSocialBackupFactor: smsOtpEnabled
              }
            };
          }
          if (whitelist) {
            finalOpenloginAdapterSettings.originData = whitelist.signed_urls;
          }
          if (this.options.uiConfig.uxMode) {
            finalOpenloginAdapterSettings.uxMode = this.options.uiConfig.uxMode;
          }
          const openloginAdapter = new OpenloginAdapter(_objectSpread2(_objectSpread2({}, defaultOptions2), {}, {
            clientId,
            useCoreKitKey,
            chainConfig: _objectSpread2({}, finalChainConfig),
            adapterSettings: finalOpenloginAdapterSettings,
            sessionTime,
            web3AuthNetwork,
            privateKeyProvider
          }));
          this.walletAdapters[adapterName] = openloginAdapter;
          return adapterName;
        }
        throw WalletInitializationError.invalidParams(`Adapter ${adapterName} is not configured`);
      } else if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.IN_APP || (adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL || adapterName === this.cachedAdapter) {
        var _this$modalConfig$ada4;
        if (!((_this$modalConfig$ada4 = this.modalConfig.adapters) !== null && _this$modalConfig$ada4 !== void 0 && _this$modalConfig$ada4[adapterName].showOnModal)) return;
        this.walletAdapters[adapterName].setAdapterSettings({
          clientId: this.options.clientId,
          sessionTime: this.options.sessionTime,
          web3AuthNetwork: this.options.web3AuthNetwork,
          useCoreKitKey: this.coreOptions.useCoreKitKey
        });
        if (!adapter.chainConfigProxy) {
          var _this$coreOptions$cha2;
          const chainConfig = _objectSpread2(_objectSpread2({}, getChainConfig(providedChainConfig.chainNamespace, (_this$coreOptions$cha2 = this.coreOptions.chainConfig) === null || _this$coreOptions$cha2 === void 0 ? void 0 : _this$coreOptions$cha2.chainId)), this.coreOptions.chainConfig);
          this.walletAdapters[adapterName].setAdapterSettings({
            chainConfig
          });
        }
        if (adapterName === WALLET_ADAPTERS.OPENLOGIN) {
          var _this$options$uiConfi;
          const openloginAdapter = this.walletAdapters[adapterName];
          if (this.coreOptions.privateKeyProvider) {
            if (openloginAdapter.currentChainNamespace !== this.coreOptions.privateKeyProvider.currentChainConfig.chainNamespace) {
              throw WalletInitializationError.incompatibleChainNameSpace("private key provider is not compatible with provided chainNamespace for openlogin adapter");
            }
            openloginAdapter.setAdapterSettings({
              privateKeyProvider: this.coreOptions.privateKeyProvider
            });
          }
          if (smsOtpEnabled !== void 0) {
            openloginAdapter.setAdapterSettings({
              loginConfig: {
                [LOGIN_PROVIDER.SMS_PASSWORDLESS]: {
                  showOnModal: smsOtpEnabled,
                  showOnDesktop: smsOtpEnabled,
                  showOnMobile: smsOtpEnabled,
                  showOnSocialBackupFactor: smsOtpEnabled
                }
              }
            });
          }
          if (whitelist) {
            openloginAdapter.setAdapterSettings({
              originData: whitelist.signed_urls
            });
          }
          if ((_this$options$uiConfi = this.options.uiConfig) !== null && _this$options$uiConfi !== void 0 && _this$options$uiConfi.uxMode) {
            openloginAdapter.setAdapterSettings({
              uxMode: this.options.uiConfig.uxMode
            });
          }
          openloginAdapter.setAdapterSettings({
            whiteLabel: this.options.uiConfig
          });
          if (!openloginAdapter.privateKeyProvider) {
            throw WalletInitializationError.invalidParams("privateKeyProvider is required for openlogin adapter");
          }
        } else if (adapterName === WALLET_ADAPTERS.WALLET_CONNECT_V2) {
          const walletConnectAdapter = this.walletAdapters[adapterName];
          const {
            wallet_connect_enabled: walletConnectEnabled,
            wallet_connect_project_id: walletConnectProjectId
          } = projectConfig;
          if (walletConnectEnabled === false) {
            var _this$modalConfig$ada5, _this$modalConfig$ada6, _this$modalConfig$ada7;
            this.modalConfig.adapters = _objectSpread2(_objectSpread2({}, (_this$modalConfig$ada5 = this.modalConfig.adapters) !== null && _this$modalConfig$ada5 !== void 0 ? _this$modalConfig$ada5 : {}), {}, {
              [WALLET_ADAPTERS.WALLET_CONNECT_V2]: _objectSpread2(_objectSpread2({}, (_this$modalConfig$ada6 = (_this$modalConfig$ada7 = this.modalConfig.adapters) === null || _this$modalConfig$ada7 === void 0 ? void 0 : _this$modalConfig$ada7[WALLET_ADAPTERS.WALLET_CONNECT_V2]) !== null && _this$modalConfig$ada6 !== void 0 ? _this$modalConfig$ada6 : {}), {}, {
                showOnModal: false
              })
            });
            this.modalConfig.adapters[WALLET_ADAPTERS.WALLET_CONNECT_V2].showOnModal = false;
          } else {
            var _walletConnectAdapter;
            if (!(walletConnectAdapter !== null && walletConnectAdapter !== void 0 && (_walletConnectAdapter = walletConnectAdapter.adapterOptions) !== null && _walletConnectAdapter !== void 0 && (_walletConnectAdapter = _walletConnectAdapter.adapterSettings) !== null && _walletConnectAdapter !== void 0 && (_walletConnectAdapter = _walletConnectAdapter.walletConnectInitOptions) !== null && _walletConnectAdapter !== void 0 && _walletConnectAdapter.projectId) && !walletConnectProjectId) throw WalletInitializationError.invalidParams("Invalid wallet connect project id. Please configure it on the dashboard");
            if (walletConnectProjectId) {
              walletConnectAdapter.setAdapterSettings({
                adapterSettings: {
                  walletConnectInitOptions: {
                    projectId: walletConnectProjectId
                  }
                }
              });
            }
          }
        }
        return adapterName;
      }
    });
    const adapterNames = await Promise.all(adapterConfigurationPromises);
    const hasInAppWallets = Object.values(this.walletAdapters).some((adapter) => {
      var _this$modalConfig$ada8, _this$modalConfig$ada9, _adapter$name;
      if (adapter.type !== ADAPTER_CATEGORY.IN_APP) return false;
      if (((_this$modalConfig$ada8 = this.modalConfig.adapters) === null || _this$modalConfig$ada8 === void 0 || (_this$modalConfig$ada8 = _this$modalConfig$ada8[adapter.name]) === null || _this$modalConfig$ada8 === void 0 ? void 0 : _this$modalConfig$ada8.showOnModal) !== true) return false;
      if (!((_this$modalConfig$ada9 = this.modalConfig.adapters) !== null && _this$modalConfig$ada9 !== void 0 && (_this$modalConfig$ada9 = _this$modalConfig$ada9[adapter.name]) !== null && _this$modalConfig$ada9 !== void 0 && _this$modalConfig$ada9.loginMethods)) return true;
      const mergedLoginMethods = getAdapterSocialLogins(adapter.name, (_adapter$name = this.modalConfig.adapters[adapter.name]) === null || _adapter$name === void 0 ? void 0 : _adapter$name.loginMethods);
      if (Object.values(mergedLoginMethods).some((method) => method.showOnModal)) return true;
      return false;
    });
    loglevel.debug(hasInAppWallets, this.walletAdapters, adapterNames, "hasInAppWallets");
    const initPromises = adapterNames.map(async (adapterName) => {
      if (!adapterName) return;
      try {
        const adapter = this.walletAdapters[adapterName];
        if (this.cachedAdapter !== adapterName && adapter.type === ADAPTER_CATEGORY.EXTERNAL) {
          return;
        }
        this.subscribeToAdapterEvents(adapter);
        if (adapter.status === ADAPTER_STATUS.NOT_READY) await adapter.init({
          autoConnect: this.cachedAdapter === adapterName
        });
        if (adapter.type === ADAPTER_CATEGORY.IN_APP) {
          this.initializeInAppWallet(adapterName);
        }
      } catch (error) {
        loglevel.error(error, "error while initializing adapter ", adapterName);
      }
    });
    this.commonJRPCProvider = await CommonJRPCProvider.getProviderInstance({
      chainConfig: this.coreOptions.chainConfig
    });
    await Promise.all(initPromises);
    if (this.status === ADAPTER_STATUS.NOT_READY) {
      this.status = ADAPTER_STATUS.READY;
      this.emit(ADAPTER_EVENTS.READY);
    }
    const hasExternalWallets = allAdapters.some((adapterName) => {
      var _this$walletAdapters$, _this$modalConfig$ada10;
      return ((_this$walletAdapters$ = this.walletAdapters[adapterName]) === null || _this$walletAdapters$ === void 0 ? void 0 : _this$walletAdapters$.type) === ADAPTER_CATEGORY.EXTERNAL && ((_this$modalConfig$ada10 = this.modalConfig.adapters) === null || _this$modalConfig$ada10 === void 0 ? void 0 : _this$modalConfig$ada10[adapterName].showOnModal);
    });
    if (hasExternalWallets) {
      this.loginModal.initExternalWalletContainer();
    }
    if (!hasInAppWallets && hasExternalWallets) {
      await this.initExternalWalletAdapters(false, {
        showExternalWalletsOnly: true
      });
    }
  }
  async connect() {
    if (!this.loginModal) throw WalletInitializationError.notReady("Login modal is not initialized");
    if (this.connectedAdapterName && this.status === ADAPTER_STATUS.CONNECTED && this.provider) return this.provider;
    this.loginModal.open();
    return new Promise((resolve, reject) => {
      this.once(ADAPTER_EVENTS.CONNECTED, () => {
        return resolve(this.provider);
      });
      this.once(ADAPTER_EVENTS.ERRORED, (err) => {
        return reject(err);
      });
      this.once(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, (visibility) => {
        if (!visibility && this.status !== ADAPTER_STATUS.CONNECTED) {
          return reject(new Error("User closed the modal"));
        }
      });
    });
  }
  async initExternalWalletAdapters(externalWalletsInitialized, options) {
    if (externalWalletsInitialized) return;
    const adaptersConfig = {};
    Object.keys(this.walletAdapters).forEach(async (adapterName) => {
      const adapter = this.walletAdapters[adapterName];
      if ((adapter === null || adapter === void 0 ? void 0 : adapter.type) === ADAPTER_CATEGORY.EXTERNAL) {
        loglevel.debug("init external wallet", this.cachedAdapter, adapterName);
        this.subscribeToAdapterEvents(adapter);
        if (this.cachedAdapter === adapterName) {
          return;
        }
        if (adapter.status === ADAPTER_STATUS.NOT_READY) {
          await adapter.init({
            autoConnect: this.cachedAdapter === adapterName
          }).then(() => {
            adaptersConfig[adapterName] = this.modalConfig.adapters[adapterName];
            this.loginModal.addWalletLogins(adaptersConfig, {
              showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
            });
            return void 0;
          }).catch((error) => loglevel.error(error, "error while initializing adapter", adapterName));
        } else if (adapter.status === ADAPTER_STATUS.READY) {
          adaptersConfig[adapterName] = this.modalConfig.adapters[adapterName];
          this.loginModal.addWalletLogins(adaptersConfig, {
            showExternalWalletsOnly: !!(options !== null && options !== void 0 && options.showExternalWalletsOnly)
          });
        }
      }
    });
  }
  initializeInAppWallet(adapterName) {
    loglevel.info("adapterInitResults", adapterName);
    if (this.walletAdapters[adapterName].type === ADAPTER_CATEGORY.IN_APP) {
      var _adapterName, _this$options$uiConfi2, _this$options$uiConfi3, _this$options$uiConfi4;
      this.loginModal.addSocialLogins(adapterName, getAdapterSocialLogins(adapterName, (_adapterName = this.modalConfig.adapters[adapterName]) === null || _adapterName === void 0 ? void 0 : _adapterName.loginMethods), ((_this$options$uiConfi2 = this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.loginMethodsOrder) || OPENLOGIN_PROVIDERS, _objectSpread2(_objectSpread2({}, this.options.uiConfig), {}, {
        loginGridCol: ((_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.loginGridCol) || 3,
        primaryButton: ((_this$options$uiConfi4 = this.options.uiConfig) === null || _this$options$uiConfi4 === void 0 ? void 0 : _this$options$uiConfi4.primaryButton) || "socialLogin"
      }));
    }
  }
  subscribeToLoginModalEvents() {
    this.loginModal.on(LOGIN_MODAL_EVENTS.LOGIN, async (params) => {
      try {
        await this.connectTo(params.adapter, params.loginParams);
      } catch (error) {
        loglevel.error(`Error while connecting to adapter: ${params.adapter}`, error);
      }
    });
    this.loginModal.on(LOGIN_MODAL_EVENTS.INIT_EXTERNAL_WALLETS, async (params) => {
      await this.initExternalWalletAdapters(params.externalWalletsInitialized);
    });
    this.loginModal.on(LOGIN_MODAL_EVENTS.DISCONNECT, async () => {
      try {
        await this.logout();
      } catch (error) {
        loglevel.error(`Error while disconnecting`, error);
      }
    });
    this.loginModal.on(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, async (visibility) => {
      loglevel.debug("is login modal visible", visibility);
      this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility);
      const adapter = this.walletAdapters[WALLET_ADAPTERS.WALLET_CONNECT_V2];
      if (adapter) {
        const walletConnectStatus = adapter === null || adapter === void 0 ? void 0 : adapter.status;
        loglevel.debug("trying refreshing wc session", visibility, walletConnectStatus);
        if (visibility && (walletConnectStatus === ADAPTER_STATUS.READY || walletConnectStatus === ADAPTER_STATUS.CONNECTING)) {
          loglevel.debug("refreshing wc session");
          try {
            adapter.connect();
          } catch (error) {
            loglevel.error(`Error while disconnecting to wallet connect in core`, error);
          }
        }
        if (!visibility && this.status === ADAPTER_STATUS.CONNECTED && (walletConnectStatus === ADAPTER_STATUS.READY || walletConnectStatus === ADAPTER_STATUS.CONNECTING)) {
          loglevel.debug("this stops wc adapter from trying to reconnect once proposal expires");
          adapter.status = ADAPTER_STATUS.READY;
        }
      }
    });
  }
};

// node_modules/@web3auth/modal-react-hooks/dist/modalReactHooks.esm.js
var import_react10 = __toESM(require_react());
var Web3AuthInnerContext = (0, import_react10.createContext)(null);
function Web3AuthInnerProvider(params) {
  const {
    children,
    config
  } = params;
  const [web3Auth, setWeb3Auth] = (0, import_react10.useState)(null);
  const [isConnecting, setIsConnecting] = (0, import_react10.useState)(false);
  const [isInitializing, setIsInitializing] = (0, import_react10.useState)(false);
  const [initError, setInitError] = (0, import_react10.useState)(null);
  const [connectError, setConnectError] = (0, import_react10.useState)(null);
  const [isConnected, setIsConnected] = (0, import_react10.useState)(false);
  const [provider, setProvider] = (0, import_react10.useState)(null);
  const [userInfo, setUserInfo] = (0, import_react10.useState)(null);
  const [isMFAEnabled, setIsMFAEnabled] = (0, import_react10.useState)(false);
  const [isInitialized, setIsInitialized] = (0, import_react10.useState)(false);
  const [status, setStatus] = (0, import_react10.useState)(null);
  const addPlugin = (0, import_react10.useCallback)((plugin) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    return web3Auth.addPlugin(plugin);
  }, [web3Auth]);
  const getPlugin = (0, import_react10.useCallback)((name) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    return web3Auth.getPlugin(name);
  }, [web3Auth]);
  const initModal = (0, import_react10.useCallback)(async (modalParams = {}) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    try {
      setInitError(null);
      setIsInitializing(true);
      await web3Auth.initModal(modalParams);
    } catch (error) {
      setInitError(error);
      throw error;
    } finally {
      setIsInitializing(false);
    }
  }, [web3Auth]);
  const enableMFA = (0, import_react10.useCallback)(async (loginParams) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    if (!isConnected) throw WalletLoginError.notConnectedError();
    await web3Auth.enableMFA(loginParams);
    const localUserInfo = await web3Auth.getUserInfo();
    setUserInfo(localUserInfo);
    setIsMFAEnabled(localUserInfo.isMfaEnabled || false);
  }, [web3Auth, isConnected]);
  const logout = (0, import_react10.useCallback)(async (logoutParams = {
    cleanup: false
  }) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    if (!isConnected) throw WalletLoginError.notConnectedError();
    await web3Auth.logout(logoutParams);
  }, [web3Auth, isConnected]);
  const connect = (0, import_react10.useCallback)(async () => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    try {
      setConnectError(null);
      setIsConnecting(true);
      const localProvider = await web3Auth.connect();
      return localProvider;
    } catch (error) {
      setConnectError(error);
      throw error;
    } finally {
      setIsConnecting(false);
    }
  }, [web3Auth]);
  const addAndSwitchChain = (0, import_react10.useCallback)(async (chainConfig) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    await web3Auth.addChain(chainConfig);
    await web3Auth.switchChain({
      chainId: chainConfig.chainId
    });
  }, [web3Auth]);
  const authenticateUser = (0, import_react10.useCallback)(async () => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    return web3Auth.authenticateUser();
  }, [web3Auth]);
  const addChain = (0, import_react10.useCallback)(async (chainConfig) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    return web3Auth.addChain(chainConfig);
  }, [web3Auth]);
  const switchChain = (0, import_react10.useCallback)((chainParams) => {
    if (!web3Auth) throw WalletInitializationError.notReady();
    return web3Auth.switchChain(chainParams);
  }, [web3Auth]);
  (0, import_react10.useEffect)(() => {
    const resetHookState = () => {
      setProvider(null);
      setUserInfo(null);
      setIsMFAEnabled(false);
      setIsConnected(false);
      setStatus(null);
    };
    resetHookState();
    const {
      web3AuthOptions,
      adapters = [],
      plugins = []
    } = config;
    const web3AuthInstance = new Web3Auth(web3AuthOptions);
    if (adapters.length) adapters.map((adapter) => web3AuthInstance.configureAdapter(adapter));
    if (plugins.length) {
      plugins.forEach((plugin) => {
        web3AuthInstance.addPlugin(plugin);
      });
    }
    setWeb3Auth(web3AuthInstance);
  }, [config]);
  (0, import_react10.useEffect)(() => {
    const addState = async () => {
      setProvider(web3Auth.provider);
      const userState = await web3Auth.getUserInfo();
      setUserInfo(userState);
      setIsMFAEnabled((userState === null || userState === void 0 ? void 0 : userState.isMfaEnabled) || false);
    };
    const resetState = () => {
      setProvider(null);
      setUserInfo(null);
      setIsMFAEnabled(false);
    };
    if (web3Auth) {
      if (isConnected) addState();
      else resetState();
    }
  }, [web3Auth, isConnected]);
  (0, import_react10.useEffect)(() => {
    const notReadyListener = () => setStatus(web3Auth.status);
    const readyListener = () => {
      setStatus(web3Auth.status);
      setIsInitialized(true);
    };
    const connectedListener = () => {
      setStatus(web3Auth.status);
      setIsInitialized(true);
      setIsConnected(true);
    };
    const disconnectedListener = () => {
      setStatus(web3Auth.status);
      setIsConnected(false);
    };
    const connectingListener = () => {
      setStatus(web3Auth.status);
    };
    const errorListener = () => {
      setStatus(ADAPTER_STATUS.ERRORED);
    };
    if (web3Auth) {
      setStatus(web3Auth.status);
      web3Auth.on(ADAPTER_EVENTS.NOT_READY, notReadyListener);
      web3Auth.on(ADAPTER_EVENTS.READY, readyListener);
      web3Auth.on(ADAPTER_EVENTS.CONNECTED, connectedListener);
      web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, disconnectedListener);
      web3Auth.on(ADAPTER_EVENTS.CONNECTING, connectingListener);
      web3Auth.on(ADAPTER_EVENTS.ERRORED, errorListener);
    }
    return () => {
      if (web3Auth) {
        web3Auth.off(ADAPTER_EVENTS.NOT_READY, notReadyListener);
        web3Auth.off(ADAPTER_EVENTS.READY, readyListener);
        web3Auth.off(ADAPTER_EVENTS.CONNECTED, connectedListener);
        web3Auth.off(ADAPTER_EVENTS.DISCONNECTED, disconnectedListener);
        web3Auth.off(ADAPTER_EVENTS.CONNECTING, connectingListener);
        web3Auth.off(ADAPTER_EVENTS.ERRORED, errorListener);
      }
    };
  }, [web3Auth]);
  const value = (0, import_react10.useMemo)(() => {
    return {
      web3Auth,
      isConnected,
      isInitialized,
      provider,
      userInfo,
      isMFAEnabled,
      status,
      initModal,
      connect,
      enableMFA,
      logout,
      addAndSwitchChain,
      addChain,
      addPlugin,
      authenticateUser,
      switchChain,
      getPlugin,
      isInitializing,
      isConnecting,
      initError,
      connectError
    };
  }, [web3Auth, isConnected, isInitialized, provider, userInfo, isMFAEnabled, status, getPlugin, initModal, connect, enableMFA, logout, addAndSwitchChain, addChain, addPlugin, authenticateUser, switchChain, isInitializing, isConnecting, initError, connectError]);
  return (0, import_react10.createElement)(Web3AuthInnerContext.Provider, {
    value
  }, children);
}
var useWeb3Auth = () => {
  const context = (0, import_react10.useContext)(Web3AuthInnerContext);
  if (!context) {
    throw WalletInitializationError.fromCode(1e3, "usage of useWeb3Auth not wrapped in `Web3AuthContextProvider`.");
  }
  return context;
};
function Web3AuthProvider({
  config,
  children
}) {
  return (0, import_react10.createElement)(Web3AuthInnerProvider, {
    config
  }, children);
}
export {
  Web3AuthInnerContext,
  Web3AuthInnerProvider,
  Web3AuthProvider,
  useWeb3Auth
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@web3auth_modal-react-hooks.js.map
