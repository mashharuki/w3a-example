import { BasePreferencesController, CustomNft, CustomToken, InitPreferencesParams, IPreferencesController, PreferencesConfig, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import KeyringController from "../Keyring/KeyringController";
import NetworkController from "../Network/NetworkController";
import type { AddChainMessageParams, CustomNetworkPayload, CustomNftInfo, CustomTokenInfo, EtherscanTransaction, ExtendedAddressPreferences, TransactionPayload } from "../utils/interfaces";
export interface IPreferencesControllerOptions {
    config?: Partial<PreferencesConfig> & Pick<PreferencesConfig, "api" | "commonApiHost">;
    state?: Partial<PreferencesState<ExtendedAddressPreferences>>;
    provider: SafeEventEmitterProvider;
    signAuthMessage?: KeyringController["signAuthMessage"];
    getProviderConfig?: NetworkController["getProviderConfig"];
    setProviderConfig?: NetworkController["setProviderConfig"];
    validateSignMessage: (message: string) => Promise<void>;
}
export default class PreferencesController extends BasePreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> implements IPreferencesController<ExtendedAddressPreferences, PreferencesConfig, PreferencesState<ExtendedAddressPreferences>> {
    private _handle?;
    private _mutex;
    private getProviderConfig;
    private setProviderConfig;
    private provider;
    constructor({ config, state, provider, signAuthMessage, getProviderConfig, setProviderConfig, validateSignMessage, }: IPreferencesControllerOptions);
    poll(interval?: number): Promise<void>;
    initPreferences(params: InitPreferencesParams): Promise<void>;
    getSelectedAddress(): string;
    sync(address: string): Promise<boolean>;
    patchNewTx(tx: TransactionPayload, address: string): Promise<void>;
    recalculatePastTx(address?: string): void;
    refetchEtherscanTx(address?: string): Promise<EtherscanTransaction[]>;
    fetchEtherscanTx<T>(parameters: {
        selectedAddress: string;
        chainId: string;
    }): Promise<T[]>;
    getEtherScanTokens(address: string, chainId: string): Promise<CustomTokenInfo[]>;
    getSimpleHashNfts(address: string, chainId: string): Promise<CustomNftInfo[]>;
    getCustomTokens(address?: string): CustomToken[];
    getCustomNfts(address?: string): CustomNft[];
    isChainIdSupported(address: string, chainId: string): boolean;
    addChain(network: AddChainMessageParams): Promise<void>;
    switchChain(data: {
        chainId: string;
    }): void;
    addCustomNetwork({ network }: {
        network: CustomNetworkPayload;
    }): Promise<number>;
    deleteCustomNetwork(id: number): Promise<boolean>;
    editCustomNetwork({ network, id }: {
        network: CustomNetworkPayload;
        id: number | null;
    }): Promise<boolean>;
    private getChainOptions;
    private getBlockExplorerUrl;
    private calculatePastTx;
    private cancelTxCalculate;
}
