import { BaseController, PreferencesState } from "@toruslabs/base-controllers";
import { SafeEventEmitterProvider } from "@toruslabs/openlogin-jrpc";
import PreferencesController from "../Preferences/PreferencesController";
import { CustomNftInfo, EthereumNetworkState, ExtendedAddressPreferences } from "../utils/interfaces";
import { NftsControllerConfig, NftsControllerState } from "./INftsController";
export interface INftsControllerOptions {
    config?: Partial<NftsControllerConfig>;
    state?: Partial<NftsControllerState>;
    provider: SafeEventEmitterProvider;
    getCustomNfts?: PreferencesController["getCustomNfts"];
    getSimpleHashNfts: PreferencesController["getSimpleHashNfts"];
    onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
    onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}
export declare class NftsController extends BaseController<NftsControllerConfig, NftsControllerState> {
    name: string;
    private provider;
    private ethersProvider;
    private _timer;
    private getCustomNfts;
    private getSimpleHashNfts;
    constructor({ config, state, provider, getCustomNfts, getSimpleHashNfts, onPreferencesStateChange, onNetworkStateChange }: INftsControllerOptions);
    get userSelectedAddress(): string;
    get userNfts(): CustomNftInfo[];
    get interval(): number;
    set interval(interval: number);
    startNftDetection(selectedAddress: string): void;
    /**
     * Restart nft detection polling period and call detectNewNfts
     * in case of address change or user session initialization.
     *
     */
    restartNftDetection(): void;
    detectNewNfts(): void;
    refreshNftBalances(): Promise<void>;
    getNftBalancesUsingHandler(customNfts: CustomNftInfo[]): Promise<void>;
}
