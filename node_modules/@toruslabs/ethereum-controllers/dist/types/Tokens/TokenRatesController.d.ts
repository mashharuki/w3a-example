import { BaseConfig, BaseController, BaseState, PreferencesState } from "@toruslabs/base-controllers";
import { CustomTokenInfo, EthereumNetworkState, ExtendedAddressPreferences } from "../utils/interfaces";
import { TokensControllerState } from "./ITokensController";
export interface CoinGeckoResponse {
    [address: string]: {
        [currency: string]: number;
    };
}
export type ContractExchangeRates = Record<string, number | undefined>;
export declare const DEFAULT_CURRENCY = "eth";
export interface ITokenRatesControllerState extends BaseState {
    contractExchangeRates: ContractExchangeRates;
}
export interface ITokenRatesControllerConfig extends BaseConfig {
    pollInterval: number;
    api: string;
    currencyApi: string;
    chainId: string;
    selectedAddress: string;
    nativeCurrency: string;
    tokens: CustomTokenInfo[];
}
export interface TokenRatesControllerOptions {
    config: Partial<ITokenRatesControllerConfig>;
    state: Partial<ITokenRatesControllerState>;
    onPreferencesStateChange: (listener: (preferencesState: PreferencesState<ExtendedAddressPreferences>) => void) => void;
    onTokensStateChange: (listener: (tokensState: TokensControllerState) => void) => void;
    onNetworkStateChange: (listener: (networkState: EthereumNetworkState) => void) => void;
}
export declare class TokenRatesController extends BaseController<ITokenRatesControllerConfig, ITokenRatesControllerState> {
    private conversionInterval;
    constructor({ config, state, onPreferencesStateChange, onNetworkStateChange, onTokensStateChange }: TokenRatesControllerOptions);
    /**
     * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
     * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
     * previous interval is clear and a new one is created.
     */
    scheduleConversionInterval(): void;
    updateExchangeRates(): Promise<void>;
    private fetchExchangeRates;
}
