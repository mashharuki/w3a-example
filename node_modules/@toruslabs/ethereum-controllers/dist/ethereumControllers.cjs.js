/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 652:
/***/ ((module) => {

module.exports = require("@ethereumjs/common");

/***/ }),

/***/ 81:
/***/ ((module) => {

module.exports = require("@ethereumjs/tx");

/***/ }),

/***/ 731:
/***/ ((module) => {

module.exports = require("jsonschema");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ARBITRUM_MAINNET_CHAIN_ID: () => (/* reexport */ ARBITRUM_MAINNET_CHAIN_ID),
  ARBITRUM_TESTNET_CHAIN_ID: () => (/* reexport */ ARBITRUM_TESTNET_CHAIN_ID),
  AVALANCHE_MAINNET_CHAIN_ID: () => (/* reexport */ AVALANCHE_MAINNET_CHAIN_ID),
  AVALANCHE_TESTNET_CHAIN_ID: () => (/* reexport */ AVALANCHE_TESTNET_CHAIN_ID),
  AccountTrackerController: () => (/* reexport */ Account_AccountTrackerController),
  AddChainController: () => (/* reexport */ AddChainController),
  BASE_CHAIN_ID: () => (/* reexport */ BASE_CHAIN_ID),
  BASE_TESTNET_CHAIN_ID: () => (/* reexport */ BASE_TESTNET_CHAIN_ID),
  BNToHex: () => (/* reexport */ BNToHex),
  BSC_MAINNET_CHAIN_ID: () => (/* reexport */ BSC_MAINNET_CHAIN_ID),
  BSC_TESTNET_CHAIN_ID: () => (/* reexport */ BSC_TESTNET_CHAIN_ID),
  CELO_MAINNET_CHAIN_ID: () => (/* reexport */ CELO_MAINNET_CHAIN_ID),
  CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP: () => (/* reexport */ CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP),
  COINGECKO_PLATFORMS_CHAIN_CODE_MAP: () => (/* reexport */ COINGECKO_PLATFORMS_CHAIN_CODE_MAP),
  COINGECKO_SUPPORTED_CURRENCIES: () => (/* reexport */ COINGECKO_SUPPORTED_CURRENCIES),
  CONTRACT_TYPE_ERC1155: () => (/* reexport */ CONTRACT_TYPE_ERC1155),
  CONTRACT_TYPE_ERC20: () => (/* reexport */ CONTRACT_TYPE_ERC20),
  CONTRACT_TYPE_ERC721: () => (/* reexport */ CONTRACT_TYPE_ERC721),
  CONTRACT_TYPE_ETH: () => (/* reexport */ CONTRACT_TYPE_ETH),
  CurrencyController: () => (/* reexport */ CurrencyController),
  DEFAULT_CURRENCY: () => (/* reexport */ DEFAULT_CURRENCY),
  DecryptMessageController: () => (/* reexport */ DecryptMessageController),
  ERC1155_INTERFACE_ID: () => (/* reexport */ ERC1155_INTERFACE_ID),
  ERC721_ENUMERABLE_INTERFACE_ID: () => (/* reexport */ ERC721_ENUMERABLE_INTERFACE_ID),
  ERC721_INTERFACE_ID: () => (/* reexport */ ERC721_INTERFACE_ID),
  ERC721_METADATA_INTERFACE_ID: () => (/* reexport */ ERC721_METADATA_INTERFACE_ID),
  ETHERSCAN_SUPPORTED_CHAINS: () => (/* reexport */ ETHERSCAN_SUPPORTED_CHAINS),
  EncryptionPublicKeyController: () => (/* reexport */ EncryptionPublicKeyController),
  GAS_ESTIMATE_TYPES: () => (/* reexport */ GAS_ESTIMATE_TYPES),
  GAS_LIMITS: () => (/* reexport */ GAS_LIMITS),
  GasFeeController: () => (/* reexport */ GasFeeController),
  KeyringController: () => (/* reexport */ KeyringController),
  LOCALHOST: () => (/* reexport */ LOCALHOST),
  MAINNET_CHAIN_ID: () => (/* reexport */ MAINNET_CHAIN_ID),
  MESSAGE_EVENTS: () => (/* reexport */ MESSAGE_EVENTS),
  METHOD_TYPES: () => (/* reexport */ METHOD_TYPES),
  MessageController: () => (/* reexport */ MessageController),
  MessageStatus: () => (/* reexport */ MessageStatus),
  NetworkController: () => (/* reexport */ NetworkController),
  NftHandler: () => (/* reexport */ NftHandler),
  NftsController: () => (/* reexport */ NftsController),
  NonceTracker: () => (/* reexport */ Transaction_NonceTracker),
  OLD_ERC721_LIST: () => (/* reexport */ OLD_ERC721_LIST),
  OPTIMISM_MAINNET_CHAIN_ID: () => (/* reexport */ OPTIMISM_MAINNET_CHAIN_ID),
  OPTIMISM_TESTNET_CHAIN_ID: () => (/* reexport */ OPTIMISM_TESTNET_CHAIN_ID),
  POLYGON_AMOY_CHAIN_ID: () => (/* reexport */ POLYGON_AMOY_CHAIN_ID),
  POLYGON_CHAIN_ID: () => (/* reexport */ POLYGON_CHAIN_ID),
  PendingTransactionTracker: () => (/* reexport */ PendingTransactionTracker),
  PersonalMessageController: () => (/* reexport */ PersonalMessageController),
  PollingBlockTracker: () => (/* reexport */ Block_PollingBlockTracker),
  PreferencesController: () => (/* reexport */ PreferencesController),
  SEPOLIA_CHAIN_ID: () => (/* reexport */ SEPOLIA_CHAIN_ID),
  SIMPLEHASH_SUPPORTED_CHAINS: () => (/* reexport */ SIMPLEHASH_SUPPORTED_CHAINS),
  SUPPORTED_NETWORKS: () => (/* reexport */ SUPPORTED_NETWORKS),
  SwitchChainController: () => (/* reexport */ SwitchChainController),
  TEST_CHAINS: () => (/* reexport */ TEST_CHAINS),
  TRANSACTION_ENVELOPE_TYPES: () => (/* reexport */ TRANSACTION_ENVELOPE_TYPES),
  TokenHandler: () => (/* reexport */ TokenHandler),
  TokenRatesController: () => (/* reexport */ TokenRatesController),
  TokensController: () => (/* reexport */ TokensController),
  TransactionController: () => (/* reexport */ TransactionController),
  TransactionGasUtil: () => (/* reexport */ TransactionGasUtil),
  TransactionStateManager: () => (/* reexport */ TransactionStateManager),
  TypedMessageController: () => (/* reexport */ TypedMessageController),
  XDAI_CHAIN_ID: () => (/* reexport */ XDAI_CHAIN_ID),
  addCurrencies: () => (/* reexport */ addCurrencies),
  addEtherscanTransactions: () => (/* reexport */ addEtherscanTransactions),
  bnLessThan: () => (/* reexport */ bnLessThan),
  conversionGTE: () => (/* reexport */ conversionGTE),
  conversionGreaterThan: () => (/* reexport */ conversionGreaterThan),
  conversionLTE: () => (/* reexport */ conversionLTE),
  conversionLessThan: () => (/* reexport */ conversionLessThan),
  conversionMax: () => (/* reexport */ conversionMax),
  conversionUtil: () => (/* reexport */ conversionUtil),
  createChainIdMiddleware: () => (/* reexport */ createChainIdMiddleware),
  createEthereumMiddleware: () => (/* reexport */ createEthereumMiddleware),
  createGetAccountsMiddleware: () => (/* reexport */ createGetAccountsMiddleware),
  createJsonRpcClient: () => (/* reexport */ createJsonRpcClient),
  createPendingNonceMiddleware: () => (/* reexport */ createPendingNonceMiddleware),
  createPendingTxMiddleware: () => (/* reexport */ createPendingTxMiddleware),
  createProcessAddEthereumChain: () => (/* reexport */ createProcessAddEthereumChain),
  createProcessDecryptMessageMiddleware: () => (/* reexport */ createProcessDecryptMessageMiddleware),
  createProcessEncryptionPublicKeyMiddleware: () => (/* reexport */ createProcessEncryptionPublicKeyMiddleware),
  createProcessEthSignMessage: () => (/* reexport */ createProcessEthSignMessage),
  createProcessPersonalMessage: () => (/* reexport */ createProcessPersonalMessage),
  createProcessSwitchEthereumChain: () => (/* reexport */ createProcessSwitchEthereumChain),
  createProcessTransactionMiddleware: () => (/* reexport */ createProcessTransactionMiddleware),
  createProcessTypedMessage: () => (/* reexport */ createProcessTypedMessage),
  createProcessTypedMessageV3: () => (/* reexport */ createProcessTypedMessageV3),
  createProcessTypedMessageV4: () => (/* reexport */ createProcessTypedMessageV4),
  createProviderConfigMiddleware: () => (/* reexport */ createProviderConfigMiddleware),
  createRequestAccountsMiddleware: () => (/* reexport */ createRequestAccountsMiddleware),
  decGWEIToHexWEI: () => (/* reexport */ decGWEIToHexWEI),
  determineTransactionType: () => (/* reexport */ determineTransactionType),
  ensureFieldIsString: () => (/* reexport */ ensureFieldIsString),
  ensureMutuallyExclusiveFieldsNotProvided: () => (/* reexport */ ensureMutuallyExclusiveFieldsNotProvided),
  erc1155Abi: () => (/* reexport */ erc1155Abi),
  erc20Abi: () => (/* reexport */ erc20Abi),
  erc721Abi: () => (/* reexport */ erc721Abi),
  formatDate: () => (/* reexport */ formatDate),
  formatPastTx: () => (/* reexport */ formatPastTx),
  formatTime: () => (/* reexport */ formatTime),
  formatTxMetaForRpcResult: () => (/* reexport */ formatTxMetaForRpcResult),
  generateHistoryEntry: () => (/* reexport */ generateHistoryEntry),
  getBigNumber: () => (/* reexport */ getBigNumber),
  getChainType: () => (/* reexport */ getChainType),
  getEthTxStatus: () => (/* reexport */ getEthTxStatus),
  getEtherScanHashLink: () => (/* reexport */ getEtherScanHashLink),
  getFinalStates: () => (/* reexport */ getFinalStates),
  getIpfsEndpoint: () => (/* reexport */ getIpfsEndpoint),
  hexToBn: () => (/* reexport */ hexToBn),
  hexWEIToDecGWEI: () => (/* reexport */ hexWEIToDecGWEI),
  idleTimeTracker: () => (/* reexport */ idleTimeTracker),
  isAddressByChainId: () => (/* reexport */ isAddressByChainId),
  isEIP1559Transaction: () => (/* reexport */ isEIP1559Transaction),
  isLegacyTransaction: () => (/* reexport */ isLegacyTransaction),
  multiplyCurrencies: () => (/* reexport */ multiplyCurrencies),
  normalizeAndValidateTxParams: () => (/* reexport */ normalizeAndValidateTxParams),
  normalizeMessageData: () => (/* reexport */ normalizeMessageData),
  normalizeTxParameters: () => (/* reexport */ normalizeTxParameters),
  parseDecryptMessageData: () => (/* reexport */ parseDecryptMessageData),
  parseStandardTokenTransactionData: () => (/* reexport */ parseStandardTokenTransactionData),
  readAddressAsContract: () => (/* reexport */ readAddressAsContract),
  replayHistory: () => (/* reexport */ replayHistory),
  sanitizeNftMetdataUrl: () => (/* reexport */ sanitizeNftMetdataUrl),
  singleBalanceCheckerAbi: () => (/* reexport */ singleBalanceCheckerAbi),
  snapshotFromTxMeta: () => (/* reexport */ snapshotFromTxMeta),
  subtractCurrencies: () => (/* reexport */ subtractCurrencies),
  toChecksumAddressByChainId: () => (/* reexport */ toChecksumAddressByChainId),
  toNegative: () => (/* reexport */ toNegative),
  transactionMatchesNetwork: () => (/* reexport */ transactionMatchesNetwork),
  validateAddChainData: () => (/* reexport */ validateAddChainData),
  validateAddress: () => (/* reexport */ validateAddress),
  validateDecryptedMessageData: () => (/* reexport */ validateDecryptedMessageData),
  validateEncryptionPublicKeyMessageData: () => (/* reexport */ validateEncryptionPublicKeyMessageData),
  validateFrom: () => (/* reexport */ validateFrom),
  validateRecipient: () => (/* reexport */ validateRecipient),
  validateSignMessageData: () => (/* reexport */ validateSignMessageData),
  validateSwitchChainData: () => (/* reexport */ validateSwitchChainData),
  validateTxParameters: () => (/* reexport */ validateTxParameters),
  validateTypedSignMessageDataV1: () => (/* reexport */ validateTypedSignMessageDataV1),
  validateTypedSignMessageDataV3V4: () => (/* reexport */ validateTypedSignMessageDataV3V4)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// CONCATENATED MODULE: external "async-mutex"
const external_async_mutex_namespaceObject = require("async-mutex");
;// CONCATENATED MODULE: external "ethers"
const external_ethers_namespaceObject = require("ethers");
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// CONCATENATED MODULE: ./src/utils/abis.ts
const erc20Abi = [{
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "decimals",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "balance",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }, {
    name: "_extraData",
    type: "bytes"
  }],
  name: "approveAndCall",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    name: "remaining",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  inputs: [{
    name: "_initialAmount",
    type: "uint256"
  }, {
    name: "_tokenName",
    type: "string"
  }, {
    name: "_decimalUnits",
    type: "uint8"
  }, {
    name: "_tokenSymbol",
    type: "string"
  }],
  type: "constructor"
}, {
  payable: false,
  type: "fallback"
}];
const erc721Abi = [{
  constant: true,
  inputs: [{
    name: "interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    type: "bool"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "_name",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_approved",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "approve",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_index",
    type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_index",
    type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "_symbol",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}];
const erc1155Abi = [{
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address[]",
    name: "_owners",
    type: "address[]"
  }, {
    internalType: "uint256[]",
    name: "_ids",
    type: "uint256[]"
  }],
  name: "balanceOfBatch",
  outputs: [{
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "address",
    name: "_operator",
    type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
    internalType: "bool",
    name: "isOperator",
    type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_from",
    type: "address"
  }, {
    internalType: "address",
    name: "_to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "_amount",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_operator",
    type: "address"
  }, {
    internalType: "bool",
    name: "_approved",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "uri",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const singleBalanceCheckerAbi = [{
  payable: true,
  stateMutability: "payable",
  type: "fallback"
}, {
  constant: true,
  inputs: [{
    name: "user",
    type: "address"
  }, {
    name: "token",
    type: "address"
  }],
  name: "tokenBalance",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "users",
    type: "address[]"
  }, {
    name: "tokens",
    type: "address[]"
  }],
  name: "balances",
  outputs: [{
    name: "",
    type: "uint256[]"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}];
;// CONCATENATED MODULE: ./src/utils/constants.ts

const LOCALHOST = "localhost";
const CONTRACT_TYPE_ETH = "eth";
const CONTRACT_TYPE_ERC20 = "erc20";
const CONTRACT_TYPE_ERC721 = "erc721";
const CONTRACT_TYPE_ERC1155 = "erc1155";
const ERC1155_INTERFACE_ID = "0xd9b67a26";
const ERC721_INTERFACE_ID = "0x80ac58cd";
const ERC721_METADATA_INTERFACE_ID = "0x5b5e139f";
const ERC721_ENUMERABLE_INTERFACE_ID = "0x780e9d63";
const MAINNET_CHAIN_ID = "0x1";
const POLYGON_CHAIN_ID = "0x89";
const BSC_MAINNET_CHAIN_ID = "0x38";
const AVALANCHE_MAINNET_CHAIN_ID = "0xa86a";
const XDAI_CHAIN_ID = "0x64";
const ARBITRUM_MAINNET_CHAIN_ID = "0xa4b1";
const OPTIMISM_MAINNET_CHAIN_ID = "0xa";
const CELO_MAINNET_CHAIN_ID = "0xa4ec";
const BASE_CHAIN_ID = "0x2105";
const SEPOLIA_CHAIN_ID = "0xaa36a7";
const POLYGON_AMOY_CHAIN_ID = "0x13882";
const BSC_TESTNET_CHAIN_ID = "0x61";
const AVALANCHE_TESTNET_CHAIN_ID = "0xa869";
const ARBITRUM_TESTNET_CHAIN_ID = "0x66eee";
const OPTIMISM_TESTNET_CHAIN_ID = "0xaa37dc";
const BASE_TESTNET_CHAIN_ID = "0x14a34";
const INFURA_KEY = process.env.VITE_APP_INFURA_PROJECT_KEY;
const SUPPORTED_NETWORKS = {
  [MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://etherscan.io",
    chainId: MAINNET_CHAIN_ID,
    displayName: "Ethereum",
    logo: "eth.svg",
    rpcTarget: `https://mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [POLYGON_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://polygonscan.com",
    chainId: POLYGON_CHAIN_ID,
    displayName: "Polygon",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://bscscan.com",
    chainId: BSC_MAINNET_CHAIN_ID,
    displayName: "Binance Smart Chain (BSC)",
    logo: "bnb_logo.svg",
    rpcTarget: `https://bsc-dataseed.binance.org`,
    ticker: "BNB",
    tickerName: "Binance Coin"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://snowtrace.io",
    chainId: AVALANCHE_MAINNET_CHAIN_ID,
    displayName: "Avalanche",
    logo: "avax.svg",
    rpcTarget: `https://api.avax.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://optimistic.etherscan.io",
    chainId: OPTIMISM_MAINNET_CHAIN_ID,
    displayName: "Optimism",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://explorer.celo.org",
    chainId: CELO_MAINNET_CHAIN_ID,
    displayName: "Celo Mainnet",
    logo: "celo.svg",
    rpcTarget: `https://celo-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "CELO",
    tickerName: "Celo"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://arbiscan.io",
    chainId: ARBITRUM_MAINNET_CHAIN_ID,
    displayName: "Arbitrum One",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [XDAI_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://gnosis.blockscout.com",
    chainId: XDAI_CHAIN_ID,
    displayName: "xDai",
    logo: "xDai.svg",
    rpcTarget: `https://rpc.gnosischain.com`,
    ticker: "DAI",
    tickerName: "xDai Token"
  },
  [BASE_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://basescan.org",
    chainId: BASE_CHAIN_ID,
    displayName: "Base",
    logo: "base.svg",
    rpcTarget: `https://mainnet.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [SEPOLIA_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.etherscan.io",
    chainId: SEPOLIA_CHAIN_ID,
    displayName: "Sepolia Test Network",
    logo: "eth.svg",
    rpcTarget: `https://sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [POLYGON_AMOY_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://amoy.polygonscan.com",
    chainId: POLYGON_AMOY_CHAIN_ID,
    displayName: "Polygon Amoy",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-amoy.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token",
    isTestnet: true
  },
  [BSC_TESTNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.bscscan.com",
    chainId: BSC_TESTNET_CHAIN_ID,
    displayName: "Binance Smart Chain Testnet",
    logo: "bnb_logo.svg",
    rpcTarget: `https://data-seed-prebsc-1-s1.binance.org:8545`,
    ticker: "BNB",
    tickerName: "Binance Coin",
    isTestnet: true
  },
  [AVALANCHE_TESTNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.snowtrace.io",
    chainId: AVALANCHE_TESTNET_CHAIN_ID,
    displayName: "Avalanche Testnet C-Chain",
    logo: "avax.svg",
    rpcTarget: `https://api.avax-test.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche",
    isTestnet: true
  },
  [ARBITRUM_TESTNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.arbiscan.io",
    chainId: ARBITRUM_TESTNET_CHAIN_ID,
    displayName: "Arbitrum Sepolia",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [OPTIMISM_TESTNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia-optimistic.etherscan.io",
    chainId: OPTIMISM_TESTNET_CHAIN_ID,
    displayName: "Optimism Sepolia",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [BASE_TESTNET_CHAIN_ID]: {
    chainNamespace: base_controllers_namespaceObject.CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.basescan.org",
    chainId: BASE_TESTNET_CHAIN_ID,
    displayName: "Base Sepolia",
    logo: "base.svg",
    rpcTarget: `https://sepolia.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  }
};
const METHOD_TYPES = {
  GET_ACCOUNTS: "eth_accounts",
  ETH_TRANSACTION: "eth_sendTransaction",
  ETH_REQUEST_ACCOUNTS: "eth_requestAccounts",
  ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  PERSONAL_SIGN: "personal_sign",
  ETH_GET_TRANSACTION_COUNT: "eth_getTransactionCount",
  ETH_GET_TRANSACTION_BY_HASH: "eth_getTransactionByHash",
  ETH_GET_ENCRYPTION_PUBLIC_KEY: "eth_getEncryptionPublicKey",
  ETH_DECRYPT: "eth_decrypt",
  ETH_GET_TRANSACTION_RECEIPT: "eth_getTransactionReceipt",
  WATCH_ASSET: "wallet_watchAsset",
  ETH_GET_BLOCK_BY_HASH: "eth_getBlockByHash",
  ETH_GET_CODE: "eth_getCode",
  ETH_GET_GAS_PRICE: "eth_gasPrice",
  SWITCH_CHAIN: "wallet_switchEthereumChain",
  ADD_CHAIN: "wallet_addEthereumChain"
};
const TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
};
const GAS_ESTIMATE_TYPES = {
  // Fee Market describes the way gas is set after the london hardfork, and was
  // defined by EIP-1559.
  FEE_MARKET: "fee-market",
  // Legacy describes gasPrice estimates from before london hardfork, when the
  // user is connected to mainnet and are presented with fast/average/slow
  // estimate levels to choose from.
  LEGACY: "legacy",
  // EthGasPrice describes a gasPrice estimate received from eth_gasPrice. Post
  // london this value should only be used for legacy type transactions when on
  // networks that support EIP-1559. This type of estimate is the most accurate
  // to display on custom networks that don't support EIP-1559.
  ETH_GASPRICE: "eth_gasPrice",
  // NoEstimate describes the state of the controller before receiving its first
  // estimate.
  NONE: "none"
};

// https://help.optimism.io/hc/en-us/articles/4411895794715-Transaction-fees
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [OPTIMISM_MAINNET_CHAIN_ID]: 1,
  [OPTIMISM_TESTNET_CHAIN_ID]: 1
};
const OLD_ERC721_LIST = {
  "0x06012c8cf97bead5deae237070f9587f8e7a266d": {
    name: "Cryptokitties",
    logo: "dapp-cryptokitty.svg",
    erc20: true,
    symbol: "CK",
    decimals: 0
  }
};
const TEST_CHAINS = [SEPOLIA_CHAIN_ID];
const ETHERSCAN_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, CELO_MAINNET_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];
const SIMPLEHASH_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, CELO_MAINNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];
const COINGECKO_SUPPORTED_CURRENCIES = new Set(["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"]);
const COINGECKO_PLATFORMS_CHAIN_CODE_MAP = {
  [POLYGON_CHAIN_ID]: {
    platform: "polygon-pos",
    currency: "matic"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    platform: "binance-smart-chain",
    currency: "bnb"
  },
  [MAINNET_CHAIN_ID]: {
    platform: "ethereum",
    currency: "eth"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    platform: "arbitrum-one",
    currency: "eth"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    platform: "optimistic-ethereum",
    currency: "eth"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    platform: "celo",
    currency: "celo"
  },
  [XDAI_CHAIN_ID]: {
    platform: "xdai",
    currency: "xDAI"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    platform: "avalanche",
    currency: "avax"
  },
  [BASE_CHAIN_ID]: {
    platform: "base",
    currency: "eth"
  }
};
const MessageStatus = {
  UNAPPROVED: "unapproved",
  SIGNED: "signed",
  PENDING: "pending",
  APPROVED: "approved",
  REJECTED: "rejected",
  FAILED: "failed"
};
const MESSAGE_EVENTS = {
  UNAPPROVED_MESSAGE: "unapprovedMessage"
};
;// CONCATENATED MODULE: ./src/utils/contractAddresses.ts

const SINGLE_CALL_BALANCES_ADDRESSES = {
  [MAINNET_CHAIN_ID]: "0xb1f8e55c7f64d203c1400b9d8555d050f94adf39",
  // [SEPOLIA_CHAIN_ID]: SINGLE_CALL_BALANCES_ADDRESS_SEPOLIA,
  // [FANTOM_CHAIN_ID]: "0x07f697424ABe762bB808c109860c04eA488ff92B",
  [BSC_MAINNET_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [OPTIMISM_MAINNET_CHAIN_ID]: "0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC",
  [POLYGON_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [AVALANCHE_MAINNET_CHAIN_ID]: "0xD023D153a0DFa485130ECFdE2FAA7e612EF94818",
  [ARBITRUM_MAINNET_CHAIN_ID]: "0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c"
};
;// CONCATENATED MODULE: ./src/Account/AccountTrackerController.ts








const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

/**
 * Tracks accounts based on blocks.
 * If block tracker provides latest block, we query accounts from it.
 * Preferences state changes also retrigger accounts update.
 * Network state changes also retrigger accounts update.
 */
class AccountTrackerController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    getIdentities,
    onPreferencesStateChange,
    getCurrentChainId
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "blockTracker", void 0);
    defineProperty_default()(this, "mutex", new external_async_mutex_namespaceObject.Mutex());
    defineProperty_default()(this, "ethersProvider", void 0);
    defineProperty_default()(this, "getIdentities", void 0);
    defineProperty_default()(this, "getCurrentChainId", void 0);
    this.defaultState = {
      accounts: {}
    };
    this.initialize();
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.ethersProvider = new external_ethers_namespaceObject.BrowserProvider(this.provider, "any");
    this.getIdentities = getIdentities;
    this.getCurrentChainId = getCurrentChainId;
    onPreferencesStateChange(() => {
      const refreshNeeded = this.syncAccounts();
      if (refreshNeeded) {
        external_loglevel_default().info("onPreferencesStateChange called");
        this.refresh();
      }
    });
    this.blockTrackerListener = this.blockTrackerListener.bind(this);
  }
  blockTrackerListener() {
    this.refresh();
  }
  startPolling() {
    this.stopPolling();
    // Initiate block tracker internal tracking.
    if (Object.keys(this.state.accounts).length > 0) {
      // Adding this listener on block tracker triggers it to start polling.
      this.blockTracker.on("latest", this.blockTrackerListener);
    }
  }
  stopPolling() {
    this.blockTracker.removeListener("latest", this.blockTrackerListener);
  }
  syncAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(this.getIdentities());
    const existing = Object.keys(accounts);
    const newAddresses = addresses.filter(address => existing.indexOf(address) === -1);
    const oldAddresses = existing.filter(address => addresses.indexOf(address) === -1);
    let isUpdated = false;
    newAddresses.forEach(address => {
      isUpdated = true;
      accounts[address] = {
        balance: "0x0"
      };
    });
    oldAddresses.forEach(address => {
      isUpdated = true;
      delete accounts[address];
    });
    this.update({
      accounts: objectSpread2_default()({}, accounts)
    });
    return isUpdated;
  }
  async refresh() {
    const releaseLock = await this.mutex.acquire();
    try {
      this._updateAccounts();
    } catch (error) {} finally {
      releaseLock();
    }
  }
  async _updateAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") return;
    if (addresses.length > 0) {
      if (SINGLE_CALL_BALANCES_ADDRESSES[chainId]) {
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESSES[chainId]);
        return;
      }
      external_loglevel_default().info("falling back to ethQuery.getBalance");
      await Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
  async _updateAccount(address) {
    const balance = await this.provider.request({
      method: "eth_getBalance",
      params: [address, "latest"]
    });
    const {
      accounts
    } = this.state;
    if (!accounts[address]) return;
    accounts[address] = {
      balance: (0,external_ethers_namespaceObject.toQuantity)(balance)
    };
    this.update({
      accounts
    });
  }
  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {
    const ethContract = new external_ethers_namespaceObject.Contract(deployedContractAddress, singleBalanceCheckerAbi, this.ethersProvider);
    try {
      const result = await ethContract.balances(addresses, [ZERO_ADDRESS]);
      const {
        accounts
      } = this.state;
      addresses.forEach((address, index) => {
        const balance = (0,external_ethers_namespaceObject.toQuantity)(result[index]);
        if (!accounts[address]) return;
        accounts[address] = {
          balance
        };
      });
      return this.update({
        accounts
      });
    } catch (error) {
      external_loglevel_default().warn("Torus - Account Tracker single call balance fetch failed", error);
      return Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
}
/* harmony default export */ const Account_AccountTrackerController = (AccountTrackerController);
;// CONCATENATED MODULE: external "@ethereumjs/util"
const util_namespaceObject = require("@ethereumjs/util");
;// CONCATENATED MODULE: external "bignumber.js"
const external_bignumber_js_namespaceObject = require("bignumber.js");
var external_bignumber_js_default = /*#__PURE__*/__webpack_require__.n(external_bignumber_js_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/openlogin-jrpc"
const openlogin_jrpc_namespaceObject = require("@toruslabs/openlogin-jrpc");
;// CONCATENATED MODULE: ./src/Transaction/TransactionUtils.ts







const erc20Interface = new external_ethers_namespaceObject.Interface(erc20Abi);
const erc721Interface = new external_ethers_namespaceObject.Interface(erc721Abi);
const erc1155Interface = new external_ethers_namespaceObject.Interface(erc1155Abi);

// functions that handle normalizing of that key in txParams

const normalizers = {
  from: (from, LowerCase = true) => LowerCase ? (0,util_namespaceObject.addHexPrefix)(from).toLowerCase() : (0,util_namespaceObject.addHexPrefix)(from),
  to: (to, LowerCase = true) => LowerCase ? (0,util_namespaceObject.addHexPrefix)(to).toLowerCase() : (0,util_namespaceObject.addHexPrefix)(to),
  nonce: nonce => (0,util_namespaceObject.addHexPrefix)(nonce),
  customNonceValue: nonce => (0,util_namespaceObject.addHexPrefix)(nonce),
  value: value => (0,util_namespaceObject.addHexPrefix)(value),
  data: data => (0,util_namespaceObject.addHexPrefix)(data),
  gas: gas => (0,util_namespaceObject.addHexPrefix)(gas),
  gasPrice: gasPrice => (0,util_namespaceObject.addHexPrefix)(gasPrice),
  type: util_namespaceObject.addHexPrefix,
  maxFeePerGas: util_namespaceObject.addHexPrefix,
  maxPriorityFeePerGas: util_namespaceObject.addHexPrefix
};

/**
 * normalizes txParams
 */
function normalizeTxParameters(txParameters, lowerCase = true) {
  // apply only keys in the normalizers
  const normalizedTxParameters = {
    id: txParameters.id || (0,base_controllers_namespaceObject.randomId)(),
    from: txParameters.from
  };
  for (const key in normalizers) {
    const currentKey = key;
    if (txParameters[currentKey])
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      normalizedTxParameters[currentKey] = normalizers[currentKey](txParameters[currentKey], lowerCase);
  }
  return normalizedTxParameters;
}
function transactionMatchesNetwork(transaction, chainId) {
  if (typeof transaction.chainId !== "undefined") {
    return transaction.chainId === chainId;
  }
  return false;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *  the transaction to check
 * @returns true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$transact, _transaction$transact2;
  return (0,util_namespaceObject.isHexString)((0,util_namespaceObject.addHexPrefix)(transaction === null || transaction === void 0 || (_transaction$transact = transaction.transaction) === null || _transaction$transact === void 0 ? void 0 : _transaction$transact.maxFeePerGas)) && (0,util_namespaceObject.isHexString)((0,util_namespaceObject.addHexPrefix)(transaction === null || transaction === void 0 || (_transaction$transact2 = transaction.transaction) === null || _transaction$transact2 === void 0 ? void 0 : _transaction$transact2.maxPriorityFeePerGas));
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 * transaction -
 *  the transaction to check
 * @returns true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.transaction.maxFeePerGas === "undefined" && typeof transaction.transaction.maxPriorityFeePerGas === "undefined" && (typeof transaction.transaction.gasPrice === "undefined" || (0,util_namespaceObject.isHexString)((0,util_namespaceObject.addHexPrefix)(transaction.transaction.gasPrice)));
}

/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 */
function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
  if (typeof txParams[mutuallyExclusiveField] !== "undefined") {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
  }
}

/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 */
function ensureFieldIsString(txParams, field) {
  if (typeof txParams[field] !== "string") {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
  }
}

/**
 * Ensures that the provided txParams has the proper 'type' specified for the
 * given field, if it is provided. If types do not match throws an
 * invalidParams error.
 */
function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
  switch (field) {
    case "maxFeePerGas":
    case "maxPriorityFeePerGas":
      if (txParams.type && txParams.type !== TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + `including maxFeePerGas and maxPriorityFeePerGas requires type: "${TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}"`);
      }
      break;
    case "gasPrice":
    default:
      if (txParams.type && txParams.type === TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + "included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas");
      }
  }
}

/**
 * validates the from field in  txParams
 */
function validateFrom(txParams) {
  if (!(typeof txParams.from === "string")) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid "from" address "${txParams.from}": not a string.`);
  }
  if (!(0,util_namespaceObject.isValidAddress)(txParams.from)) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams('Invalid "from" address.');
  }
}

/**
 * validates the to field in  txParams
 */
function validateRecipient(txParameters) {
  if (txParameters.to === "0x" || txParameters.to === null) {
    if (txParameters.data) {
      delete txParameters.to;
    } else {
      throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams('Invalid "to" address.');
    }
  } else if (txParameters.to !== undefined && !(0,util_namespaceObject.isValidAddress)(txParameters.to)) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams('Invalid "to" address.');
  }
  return txParameters;
}

/**
 * Validates the given tx parameters
 * @throws if the tx params contains invalid fields
 */
function validateTxParameters(txParams, eip1559Compatibility = true) {
  if (!txParams || typeof txParams !== "object" || Array.isArray(txParams)) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Invalid transaction params: must be an object.");
  }
  if (!txParams.to && !txParams.data) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams('Invalid transaction params: must specify "data" for contract deployments, or "to" (and optionally "data") for all other types of transactions.');
  }
  if (isEIP1559Transaction({
    transaction: txParams
  }) && !eip1559Compatibility) {
    throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams("Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559");
  }
  Object.entries(txParams).forEach(([key, value]) => {
    // validate types
    switch (key) {
      case "from":
        validateFrom(txParams);
        break;
      case "to":
        validateRecipient(txParams);
        break;
      case "gasPrice":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "gasPrice");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxPriorityFeePerGas");
        ensureFieldIsString(txParams, "gasPrice");
        break;
      case "maxFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxFeePerGas");
        break;
      case "maxPriorityFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxPriorityFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxPriorityFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxPriorityFeePerGas");
        break;
      case "value":
        ensureFieldIsString(txParams, "value");
        if (value.toString().includes("-")) {
          throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
        }
        if (value.toString().includes(".")) {
          throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction value of "${value}": number must be in wei.`);
        }
        break;
      case "chainId":
        if (typeof value !== "number" && typeof value !== "string") {
          throw openlogin_jrpc_namespaceObject.rpcErrors.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);
        }
        break;
      default:
        ensureFieldIsString(txParams, key);
    }
  });
}
function normalizeAndValidateTxParams(txParams, lowerCase = true) {
  const normalizedTxParams = normalizeTxParameters(txParams, lowerCase);
  validateTxParameters(normalizedTxParams);
  return normalizedTxParams;
}

/**
 * @returns an array of states that can be considered final
 */
function getFinalStates() {
  return [base_controllers_namespaceObject.TransactionStatus.rejected,
  // the user has responded no!
  base_controllers_namespaceObject.TransactionStatus.confirmed,
  // the tx has been included in a block.
  base_controllers_namespaceObject.TransactionStatus.failed,
  // the tx failed for some reason, included on tx data.
  base_controllers_namespaceObject.TransactionStatus.dropped // the tx nonce was already used
  ];
}
function parseStandardTokenTransactionData(data) {
  try {
    const txDesc = erc20Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC20
    };
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    const txDesc = erc721Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC721
    };
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    const txDesc = erc1155Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC1155
    };
  } catch {
    // ignore and return undefined
  }
  return undefined;
}
const readAddressAsContract = async (provider, address) => {
  let contractCode;
  try {
    contractCode = await provider.request({
      method: METHOD_TYPES.ETH_GET_CODE,
      params: [address, "latest"]
    });
  } catch (e) {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== "0x" && contractCode !== "0x0" : false;
  return {
    contractCode,
    isContractAddress
  };
};
async function determineTransactionType(txParams, provider) {
  const {
    data,
    to
  } = txParams;
  let name = "";
  let methodParams = [];
  let type = "";
  try {
    ({
      name,
      methodParams,
      type
    } = data && parseStandardTokenTransactionData(data) || {});
  } catch (error) {
    external_loglevel_default().debug("Failed to parse transaction data", error);
  }
  let result;
  let contractCode = "";
  if (data && !to) {
    result = base_controllers_namespaceObject.TRANSACTION_TYPES.DEPLOY_CONTRACT;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await readAddressAsContract(provider, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const valueExists = txParams.value && Number(txParams.value) !== 0;
      const tokenMethodName = [base_controllers_namespaceObject.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, base_controllers_namespaceObject.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, base_controllers_namespaceObject.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, base_controllers_namespaceObject.TRANSACTION_TYPES.COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM, base_controllers_namespaceObject.TRANSACTION_TYPES.SET_APPROVAL_FOR_ALL].find(x => {
        var _name;
        return x.toLowerCase() === ((_name = name) === null || _name === void 0 ? void 0 : _name.toLowerCase());
      });
      result = data && tokenMethodName && !valueExists ? tokenMethodName : base_controllers_namespaceObject.TRANSACTION_TYPES.CONTRACT_INTERACTION;
    } else {
      result = base_controllers_namespaceObject.TRANSACTION_TYPES.SENT_ETHER;
    }
  }
  return {
    type: type || CONTRACT_TYPE_ETH,
    category: result,
    methodParams,
    getCodeResponse: contractCode
  };
}
;// CONCATENATED MODULE: ./src/utils/helpers.ts







function hexToBn(hex) {
  return new (external_bignumber_js_default())((0,util_namespaceObject.stripHexPrefix)(hex), 16);
}
function BNToHex(bn) {
  return (0,util_namespaceObject.addHexPrefix)(bn.toString(16));
}
function getEtherScanHashLink(txHash, chainId) {
  if (!SUPPORTED_NETWORKS[chainId]) return "";
  return `${SUPPORTED_NETWORKS[chainId].blockExplorerUrl}/tx/${txHash}`;
}
const formatPastTx = params => {
  var _transaction$to;
  const {
    transaction,
    lowerCaseSelectedAddress,
    blockExplorerUrl
  } = params;
  let totalAmountString = "";
  if (transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155) totalAmountString = transaction.symbol;else if (transaction.type === CONTRACT_TYPE_ERC20) totalAmountString = (0,base_controllers_namespaceObject.formatSmallNumbers)(Number.parseFloat(transaction.total_amount), transaction.symbol, true);else totalAmountString = (0,base_controllers_namespaceObject.formatSmallNumbers)(Number.parseFloat(transaction.total_amount), transaction.type_name, true);
  const currencyAmountString = transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155 || transaction.isEtherscan ? "" : (0,base_controllers_namespaceObject.formatSmallNumbers)(Number.parseFloat(transaction.currency_amount), transaction.selected_currency, true);
  const finalObject = {
    id: transaction.created_at.toString(),
    date: new Date(transaction.created_at).toString(),
    from: transaction.from,
    from_aa_address: transaction.from_aa_address,
    slicedFrom: typeof transaction.from === "string" ? (0,base_controllers_namespaceObject.addressSlicer)(transaction.from) : "",
    to: transaction.to,
    slicedTo: typeof transaction.to === "string" ? (0,base_controllers_namespaceObject.addressSlicer)(transaction.to) : "",
    action: lowerCaseSelectedAddress === ((_transaction$to = transaction.to) === null || _transaction$to === void 0 ? void 0 : _transaction$to.toLowerCase()) || "" ? base_controllers_namespaceObject.ACTIVITY_ACTION_RECEIVE : base_controllers_namespaceObject.ACTIVITY_ACTION_SEND,
    totalAmount: transaction.total_amount,
    totalAmountString,
    currencyAmount: transaction.currency_amount,
    currencyAmountString,
    amount: `${totalAmountString} / ${currencyAmountString}`,
    status: transaction.status,
    etherscanLink: blockExplorerUrl ? `${blockExplorerUrl}/tx/${transaction.transaction_hash}` : "",
    chainId: transaction.chain_id,
    ethRate: Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.total_amount) && Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.currency_amount) ? `1 ${transaction.symbol} = ${(0,base_controllers_namespaceObject.significantDigits)(Number.parseFloat(transaction.currency_amount) / Number.parseFloat(transaction.total_amount))}` : "",
    currencyUsed: transaction.selected_currency,
    type: transaction.type,
    type_name: transaction.type_name,
    type_image_link: transaction.type_image_link,
    transaction_hash: transaction.transaction_hash,
    transaction_category: transaction.transaction_category,
    isEtherscan: transaction.isEtherscan,
    input: transaction.input || "",
    token_id: transaction.token_id || "",
    contract_address: transaction.contract_address || "",
    nonce: transaction.nonce || "",
    is_cancel: !!transaction.is_cancel || false,
    gas: transaction.gas || "",
    gasPrice: transaction.gasPrice || ""
  };
  return finalObject;
};

/**
 * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt
 */
const getEthTxStatus = async (hash, provider) => {
  try {
    const result = await provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
      params: [hash]
    });
    if (result === null) return base_controllers_namespaceObject.TransactionStatus.submitted;
    if (result && result.status === "0x1") return base_controllers_namespaceObject.TransactionStatus.confirmed;
    if (result && result.status === "0x0") return base_controllers_namespaceObject.TransactionStatus.rejected;
    return undefined;
  } catch (err) {
    external_loglevel_default().warn("unable to fetch transaction status", err);
    return undefined;
  }
};
function formatDate(inputDate) {
  const monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const date = new Date(inputDate);
  const day = date.getDate();
  const month = monthList[date.getMonth()];
  const year = date.getFullYear();
  return `${day} ${month} ${year}`;
}
function formatTime(time) {
  return new Date(time).toTimeString().slice(0, 8);
}
const idleTimeTracker = (activityThresholdTime => {
  let isIdle = false;
  let idleTimeout = null;
  const resetTimer = () => {
    if (idleTimeout) {
      window.clearTimeout(idleTimeout);
    }
    isIdle = false;
    idleTimeout = window.setTimeout(() => {
      isIdle = true;
    }, activityThresholdTime * 1000);
  };
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    window.addEventListener("load", resetTimer);
    document.addEventListener("mousemove", resetTimer);
    document.addEventListener("keydown", resetTimer);
  }
  function checkIfIdle() {
    return isIdle;
  }
  return {
    checkIfIdle
  };
})(60 * 3);
function isAddressByChainId(address, _chainId) {
  // TOOD: add rsk network checks.
  return (0,util_namespaceObject.isValidAddress)(address);
}
function toChecksumAddressByChainId(address, chainId) {
  // TOOD: add rsk network checks.
  if (!isAddressByChainId(address, chainId)) return address;
  return (0,util_namespaceObject.toChecksumAddress)(address);
}
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0,util_namespaceObject.addHexPrefix)(21000 .toString(16)),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0,util_namespaceObject.addHexPrefix)(100000 .toString(16))
};
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new (external_bignumber_js_default())(a, 10).lt(b, 10);
}
const getIpfsEndpoint = path => `https://infura-ipfs.io/${path}`;
function sanitizeNftMetdataUrl(url) {
  let finalUri = url;
  if (url !== null && url !== void 0 && url.startsWith("ipfs")) {
    const ipfsPath = url.split("ipfs://")[1];
    finalUri = getIpfsEndpoint(ipfsPath);
  }
  return finalUri;
}
function getChainType(chainId) {
  if (chainId === MAINNET_CHAIN_ID) {
    return "mainnet";
  } else if (TEST_CHAINS.includes(chainId)) {
    return "testnet";
  }
  return "custom";
}
const addEtherscanTransactions = async params => {
  const {
    txn,
    lowerCaseSelectedAddress,
    provider,
    chainId,
    blockExplorerUrl
  } = params;
  const transactionPromises = await Promise.all(txn.map(async tx => {
    var _SUPPORTED_NETWORKS$c, _SUPPORTED_NETWORKS$c2;
    const {
      category,
      type
    } = await determineTransactionType(objectSpread2_default()(objectSpread2_default()({}, tx), {}, {
      data: tx.input
    }), provider);
    tx.transaction_category = tx.transaction_category || category;
    tx.type_image_link = ((_SUPPORTED_NETWORKS$c = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c === void 0 ? void 0 : _SUPPORTED_NETWORKS$c.logo) || "";
    tx.type_name = (_SUPPORTED_NETWORKS$c2 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c2 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c2.ticker;
    tx.type = type;
    return tx;
  }));
  const finalTxs = transactionPromises.reduce((accumulator, x) => {
    var _SUPPORTED_NETWORKS$c3, _SUPPORTED_NETWORKS$c4;
    let totalAmountString = x.value ? new (external_bignumber_js_default())(x.value).div(new (external_bignumber_js_default())(10).pow(new (external_bignumber_js_default())(x.tokenDecimal || 18))).toString() : "";
    let type = CONTRACT_TYPE_ETH;
    if (x.contractAddress !== "") {
      if (x.tokenID) {
        type = x.tokenValue ? CONTRACT_TYPE_ERC1155 : CONTRACT_TYPE_ERC721;
      } else {
        type = CONTRACT_TYPE_ERC20;
      }
    }
    if (type === CONTRACT_TYPE_ERC1155) {
      totalAmountString = x.tokenValue;
    }
    const etherscanTransaction = {
      type,
      type_image_link: x.type_image_link || "n/a",
      type_name: x.tokenName || ((_SUPPORTED_NETWORKS$c3 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c3 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c3.ticker) || "n/a",
      symbol: x.tokenSymbol || ((_SUPPORTED_NETWORKS$c4 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c4 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c4.ticker),
      token_id: x.tokenID || "",
      total_amount: totalAmountString,
      created_at: new Date(Number(x.timeStamp) * 1000),
      from: x.from,
      to: x.to,
      transaction_hash: x.hash,
      status: x.txreceipt_status && x.txreceipt_status === "0" ? base_controllers_namespaceObject.TransactionStatus.failed : base_controllers_namespaceObject.TransactionStatus.confirmed,
      isEtherscan: true,
      input: x.input,
      contract_address: x.contractAddress,
      transaction_category: x.transaction_category,
      gas: `0x${new (external_bignumber_js_default())(x.gasUsed || 0, 10).toString(16)}`,
      gasPrice: `0x${new (external_bignumber_js_default())(x.gasPrice || 0, 10).toString(16)}`,
      chain_id: chainId,
      currency_amount: "",
      nonce: x.nonce,
      from_aa_address: "",
      is_cancel: false,
      selected_currency: ""
    };
    accumulator.push(formatPastTx({
      transaction: etherscanTransaction,
      lowerCaseSelectedAddress,
      blockExplorerUrl
    }));
    return accumulator;
  }, []);
  return finalTxs;
};
;// CONCATENATED MODULE: ./src/Block/PollingBlockTracker.ts



const DEFAULT_POLLING_INTERVAL = 20;
const DEFAULT_RETRY_TIMEOUT = 2;
const SEC = 1000;
class PollingBlockTracker extends base_controllers_namespaceObject.BaseBlockTracker {
  constructor({
    config,
    state = {}
  }) {
    if (!config.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }
    super({
      config,
      state
    });
    const pollingInterval = config.pollingInterval || DEFAULT_POLLING_INTERVAL;
    const retryTimeout = config.retryTimeout || DEFAULT_RETRY_TIMEOUT;

    // merge default + provided config.
    this.defaultConfig = {
      provider: config.provider,
      pollingInterval: pollingInterval * SEC,
      retryTimeout: retryTimeout * SEC,
      setSkipCacheFlag: config.setSkipCacheFlag || false
    };
    this.initialize();
  }
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return this.getLatestBlock();
  }

  // overrides the BaseBlockTracker._start method.
  _start() {
    this._synchronize().catch(err => this.emit("error", err));
  }
  async _synchronize() {
    while (this.state._isRunning) {
      if (idleTimeTracker.checkIfIdle()) return;
      try {
        await this._updateLatestBlock();
        await (0,base_controllers_namespaceObject.timeout)(this.config.pollingInterval);
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          external_loglevel_default().error(newErr);
        }
        await (0,base_controllers_namespaceObject.timeout)(this.config.retryTimeout);
      }
    }
  }
  async _updateLatestBlock() {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    try {
      const block = await this.config.provider.request({
        method: "eth_getBlockByNumber",
        params: ["latest", false]
      });
      return {
        blockHash: block.hash,
        idempotencyKey: block.number,
        timestamp: block.timestamp,
        baseFeePerGas: block.baseFeePerGas,
        gasLimit: block.gasLimit
      };
    } catch (error) {
      external_loglevel_default().error("Polling Block Tracker: ", error);
      throw new Error(`PollingBlockTracker - encountered error fetching block:\n${error.message}`);
    }
  }
}
/* harmony default export */ const Block_PollingBlockTracker = (PollingBlockTracker);
;// CONCATENATED MODULE: external "@toruslabs/http-helpers"
const http_helpers_namespaceObject = require("@toruslabs/http-helpers");
;// CONCATENATED MODULE: ./src/Currency/CurrencyController.ts






class CurrencyController extends base_controllers_namespaceObject.BaseCurrencyController {
  constructor({
    config,
    state,
    onNetworkChanged
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "conversionInterval", void 0);
    this.defaultState = objectSpread2_default()(objectSpread2_default()({}, this.defaultState), {}, {
      commonDenomination: "USD",
      commonDenominatorPrice: 0
    });
    this.initialize();
    onNetworkChanged(networkState => {
      // to be called as (listener) => this.networkController.on('networkDidChange', listener);
      if (networkState.providerConfig.ticker.toUpperCase() !== this.state.nativeCurrency.toUpperCase()) {
        this.setNativeCurrency(networkState.providerConfig.ticker);
        this.updateConversionRate();
      }
    });
  }
  setCommonDenomination(commonDenomination) {
    this.update({
      commonDenomination
    });
  }
  getCommonDenomination() {
    return this.state.commonDenomination;
  }
  setCommonDenominatorPrice(commonDenominatorPrice) {
    this.update({
      commonDenominatorPrice
    });
  }
  getCommonDenominatorPrice() {
    return this.state.commonDenominatorPrice;
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  scheduleConversionInterval() {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateConversionRate();
      }
    }, this.config.pollInterval);
  }

  /**
   * Updates the conversionRate and conversionDate properties associated with the currentCurrency. Updated info is
   * fetched from an external API
   */
  async updateConversionRate() {
    const currentCurrency = this.getCurrentCurrency();
    const nativeCurrency = this.getNativeCurrency();
    const commonDenomination = this.getCommonDenomination();
    const conversionRate = await this.retrieveConversionRate(nativeCurrency, currentCurrency, commonDenomination);
    const currentCurrencyRate = Number.parseFloat(conversionRate[currentCurrency.toUpperCase()]);
    const commonDenominationRate = Number.parseFloat(conversionRate[commonDenomination.toUpperCase()]);
    // set conversion rate
    if (currentCurrencyRate || commonDenominationRate) {
      // ETC
      this.setConversionRate(currentCurrencyRate);
      this.setConversionDate(Math.floor(Date.now() / 1000).toString());
      if (currentCurrency.toUpperCase() === commonDenomination.toUpperCase()) {
        this.setCommonDenominatorPrice(currentCurrencyRate);
      } else {
        this.setCommonDenominatorPrice(commonDenominationRate);
      }
    } else {
      this.setConversionRate(0);
      this.setConversionDate("N/A");
    }
  }
  async retrieveConversionRate(fromCurrency, toCurrency, commonDenomination) {
    try {
      let apiUrl = `${this.config.api}/currency?fsym=${fromCurrency.toUpperCase()}&tsyms=${toCurrency.toUpperCase()}`;
      if (commonDenomination && commonDenomination.toUpperCase() !== toCurrency.toUpperCase()) {
        apiUrl += `,${commonDenomination.toUpperCase()}`;
      }
      const parsedResponse = await (0,http_helpers_namespaceObject.get)(apiUrl);
      return parsedResponse;
    } catch (error) {
      external_loglevel_default().error(error, `CurrencyController - updateCommonDenominatorPrice: Failed to query rate for currency: ${fromCurrency}/ ${toCurrency}`);
    }
    return {
      [toCurrency.toUpperCase()]: "0",
      [commonDenomination.toUpperCase()]: "0"
    };
  }
}
;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectDestructuringEmpty"
const objectDestructuringEmpty_namespaceObject = require("@babel/runtime/helpers/objectDestructuringEmpty");
var objectDestructuringEmpty_default = /*#__PURE__*/__webpack_require__.n(objectDestructuringEmpty_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectWithoutProperties"
const objectWithoutProperties_namespaceObject = require("@babel/runtime/helpers/objectWithoutProperties");
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties_namespaceObject);
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: ./src/utils/conversionUtils.ts



const _excluded = ["aBase", "bBase"],
  _excluded2 = ["aBase", "bBase"],
  _excluded3 = ["multiplicandBase", "multiplierBase"];
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* Currency Conversion Utility
 * This utility function can be used for converting currency related values within metamask.
 * The caller should be able to pass it a value, along with information about the value's
 * numeric base, denomination and currency, and the desired numeric base, denomination and
 * currency. It should return a single value.
 *
 * @param {(number | string | BN)} value - The value to convert.
 * @param {Object} [options] - Options to specify details of the conversion
 * @param {string} [options.fromCurrency = 'ETH' | 'USD'] - The currency of the passed value
 * @param {string} [options.toCurrency = 'ETH' | 'USD'] - The desired currency of the result
 * @param {string} [options.fromNumericBase = 'hex' | 'dec' | 'BN'] - The numeric basic of the passed value.
 * @param {string} [options.toNumericBase = 'hex' | 'dec' | 'BN'] - The desired numeric basic of the result.
 * @param {string} [options.fromDenomination = 'WEI'] - The denomination of the passed value
 * @param {string} [options.numberOfDecimals] - The desired number of decimals in the result
 * @param {string} [options.roundDown] - The desired number of decimals to round down to
 * @param {number} [options.conversionRate] - The rate to use to make the fromCurrency -> toCurrency conversion
 * @returns {(number | string | BN)}
 *
 * The utility passes value along with the options as a single object to the `converter` function.
 * `converter` conditional modifies the supplied `value` property, depending
 * on the accompanying options.
 */





// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new (external_bignumber_js_default())("1000000000000000000");
const BIG_NUMBER_GWEI_MULTIPLIER = new (external_bignumber_js_default())("1000000000");
const BIG_NUMBER_ETH_MULTIPLIER = new (external_bignumber_js_default())("1");
// Setter Maps
const toBigNumber = {
  hex: n => new (external_bignumber_js_default())((0,util_namespaceObject.stripHexPrefix)(n), 16),
  dec: n => new (external_bignumber_js_default())(String(n), 10),
  BN: n => new (external_bignumber_js_default())(n.toString(16), 16)
};
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, (external_bignumber_js_default()).ROUND_HALF_UP),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, (external_bignumber_js_default()).ROUND_HALF_UP),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, (external_bignumber_js_default()).ROUND_HALF_UP)
};
const baseChange = {
  hex: n => n.toString(16),
  dec: n => new (external_bignumber_js_default())(n).toString(10),
  BN: n => new (external_bn_js_default())(n.toString(16))
};

// Utility function for checking base types
const isValidBase = base => Number.isInteger(base) && base > 1;

/**
 * Utility method to convert a value between denominations, formats and currencies.
 */
const converter = ({
  value,
  fromNumericBase,
  fromDenomination,
  fromCurrency,
  toNumericBase,
  toDenomination,
  toCurrency,
  numberOfDecimals,
  conversionRate,
  invertConversionRate,
  roundDown
}) => {
  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (fromCurrency !== toCurrency) {
    if (conversionRate === null || conversionRate === undefined) {
      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
    }
    let rate = toBigNumber.dec(conversionRate);
    if (invertConversionRate) {
      rate = new (external_bignumber_js_default())(1).div(conversionRate);
    }
    convertedValue = convertedValue.times(rate);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, (external_bignumber_js_default()).ROUND_HALF_DOWN);
  }
  if (roundDown) {
    convertedValue = convertedValue.dp(roundDown, (external_bignumber_js_default()).ROUND_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
const conversionUtil = (value, {
  fromCurrency = null,
  toCurrency = fromCurrency,
  fromNumericBase,
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals,
  conversionRate,
  invertConversionRate
}) => {
  if (fromCurrency !== toCurrency && !conversionRate) {
    return 0;
  }
  return converter({
    fromCurrency,
    toCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
    value
  });
};
const getBigNumber = (value, base) => {
  if (!isValidBase(base)) {
    throw new Error("Must specificy valid base");
  }

  // We don't include 'number' here, because BigNumber will throw if passed
  // a number primitive it considers unsafe.
  if (typeof value === "string" || value instanceof (external_bignumber_js_default())) {
    return new (external_bignumber_js_default())(value, base);
  }
  return new (external_bignumber_js_default())(String(value), base);
};
const addCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = objectWithoutProperties_default()(options, _excluded);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).plus(getBigNumber(b, bBase));
  return converter(objectSpread2_default()({
    value
  }, conversionOptions));
};
const subtractCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = objectWithoutProperties_default()(options, _excluded2);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));
  return converter(objectSpread2_default()({
    value
  }, conversionOptions));
};
const multiplyCurrencies = (a, b, options = {}) => {
  const {
      multiplicandBase,
      multiplierBase
    } = options,
    conversionOptions = objectWithoutProperties_default()(options, _excluded3);
  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
    throw new Error("Must specify valid multiplicandBase and multiplierBase");
  }
  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));
  return converter(objectSpread2_default()({
    value
  }, conversionOptions));
};
const conversionGreaterThan = (_ref, _ref2) => {
  let secondProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref2), _ref2));
  let firstProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref), _ref));
  const firstValue = converter(objectSpread2_default()({}, firstProps));
  const secondValue = converter(objectSpread2_default()({}, secondProps));
  return firstValue.gt(secondValue);
};
const conversionLessThan = (_ref3, _ref4) => {
  let secondProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref4), _ref4));
  let firstProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref3), _ref3));
  const firstValue = converter(objectSpread2_default()({}, firstProps));
  const secondValue = converter(objectSpread2_default()({}, secondProps));
  return firstValue.lt(secondValue);
};
const conversionMax = (_ref5, _ref6) => {
  let secondProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref6), _ref6));
  let firstProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref5), _ref5));
  const firstIsGreater = conversionGreaterThan(objectSpread2_default()({}, firstProps), objectSpread2_default()({}, secondProps));
  return firstIsGreater ? firstProps.value : secondProps.value;
};
const conversionGTE = (_ref7, _ref8) => {
  let secondProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref8), _ref8));
  let firstProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref7), _ref7));
  const firstValue = converter(objectSpread2_default()({}, firstProps));
  const secondValue = converter(objectSpread2_default()({}, secondProps));
  return firstValue.isGreaterThanOrEqualTo(secondValue);
};
const conversionLTE = (_ref9, _ref10) => {
  let secondProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref10), _ref10));
  let firstProps = Object.assign({}, (objectDestructuringEmpty_default()(_ref9), _ref9));
  const firstValue = converter(objectSpread2_default()({}, firstProps));
  const secondValue = converter(objectSpread2_default()({}, secondProps));
  return firstValue.isLessThanOrEqualTo(secondValue);
};
const toNegative = (n, options = {}) => multiplyCurrencies(n, -1, options);
const decGWEIToHexWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
};
const hexWEIToDecGWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
};
;// CONCATENATED MODULE: ./src/Gas/gasUtil.ts





function normalizeGWEIDecimalNumbers(n) {
  const numberAsWEIHex = decGWEIToHexWEI(new (external_bignumber_js_default())(n));
  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);
  return numberAsGWEI;
}
async function gasUtil_fetchGasEstimates(url) {
  const estimates = await (0,http_helpers_namespaceObject.get)(url);
  const normalizedEstimates = {
    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee).toString(10),
    low: objectSpread2_default()(objectSpread2_default()({}, estimates.low), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas).toString(10)
    }),
    medium: objectSpread2_default()(objectSpread2_default()({}, estimates.medium), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas).toString(10)
    }),
    high: objectSpread2_default()(objectSpread2_default()({}, estimates.high), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas).toString(10)
    })
  };
  return normalizedEstimates;
}
async function gasUtil_fetchGasEstimatesViaEthFeeHistory(provider) {
  const noOfBlocks = 10;
  const newestBlock = "latest";
  // get the 10, 50 and 95th percentile of the tip fees from the last 10 blocks
  const percentileValues = [10, 50, 95];
  const feeHistory = await provider.request({
    method: "eth_feeHistory",
    params: [noOfBlocks, newestBlock, percentileValues]
  });
  // this is in hex wei
  const finalBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];
  // this is in hex wei
  const priorityFeeCalcs = feeHistory.reward.reduce((acc, curr) => {
    return {
      slow: acc.slow.plus(new (external_bignumber_js_default())(curr[0], 16)),
      average: acc.average.plus(new (external_bignumber_js_default())(curr[1], 16)),
      fast: acc.fast.plus(new (external_bignumber_js_default())(curr[2], 16))
    };
  }, {
    slow: new (external_bignumber_js_default())(0),
    average: new (external_bignumber_js_default())(0),
    fast: new (external_bignumber_js_default())(0)
  });
  return {
    estimatedBaseFee: hexWEIToDecGWEI(finalBaseFeePerGas).toString(10),
    high: {
      maxWaitTimeEstimate: 30000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.toString(16)).toString()
    },
    medium: {
      maxWaitTimeEstimate: 45000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.toString(16)).toString()
    },
    low: {
      maxWaitTimeEstimate: 60000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.toString(16)).toString()
    }
  };
}

/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 */
async function gasUtil_fetchLegacyGasPriceEstimates(url) {
  const result = await (0,http_helpers_namespaceObject.get)(url, {
    referrer: url,
    referrerPolicy: "no-referrer-when-downgrade",
    method: "GET"
  });
  // this returns decimal gwei
  return {
    low: result.SafeGasPrice,
    medium: result.ProposeGasPrice,
    high: result.FastGasPrice
  };
}
async function gasUtil_fetchEthGasPriceEstimate(provider) {
  const gasPrice = await provider.request({
    method: METHOD_TYPES.ETH_GET_GAS_PRICE
  });
  return {
    gasPrice: hexWEIToDecGWEI(gasPrice).toString()
  };
}
function calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {
  // all are in dec gwei
  const {
    low,
    medium,
    high,
    estimatedBaseFee
  } = gasFeeEstimates;
  const maxPriorityFeePerGasInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(maxPriorityFeePerGas)), 16);
  const maxFeePerGasInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(maxFeePerGas)), 16);
  const estimatedBaseFeeInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(estimatedBaseFee)), 16);
  const effectiveMaxPriorityFee = external_bignumber_js_default().min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.minus(estimatedBaseFeeInWEI));
  const lowMaxPriorityFeeInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(low.suggestedMaxPriorityFeePerGas)), 16);
  const mediumMaxPriorityFeeInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(medium.suggestedMaxPriorityFeePerGas)), 16);
  const highMaxPriorityFeeInWEI = new (external_bignumber_js_default())(decGWEIToHexWEI(new (external_bignumber_js_default())(high.suggestedMaxPriorityFeePerGas)), 16);
  let lowerTimeBound;
  let upperTimeBound;
  if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {
    lowerTimeBound = null;
    upperTimeBound = "unknown";
  } else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {
    lowerTimeBound = low.minWaitTimeEstimate;
    upperTimeBound = low.maxWaitTimeEstimate;
  } else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {
    lowerTimeBound = medium.minWaitTimeEstimate;
    upperTimeBound = medium.maxWaitTimeEstimate;
  } else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {
    lowerTimeBound = high.minWaitTimeEstimate;
    upperTimeBound = high.maxWaitTimeEstimate;
  } else {
    lowerTimeBound = 0;
    upperTimeBound = high.maxWaitTimeEstimate;
  }
  return {
    lowerTimeBound,
    upperTimeBound
  };
}
;// CONCATENATED MODULE: ./src/Gas/GasFeeController.ts







const GAS_FEE_API = "https://mock-gas-server.herokuapp.com/";
const LEGACY_GAS_PRICES_API_URL = "https://api.metaswap.codefi.network/gasPrices";
/**
 * Returns gas prices in dec gwei
 */
class GasFeeController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    getProvider,
    fetchGasEstimates = gasUtil_fetchGasEstimates,
    fetchEthGasPriceEstimate = gasUtil_fetchEthGasPriceEstimate,
    fetchLegacyGasPriceEstimates = gasUtil_fetchLegacyGasPriceEstimates,
    fetchGasEstimatesViaEthFeeHistory = gasUtil_fetchGasEstimatesViaEthFeeHistory,
    getCurrentNetworkLegacyGasAPICompatibility,
    getCurrentNetworkEIP1559Compatibility,
    getCurrentAccountEIP1559Compatibility,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "name", "GasFeeController");
    // https://0x.org/docs/introduction/0x-cheat-sheet#swap-api-endpoints
    defineProperty_default()(this, "API_SUPPORTED_CHAINIDS", new Set(["0x1", "0x5", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"]));
    defineProperty_default()(this, "intervalId", void 0);
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "currentChainId", void 0);
    defineProperty_default()(this, "getNetworkIdentifier", void 0);
    defineProperty_default()(this, "getProvider", void 0);
    defineProperty_default()(this, "fetchGasEstimates", void 0);
    defineProperty_default()(this, "fetchGasEstimatesViaEthFeeHistory", void 0);
    defineProperty_default()(this, "fetchEthGasPriceEstimate", void 0);
    defineProperty_default()(this, "fetchLegacyGasPriceEstimates", void 0);
    defineProperty_default()(this, "getCurrentNetworkEIP1559Compatibility", void 0);
    defineProperty_default()(this, "getCurrentAccountEIP1559Compatibility", void 0);
    defineProperty_default()(this, "getCurrentNetworkLegacyGasAPICompatibility", void 0);
    this.getNetworkIdentifier = getNetworkIdentifier;
    this.getProvider = getProvider;
    this.fetchGasEstimates = fetchGasEstimates;
    this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
    this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.fetchGasEstimatesViaEthFeeHistory = fetchGasEstimatesViaEthFeeHistory;
    this.defaultConfig = {
      interval: 30000,
      legacyAPIEndpoint: LEGACY_GAS_PRICES_API_URL,
      EIP1559APIEndpoint: GAS_FEE_API
    };
    this.defaultState = {
      gasFeeEstimates: {},
      estimatedGasFeeTimeBounds: {},
      gasEstimateType: GAS_ESTIMATE_TYPES.NONE
    };
    // Initialize.
    this.currentChainId = this.getNetworkIdentifier();
    this.provider = this.getProvider();
    this.initialize();
    onNetworkStateChange(() => {
      this.onNetworkStateChange();
    });
  }
  async onNetworkStateChange() {
    this.provider = this.getProvider();
    const newChainId = this.getNetworkIdentifier();
    if (this.currentChainId !== newChainId) {
      this.currentChainId = newChainId;
      await this.fetchGasFeeEstimates();
    }
  }
  async resetPolling() {
    this.stopPolling();
    await this.getGasFeeEstimatesAndStartPolling();
  }
  async fetchGasFeeEstimates() {
    return this._fetchGasFeeEstimateData();
  }
  async getGasFeeEstimatesAndStartPolling() {
    await this._fetchGasFeeEstimateData();
    this._startPolling();
  }
  disconnectPoller() {
    this.stopPolling();
  }

  /**
   * Prepare to discard this controller.
   *
   * This stops any active polling.
   */
  destroy() {
    this.stopPolling();
  }
  stopPolling() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
    this.resetState();
  }

  /**
   * Gets and sets gasFeeEstimates in state
   *
   * @returns GasFeeEstimates
   */
  async _fetchGasFeeEstimateData() {
    let isEIP1559Compatible;
    const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
    const chainId = this.getNetworkIdentifier();
    if (chainId === "loading") return;
    let chainIdInt;
    if (typeof chainId === "string" && (0,util_namespaceObject.isHexString)((0,util_namespaceObject.addHexPrefix)(chainId))) {
      chainIdInt = Number.parseInt(chainId, 16);
    }
    try {
      isEIP1559Compatible = await this.getEIP1559Compatibility();
      external_loglevel_default().info("eip1559 compatible", isEIP1559Compatible);
    } catch (error) {
      external_loglevel_default().warn(error);
      isEIP1559Compatible = false;
    }
    let newState = (0,base_controllers_namespaceObject.cloneDeep)(this.defaultState);
    try {
      if (isEIP1559Compatible) {
        let estimates;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(chainId)) {
            estimates = await this.fetchGasEstimates(this.config.EIP1559APIEndpoint.replace("<chain_id>", `${chainIdInt}`));
          } else {
            throw new Error("ChainId not supported by api");
          }
        } catch (error) {
          estimates = await this.fetchGasEstimatesViaEthFeeHistory(this.provider);
        }
        const {
          suggestedMaxPriorityFeePerGas,
          suggestedMaxFeePerGas
        } = estimates.medium;
        const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
        };
      } else if (isLegacyGasAPICompatible) {
        const estimates = await this.fetchLegacyGasPriceEstimates(this.config.legacyAPIEndpoint.replace("<chain_id>", `${chainIdInt}`));
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
        };
      } else {
        throw new Error("Main gas fee/price estimation failed. Use fallback");
      }
    } catch {
      try {
        const estimates = await this.fetchEthGasPriceEstimate(this.provider);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
        };
      } catch (error) {
        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
      }
    }
    this.update(newState);
    return newState;
  }
  async _startPolling() {
    this._poll();
  }
  async _poll() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
    }
    this.intervalId = window.setInterval(async () => {
      if (!idleTimeTracker.checkIfIdle()) {
        await this._fetchGasFeeEstimateData();
      }
    }, this.config.interval);
  }
  resetState() {
    this.update((0,base_controllers_namespaceObject.cloneDeep)(this.defaultState));
  }
  async getEIP1559Compatibility() {
    var _this$getCurrentAccou, _this$getCurrentAccou2;
    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility();
    const currentAccountIsEIP1559Compatible = (_this$getCurrentAccou = (_this$getCurrentAccou2 = this.getCurrentAccountEIP1559Compatibility) === null || _this$getCurrentAccou2 === void 0 ? void 0 : _this$getCurrentAccou2.call(this)) !== null && _this$getCurrentAccou !== void 0 ? _this$getCurrentAccou : true;
    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
  }
  getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
    if (!this.state.gasFeeEstimates || this.state.gasEstimateType !== GAS_ESTIMATE_TYPES.FEE_MARKET) {
      return {};
    }
    return calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
  }
}
;// CONCATENATED MODULE: external "@metamask/eth-sig-util"
const eth_sig_util_namespaceObject = require("@metamask/eth-sig-util");
;// CONCATENATED MODULE: ./src/Keyring/KeyringController.ts



class KeyringController extends base_controllers_namespaceObject.BaseKeyringController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    this.defaultState = {
      wallets: []
    };
    this.initialize();
  }
  async signTransaction(tx, address) {
    const txPayload = tx;
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const signedTx = txPayload.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }
  getAccounts() {
    return this.state.wallets.map(w => w.publicKey);
  }
  importAccount(accountPrivateKey) {
    const hexPrivateKey = accountPrivateKey.padStart(64, "0");
    const bufferPrivKey = Buffer.from(hexPrivateKey, "hex");
    const publicKey = (0,util_namespaceObject.bytesToHex)((0,util_namespaceObject.privateToPublic)(bufferPrivKey));
    const address = (0,util_namespaceObject.toChecksumAddress)((0,util_namespaceObject.bytesToHex)((0,util_namespaceObject.privateToAddress)(bufferPrivKey)));
    const existingWallet = this.state.wallets.find(w => w.address === address);
    if (existingWallet) return existingWallet.address;
    this.update({
      wallets: [...this.state.wallets, {
        publicKey,
        privateKey: accountPrivateKey,
        address
      }]
    });
    return address;
  }
  removeAccount(address) {
    const newWallets = [...this.state.wallets];
    const idx = newWallets.findIndex(w => w.address === address);
    if (idx !== -1) {
      newWallets.splice(idx, 1);
      this.update({
        wallets: newWallets
      });
    }
  }
  getBufferPrivateKey(privateKey) {
    const stripped = (0,util_namespaceObject.stripHexPrefix)(privateKey);
    return Buffer.from(stripped, "hex");
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const messageSig = (0,util_namespaceObject.ecsign)(Buffer.from((0,util_namespaceObject.stripHexPrefix)(data), "hex"), privKey);
    const sig = (0,eth_sig_util_namespaceObject.concatSig)(Buffer.from((0,util_namespaceObject.bigIntToBytes)(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));
    return sig;
  }

  // For personal_sign, we need to prefix the message: ensure input is hashed and not buffer of utf-8
  async signPersonalMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const sig = (0,eth_sig_util_namespaceObject.personalSign)({
      privateKey: privKey,
      data
    });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(typedData, address, version) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    return (0,eth_sig_util_namespaceObject.signTypedData)({
      privateKey: privKey,
      data: typedData,
      version
    });
  }
  signEncryptionPublicKey(address) {
    const wallet = this._getWalletForAccount(address);
    return (0,eth_sig_util_namespaceObject.getEncryptionPublicKey)((0,util_namespaceObject.stripHexPrefix)(wallet.privateKey));
  }
  decryptMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    return (0,eth_sig_util_namespaceObject.decrypt)({
      encryptedData: data,
      privateKey: (0,util_namespaceObject.stripHexPrefix)(wallet.privateKey)
    });
  }
  _getWalletForAccount(account) {
    const address = account.toLowerCase();
    const wallet = this.state.wallets.find(w => w.address.toLowerCase() === address);
    if (!wallet) throw new Error("Torus Keyring - Unable to find matching address.");
    return wallet;
  }
}
;// CONCATENATED MODULE: ./src/Message/AbstractMessageController.ts




class AbstractMessageController extends base_controllers_namespaceObject.BaseController {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   */
  constructor({
    config,
    state,
    getNetworkIdentifier
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "messages", void 0);
    defineProperty_default()(this, "getNetworkIdentifier", void 0);
    this.defaultState = {
      unapprovedMessages: {},
      unapprovedMessagesCount: 0
    };
    this.messages = [];
    this.defaultConfig = {};
    this.getNetworkIdentifier = getNetworkIdentifier;
    super.initialize();
  }
  getMessage(messageId) {
    return this.messages.find(message => message.id === messageId);
  }
  getAllMessages() {
    return this.messages;
  }
  setMetadata(messageId, metadata) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.metadata = metadata;
    this.updateMessage(message);
  }
  getUnapprovedMessages() {
    return this.messages.filter(message => message.status === MessageStatus.UNAPPROVED).reduce((result, message) => {
      result[message.id] = message;
      return result;
    }, {});
  }
  async addMessage(message) {
    this.messages.push(message);
    this.saveMessageList();
  }
  approveMessage(messageId, messageParams) {
    this.setMessageStatus(messageId, MessageStatus.APPROVED);
    return this.prepMessageForSigning(messageParams);
  }
  setMessageStatus(messageId, status) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.status = status;
    this.updateMessage(message);
    this.emit(`${messageId}:${status}`, message);
    if (status === MessageStatus.REJECTED || status === MessageStatus.SIGNED || status === MessageStatus.FAILED) {
      this.emit(`${messageId}:finished`, message);
    }
  }
  async waitForFinishStatus(msgParams, messageName) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === MessageStatus.REJECTED) {
          return reject(openlogin_jrpc_namespaceObject.providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));
        }
        if (msg.status === MessageStatus.FAILED) {
          return reject(openlogin_jrpc_namespaceObject.rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === MessageStatus.SIGNED) {
          return resolve(msg.rawSig);
        }
        return reject(openlogin_jrpc_namespaceObject.rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
      };
      this.once(`${msgParams.id}:finished`, handleFinished);
    });
  }
  updateMessage(message) {
    const index = this.messages.findIndex(msg => message.id === msg.id);
    if (index !== -1) {
      this.messages[index] = message;
    }
    this.saveMessageList();
  }
  saveMessageList() {
    const unapprovedMessages = this.getUnapprovedMessages();
    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;
    this.update({
      unapprovedMessages,
      unapprovedMessagesCount
    });
  }
}
;// CONCATENATED MODULE: ./src/Message/utils.ts



const hexRe = /^[0-9A-Fa-f]+$/gu;
function validateAddress(address, propertyName) {
  if (!address || typeof address !== "string" || !(0,util_namespaceObject.isValidAddress)(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}
function validateSignMessageData(messageData) {
  const {
    from,
    data
  } = messageData;
  validateAddress(from, "from");
  if (!data || typeof data !== "string") {
    throw new Error(`Invalid message "data": ${data} must be a valid string.`);
  }
}
function normalizeMessageData(data) {
  try {
    const stripped = (0,util_namespaceObject.stripHexPrefix)(data);
    if (stripped.match(hexRe)) {
      return (0,util_namespaceObject.addHexPrefix)(stripped);
    }
  } catch (e) {}
  return (0,util_namespaceObject.bytesToHex)(Buffer.from(data, "utf8"));
}
function validateTypedSignMessageDataV1(messageData) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || !Array.isArray(messageData.data)) {
    throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
  }
  try {
    // typedSignatureHash will throw if the data is invalid.
    (0,eth_sig_util_namespaceObject.typedSignatureHash)(messageData.data);
  } catch (e) {
    throw new Error(`Expected EIP712 typed data.`);
  }
}
async function validateTypedSignMessageDataV3V4(messageData, currentChainId) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== "object" && typeof messageData.data !== "string") {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }
  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch (e) {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }
  const {
    validate
  } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 731, 23));
  const validation = validate(data, eth_sig_util_namespaceObject.TYPED_MESSAGE_SCHEMA);
  if (validation.errors.length > 0) {
    throw new Error("Data must conform to EIP-712 schema. See https://git.io/fNtcx.");
  }
  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }
  let {
    chainId
  } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }
    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);
    }
    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}
function validateEncryptionPublicKeyMessageData(messageData) {
  const {
    from
  } = messageData;
  validateAddress(from, "from");
}
function validateDecryptedMessageData(messageData) {
  const {
    from
  } = messageData;
  validateAddress(from, "from");
}
function parseDecryptMessageData(data) {
  const stripped = (0,util_namespaceObject.stripHexPrefix)(data);
  const buffer = Buffer.from(stripped, "hex");
  return JSON.parse(buffer.toString("utf8"));
}
async function validateAddChainData(data) {
  const {
    chainId,
    rpcUrls,
    nativeCurrency
  } = data || {};
  if (!chainId) {
    throw new Error("Invalid add chain params: please pass chainId in params");
  }
  if (!(0,external_ethers_namespaceObject.isHexString)(chainId)) {
    throw new Error("Invalid add chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
  if (!rpcUrls || rpcUrls.length === 0) throw new Error("params.rpcUrls not provided");
  if (!nativeCurrency) throw new Error("params.nativeCurrency not provided");
  const {
    name,
    symbol,
    decimals
  } = nativeCurrency;
  if (!name) throw new Error("params.nativeCurrency.name not provided");
  if (!symbol) throw new Error("params.nativeCurrency.symbol not provided");
  if (decimals === undefined) throw new Error("params.nativeCurrency.decimals not provided");
  const _web3 = new external_ethers_namespaceObject.JsonRpcProvider(rpcUrls[0], "any");
  const {
    chainId: networkChainID
  } = await _web3.getNetwork();
  if (Number.parseInt(networkChainID.toString()) !== Number.parseInt(chainId, 16)) {
    throw new Error(`Provided rpc url's chainId version is not matching with provided chainId, expected: ${(0,external_ethers_namespaceObject.toQuantity)(networkChainID)}, received: ${chainId}`);
  }
}
function validateSwitchChainData(data) {
  const {
    chainId
  } = data || {};
  if (!chainId) {
    throw new Error("Invalid switch chain params: please pass chainId in params");
  }
  if (!(0,external_ethers_namespaceObject.isHexString)(chainId)) {
    throw new Error("Invalid switch chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
}
;// CONCATENATED MODULE: ./src/Message/AddChainController.ts







class AddChainController extends AbstractMessageController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    addChain
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "AddChainController");
    defineProperty_default()(this, "addChain", void 0);
    this.addChain = addChain;
    this.initialize();
  }
  async processAddChain(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error("Message not found");
    }
    try {
      await this.approveMessage(messageId, msgObject.messageParams);
      await this.addChain(msgObject.messageParams);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig: JSON.stringify(msgObject.messageParams)
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    // set message params origin first to satisfy the eslint rule (origin won't be checked by validateAddChainData)
    // for "Possible race condition: `messageParams.origin` might be assigned based on an outdated state of `messageParams`"
    if (req) {
      messageParams.origin = req.origin;
    }
    await validateAddChainData(messageParams);
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ADD_CHAIN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}
;// CONCATENATED MODULE: ./src/Message/DecryptMessageController.ts


// import { isValidAddress } from "@ethereumjs/util";





class DecryptMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    decryptMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "DecryptMessageController");
    defineProperty_default()(this, "decryptMessage", void 0);
    this.decryptMessage = decryptMessage;
    this.initialize();
  }
  async processDecryptMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error("Message not found");
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const parsedData = parseDecryptMessageData(cleanMsgParams.data);
      const rawSig = this.decryptMessage(parsedData, cleanMsgParams.from);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateDecryptedMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_DECRYPT
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(objectSpread2_default()({}, messageParams));
  }
}
;// CONCATENATED MODULE: ./src/Message/EncryptionPublicKeyController.ts


// import { isValidAddress } from "@ethereumjs/util";





class EncryptionPublicKeyController extends AbstractMessageController {
  constructor({
    config,
    state,
    signEncryptionPublicKey,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "EncryptionPublicKeyController");
    defineProperty_default()(this, "signEncryptionPublicKey", void 0);
    this.signEncryptionPublicKey = signEncryptionPublicKey;
    this.initialize();
  }
  async processGetEncryptionPublicKey(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const publicKey = this.signEncryptionPublicKey(cleanMsgParams.from);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig: publicKey
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return publicKey;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateEncryptionPublicKeyMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    // From should be the public key for the encryption
    return Promise.resolve(objectSpread2_default()(objectSpread2_default()({}, messageParams), {}, {
      from: messageParams.data
    }));
  }
}
;// CONCATENATED MODULE: ./src/Message/MessageController.ts







class MessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "MessageController");
    defineProperty_default()(this, "signMessage", void 0);
    this.signMessage = signMessage;
    this.initialize();
  }
  async processSignMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const rawSig = await this.signMessage(cleanMsgParams.data, cleanMsgParams.from);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSignMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_SIGN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}
;// CONCATENATED MODULE: ./src/Message/PersonalMessageController.ts







class PersonalMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signPersonalMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "PersonalMessageController");
    defineProperty_default()(this, "signPersonalMessage", void 0);
    this.signPersonalMessage = signPersonalMessage;
    this.initialize();
  }
  async processSignPersonalMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const rawSig = await this.signPersonalMessage(cleanMsgParams.data, cleanMsgParams.from);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSignMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.PERSONAL_SIGN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}
;// CONCATENATED MODULE: ./src/Message/SwitchChainController.ts







class SwitchChainController extends AbstractMessageController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    switchChain
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "SwitchChainController");
    defineProperty_default()(this, "switchChain", void 0);
    this.switchChain = switchChain;
    this.initialize();
  }
  async processSwitchChain(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      await this.approveMessage(messageId, msgObject.messageParams);
      this.switchChain({
        chainId: msgObject.messageParams.chainId
      });
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig: JSON.stringify(msgObject.messageParams)
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSwitchChainData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.SWITCH_CHAIN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}
;// CONCATENATED MODULE: ./src/Message/TypedMessageController.ts








function getMessageType(version) {
  switch (version) {
    case eth_sig_util_namespaceObject.SignTypedDataVersion.V1:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
    case eth_sig_util_namespaceObject.SignTypedDataVersion.V3:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3;
    case eth_sig_util_namespaceObject.SignTypedDataVersion.V4:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4;
    default:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
  }
}
class TypedMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signTypedData,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    defineProperty_default()(this, "name", "TypedMessageController");
    defineProperty_default()(this, "signTypedData", void 0);
    this.signTypedData = signTypedData;
    this.initialize();
  }
  async processSignTypedMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const msgData = cleanMsgParams.version === eth_sig_util_namespaceObject.SignTypedDataVersion.V1 ? cleanMsgParams.data : JSON.parse(cleanMsgParams.data);
      const rawSig = await this.signTypedData(msgData, cleanMsgParams.from, cleanMsgParams.version);
      this.updateMessage(objectSpread2_default()(objectSpread2_default()({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      external_loglevel_default().error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req, version) {
    await this.addUnapprovedMessage(messageParams, req, version);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req, version) {
    if (version === eth_sig_util_namespaceObject.SignTypedDataVersion.V1) {
      validateTypedSignMessageDataV1(messageParams);
    }
    if (version === eth_sig_util_namespaceObject.SignTypedDataVersion.V3 || version === eth_sig_util_namespaceObject.SignTypedDataVersion.V4) {
      const currentChainId = this.getNetworkIdentifier();
      await validateTypedSignMessageDataV3V4(messageParams, currentChainId);
    }
    if (typeof messageParams.data !== "string" && (version === eth_sig_util_namespaceObject.SignTypedDataVersion.V3 || version === eth_sig_util_namespaceObject.SignTypedDataVersion.V4)) {
      messageParams.data = JSON.stringify(messageParams.data);
    }
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.version = version;
    const messageId = messageParams.id || (0,base_controllers_namespaceObject.randomId)();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: getMessageType(version)
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}
;// CONCATENATED MODULE: ./src/Network/createEthereumMiddleware.ts




function createGetAccountsMiddleware({
  getAccounts
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    const accounts = await getAccounts(request);
    response.result = accounts;
  });
}
function createProcessTransactionMiddleware({
  processTransaction
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_TRANSACTION) return next();
    if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");
    response.result = await processTransaction(request.params, request);
  });
}
function createProcessEthSignMessage({
  processEthSignMessage
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN) return next();
    if (!processEthSignMessage) throw new Error("WalletMiddleware - opts.processEthSignMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processEthSignMessage(msgParams, request);
  });
}
function createProcessTypedMessage({
  processTypedMessage
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA) return next();
    if (!processTypedMessage) throw new Error("WalletMiddleware - opts.processTypedMessage not  provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [typedData, address]`);
      const params = request.params;
      const message = typeof params[0] === "string" ? JSON.parse(params[0]) : params[0];
      const address = params[1];
      msgParams = {
        from: address,
        data: message,
        version: eth_sig_util_namespaceObject.SignTypedDataVersion.V1
      };
    }
    response.result = await processTypedMessage(msgParams, request);
  });
}
function createProcessTypedMessageV3({
  processTypedMessageV3
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3) return next();
    if (!processTypedMessageV3) throw new Error("WalletMiddleware - opts.processTypedMessageV3 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message,
        version: eth_sig_util_namespaceObject.SignTypedDataVersion.V3
      };
    }
    response.result = await processTypedMessageV3(msgParams, request);
  });
}
function createProcessTypedMessageV4({
  processTypedMessageV4
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();
    if (!processTypedMessageV4) throw new Error("WalletMiddleware - opts.processTypedMessageV4 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message,
        version: eth_sig_util_namespaceObject.SignTypedDataVersion.V4
      };
    }
    response.result = await processTypedMessageV4(msgParams, request);
  });
}
function createProcessPersonalMessage({
  processPersonalMessage
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.PERSONAL_SIGN) return next();
    if (!processPersonalMessage) throw new Error("WalletMiddleware - opts.processPersonalMessage is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const params = request.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    response.result = await processPersonalMessage(msgParams, request);
  });
}
function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();
    const {
      blockReference
    } = params;
    if (blockReference !== "pending") return next();
    response.result = await getPendingNonce(params, request);
  });
}
function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    txReceipt,
    transaction,
    transactionHash,
    accessList
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = transaction;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash: transactionHash,
    nonce,
    input: data || "0x",
    value: value || "0x0",
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null,
    type: null
  };
  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }
  return formattedTxMeta;
}
function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();
    if (!getPendingTransactionByHash) throw new Error("WalletMiddleware - opts.getPendingTransactionByHash not provided");
    const txMeta = await getPendingTransactionByHash(params, request);
    if (!txMeta) {
      return next();
    }
    response.result = formatTxMetaForRpcResult(txMeta);
    return undefined;
  });
}
function createProcessEncryptionPublicKeyMiddleware({
  processEncryptionPublicKey
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY) return next();
    if (!processEncryptionPublicKey) throw new Error("WalletMiddleware - opts.processEncryptionPublicKey not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address]`);
      const [address] = request.params;
      msgParams = {
        data: address,
        from: address
      };
    }
    response.result = await processEncryptionPublicKey(msgParams, request);
  });
}
function createProcessDecryptMessageMiddleware({
  processDecryptMessage
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_DECRYPT) return next();
    if (!processDecryptMessage) throw new Error("WalletMiddleware - opts.processDecryptMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const [message, address] = request.params;
      msgParams = {
        data: message,
        from: address
      };
    }
    response.result = await processDecryptMessage(msgParams, request);
  });
}
function createProcessSwitchEthereumChain({
  processSwitchEthereumChain
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.SWITCH_CHAIN) return next();
    if (!processSwitchEthereumChain) throw new Error("WalletMiddleware - opts.processSwitchEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processSwitchEthereumChain(msgParams, request);
  });
}
function createProcessAddEthereumChain({
  processAddEthereumChain
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ADD_CHAIN) return next();
    if (!processAddEthereumChain) throw new Error("WalletMiddleware - opts.processAddEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processAddEthereumChain(msgParams, request);
  });
}
function createRequestAccountsMiddleware({
  requestAccounts
}) {
  return (0,openlogin_jrpc_namespaceObject.createAsyncMiddleware)(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "eth_requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createEthereumMiddleware(providerHandlers) {
  const {
    requestAccounts,
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    getPendingNonce,
    getPendingTransactionByHash,
    processEncryptionPublicKey,
    processDecryptMessage,
    processSwitchEthereumChain,
    processAddEthereumChain,
    getProviderState,
    version
  } = providerHandlers;
  return (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([(0,openlogin_jrpc_namespaceObject.createScaffoldMiddleware)({
    version,
    [base_controllers_namespaceObject.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState
  }), createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), createProcessTransactionMiddleware({
    processTransaction
  }), createProcessEthSignMessage({
    processEthSignMessage
  }), createProcessTypedMessage({
    processTypedMessage
  }), createProcessTypedMessageV3({
    processTypedMessageV3
  }), createProcessTypedMessageV4({
    processTypedMessageV4
  }), createProcessPersonalMessage({
    processPersonalMessage
  }), createPendingNonceMiddleware({
    getPendingNonce
  }), createPendingTxMiddleware({
    getPendingTransactionByHash
  }), createProcessEncryptionPublicKeyMiddleware({
    processEncryptionPublicKey
  }), createProcessDecryptMessageMiddleware({
    processDecryptMessage
  }), createProcessSwitchEthereumChain({
    processSwitchEthereumChain
  }), createProcessAddEthereumChain({
    processAddEthereumChain
  })]);
}
;// CONCATENATED MODULE: external "fast-safe-stringify"
const external_fast_safe_stringify_namespaceObject = require("fast-safe-stringify");
var external_fast_safe_stringify_default = /*#__PURE__*/__webpack_require__.n(external_fast_safe_stringify_namespaceObject);
;// CONCATENATED MODULE: ./src/Network/cacheIdentifier.ts

let CacheStrategy = /*#__PURE__*/function (CacheStrategy) {
  CacheStrategy["Block"] = "block";
  CacheStrategy["Fork"] = "fork";
  CacheStrategy["Never"] = "never";
  CacheStrategy["Permanent"] = "perma";
  return CacheStrategy;
}({});
function blockTagParamIndex(method) {
  switch (method) {
    // blockTag is at index 2
    case "eth_getStorageAt":
      return 2;
    // blockTag is at index 1
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    // blockTag is at index 0
    case "eth_getBlockByNumber":
      return 0;
    // there is no blockTag
    default:
      return undefined;
  }
}
function cacheTypeForMethod(method) {
  switch (method) {
    // cache permanently
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return CacheStrategy.Permanent;

    // cache until fork
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return CacheStrategy.Fork;

    // cache for block
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return CacheStrategy.Block;

    // never cache
    default:
      return CacheStrategy.Never;
  }
}
function canCache(method) {
  return cacheTypeForMethod(method) !== CacheStrategy.Never;
}
function paramsWithoutBlockTag(request) {
  if (!request.params) {
    return [];
  }
  const index = blockTagParamIndex(request.method);

  // Block tag param not passed.
  if (index === undefined || !Array.isArray(request.params) || index >= request.params.length) {
    return request.params;
  }

  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
  if (request.method === "eth_getBlockByNumber") {
    return request.params.slice(1);
  }
  return request.params.slice(0, index);
}
function cacheIdentifierForRequest(request, skipBlockRef) {
  var _request$params;
  const simpleParams = skipBlockRef ? paramsWithoutBlockTag(request) : (_request$params = request.params) !== null && _request$params !== void 0 ? _request$params : [];
  if (canCache(request.method)) {
    return `${request.method}:${external_fast_safe_stringify_default()(simpleParams)}`;
  }
  return null;
}
;// CONCATENATED MODULE: ./src/Network/createJsonRpcClient.ts





function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    if (req.method === "net_version") {
      // convert to decimal
      res.result = Number.parseInt(chainId, 16).toString(10);
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig, networkConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = (0,base_controllers_namespaceObject.createFetchMiddleware)({
    rpcTarget
  });
  const blockProvider = (0,openlogin_jrpc_namespaceObject.providerFromMiddleware)(fetchMiddleware);
  const blockTracker = new Block_PollingBlockTracker({
    config: objectSpread2_default()(objectSpread2_default()({}, networkConfig), {}, {
      provider: blockProvider
    }),
    state: {}
  });
  const networkMiddleware = (0,openlogin_jrpc_namespaceObject.mergeMiddleware)([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig),
  // No need for the following middlewares for web because all browser sessions are quite short lived and each session is limited to scope of a window/tab
  // createBlockRefRewriteMiddleware({ blockTracker }),
  // createBlockCacheMiddleware({ blockTracker }),
  (0,base_controllers_namespaceObject.createInflightCacheMiddleware)({
    cacheIdentifierForRequest: cacheIdentifierForRequest
  }),
  // createBlockTrackerInspectorMiddleware({ blockTracker }),
  fetchMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}
;// CONCATENATED MODULE: ./src/Network/NetworkController.ts



const NetworkController_excluded = ["chainId", "rpcTarget"];







class NetworkController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "name", "NetworkController");
    defineProperty_default()(this, "providerProxy", void 0);
    defineProperty_default()(this, "blockTrackerProxy", void 0);
    defineProperty_default()(this, "mutex", new external_async_mutex_namespaceObject.Mutex());
    defineProperty_default()(this, "provider", null);
    defineProperty_default()(this, "blockTracker", null);
    defineProperty_default()(this, "baseProviderHandlers", void 0);
    this.defaultState = {
      chainId: "loading",
      properties: {
        EIPS_1559: undefined
      },
      providerConfig: SUPPORTED_NETWORKS[MAINNET_CHAIN_ID]
    };

    // when a new network is set,
    // we set to loading first and
    // then when connection succeeds,
    // we update the network
    this.initialize();
  }
  getNetworkIdentifier() {
    return this.state.chainId;
  }
  getNetworkRPCUrl() {
    return this.state.providerConfig.rpcTarget;
  }

  /**
   * Called by orchestrator once while initializing the class
   * @param providerHandlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */
  initializeProvider(providerHandlers) {
    this.baseProviderHandlers = providerHandlers;
    this.configureProvider();
    this.lookupNetwork(); // Not awaiting this, because we don't want to block the initialization
    return this.providerProxy;
  }
  getProvider() {
    return this.providerProxy;
  }
  getBlockTracker() {
    return this.blockTrackerProxy;
  }
  getProviderConfig() {
    return this.state.providerConfig;
  }
  setProviderConfig(config) {
    this.update({
      providerConfig: objectSpread2_default()({}, config)
    });
    this.refreshNetwork();
  }
  async getEIP1559Compatibility() {
    const {
      EIPS_1559
    } = this.state.properties;
    // log.info('checking eip 1559 compatibility')
    if (EIPS_1559 !== undefined) {
      return EIPS_1559;
    }
    const latestBlock = await this.blockTracker.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.update({
      properties: {
        EIPS_1559: supportsEIP1559
      }
    });
    return supportsEIP1559;
  }

  /**
   * Refreshes the current network code
   */
  async lookupNetwork() {
    const {
      chainId,
      rpcTarget
    } = this.getProviderConfig();
    if (!chainId || !rpcTarget || !this.provider) {
      this.update({
        chainId: "loading",
        properties: {}
      });
      return;
    }
    const releaseLock = await this.mutex.acquire();
    try {
      // use eth_chainId
      const [networkChainId] = await Promise.all([this.provider.request({
        method: "eth_chainId"
      }), this.getEIP1559Compatibility()]);
      external_loglevel_default().info("network fetched chain id", networkChainId);
      // update chain ID
      this.update({
        chainId: networkChainId
      });
      this.emit("networkDidChange");
    } catch {
      this.update({
        chainId: "loading"
      });
    } finally {
      releaseLock();
    }
  }
  configureProvider() {
    const _this$getProviderConf = this.getProviderConfig(),
      {
        chainId,
        rpcTarget
      } = _this$getProviderConf,
      rest = objectWithoutProperties_default()(_this$getProviderConf, NetworkController_excluded);
    if (!chainId || !rpcTarget) {
      throw new Error("chainId and rpcTarget must be provider in providerConfig");
    }
    this.configureStandardProvider(objectSpread2_default()({
      chainId,
      rpcTarget
    }, rest));
  }
  setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const ethereumMiddleware = createEthereumMiddleware(this.baseProviderHandlers);
    const engine = new openlogin_jrpc_namespaceObject.JRPCEngine();
    engine.push(ethereumMiddleware);
    engine.push(networkMiddleware);
    const provider = (0,openlogin_jrpc_namespaceObject.providerFromEngine)(engine);
    this.setProvider({
      provider,
      blockTracker
    });
  }
  setProvider({
    provider,
    blockTracker
  }) {
    if (this.providerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.providerProxy.setTarget(provider);
    } else {
      this.providerProxy = (0,base_controllers_namespaceObject.createSwappableProxy)(provider);
    }
    if (this.blockTrackerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.blockTrackerProxy.setTarget(blockTracker);
    } else {
      this.blockTrackerProxy = (0,base_controllers_namespaceObject.createEventEmitterProxy)(blockTracker, {
        eventFilter: "skipInternal"
      });
    }

    // set new provider and blockTracker
    this.provider = provider;
    provider.setMaxListeners(10);
    this.blockTracker = blockTracker;
  }
  configureStandardProvider(providerConfig) {
    const networkClient = createJsonRpcClient(providerConfig, this.config);
    external_loglevel_default().info("networkClient", networkClient);
    this.setNetworkClient(networkClient);
  }
  refreshNetwork() {
    this.update({
      chainId: "loading",
      properties: {}
    });
    this.configureProvider();
    this.lookupNetwork();
  }
}
;// CONCATENATED MODULE: ./src/Nfts/NftHandler.ts








class NftHandler {
  constructor({
    chainId,
    contractAddress,
    contractImage,
    contractName,
    contractSymbol,
    nftStandard,
    provider,
    contractDescription,
    contractFallbackLogo,
    contractSupply
  }) {
    defineProperty_default()(this, "contractAddress", void 0);
    defineProperty_default()(this, "contractName", void 0);
    defineProperty_default()(this, "contractSymbol", void 0);
    defineProperty_default()(this, "contractImage", void 0);
    defineProperty_default()(this, "contractSupply", void 0);
    defineProperty_default()(this, "contractFallbackLogo", void 0);
    defineProperty_default()(this, "nftStandard", void 0);
    defineProperty_default()(this, "contractDescription", void 0);
    defineProperty_default()(this, "chainId", void 0);
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "isSpecial", void 0);
    this.chainId = chainId;
    this.contractAddress = contractAddress;
    this.contractImage = contractImage;
    this.contractName = contractName;
    this.contractSymbol = contractSymbol;
    this.nftStandard = nftStandard;
    this.provider = provider;
    this.contractDescription = contractDescription;
    this.contractFallbackLogo = contractFallbackLogo;
    this.contractSupply = contractSupply;
  }
  async getNftMetadata(userAddress, tokenInfo) {
    const returnNftItem = objectSpread2_default()({
      description: "",
      image: "",
      name: "",
      tokenBalance: "",
      tokenId: "",
      decimals: "1"
    }, tokenInfo);
    const [tokenURI, balance] = await Promise.all([this.getCollectibleTokenURI(returnNftItem.tokenId, this.nftStandard), !returnNftItem.tokenBalance ? this.fetchNftBalance(userAddress, returnNftItem.tokenId) : Promise.resolve("0")]);
    returnNftItem.tokenBalance = returnNftItem.tokenBalance || balance;
    // some people put full json object in uri
    try {
      const object = JSON.parse(tokenURI);
      returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
      returnNftItem.name = returnNftItem.name || object.name;
      returnNftItem.description = returnNftItem.description || object.description;
      returnNftItem.decimals = returnNftItem.decimals || object.decimals;
    } catch (error) {
      external_loglevel_default().warn("Token uri is not a valid json object", error);
    }
    const finalTokenMetaUri = sanitizeNftMetdataUrl(tokenURI);
    try {
      if (!returnNftItem.description || !returnNftItem.image || !returnNftItem.name) {
        // this call might fail, if metadata url available in smart contract is not reachable
        const object = await (0,http_helpers_namespaceObject.get)(finalTokenMetaUri);
        returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
        returnNftItem.name = returnNftItem.name || object.name;
        returnNftItem.description = returnNftItem.description || object.description;
        returnNftItem.decimals = returnNftItem.decimals || object.decimals;
      }
    } catch (error) {
      external_loglevel_default().error("Failed to fetch nft metadata", error);
    }
    return returnNftItem;
  }
  async getContractMetadata() {
    const returnNft = {
      chainId: this.chainId,
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      contractSymbol: this.contractSymbol,
      nftStandard: this.nftStandard,
      contractImage: this.contractImage,
      contractDescription: this.contractDescription,
      contractFallbackLogo: this.contractFallbackLogo,
      contractSupply: this.contractSupply
    };
    if (!this.nftStandard) {
      const {
        standard,
        isSpecial
      } = await this.checkNftStandard();
      returnNft.nftStandard = standard;
      this.nftStandard = standard;
      this.isSpecial = isSpecial;
    }
    if (!this.contractName || !this.contractSymbol || !this.contractDescription) {
      const abi = this.nftStandard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
      const contract = new external_ethers_namespaceObject.Contract(this.contractAddress, abi, this.provider);
      const [name, symbol] = await Promise.all([contract.name(), contract.symbol()]);
      returnNft.contractName = name;
      returnNft.contractSymbol = symbol;
      if (!this.contractName) this.contractName = name;
      if (!this.contractSymbol) this.contractSymbol = symbol;
    }
    return returnNft;
  }
  async fetchNftBalance(userAddress, tokenId) {
    const {
      standard
    } = await this.checkNftStandard();
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new external_ethers_namespaceObject.Contract(this.contractAddress, abi, this.provider);
    if (standard === CONTRACT_TYPE_ERC1155) {
      const balance = await contract.balanceOf(userAddress, tokenId);
      return balance;
    }
    let owner = "";
    try {
      owner = await contract.ownerOf(tokenId);
    } catch {
      throw new Error("Token id doesn't exists");
    }
    if (owner.toLowerCase() === userAddress.toLowerCase()) {
      return "1";
    }
    return "0";
  }
  async checkNftStandard() {
    // For Cryptokitties
    if (this.nftStandard && this.isSpecial !== undefined) return;
    if (Object.prototype.hasOwnProperty.call(OLD_ERC721_LIST, this.contractAddress.toLowerCase())) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = true;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: true
      };
    }
    const isErc721 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC721, ERC721_INTERFACE_ID);
    if (isErc721) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: false
      };
    }
    const isErc1155 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC1155, ERC1155_INTERFACE_ID);
    if (isErc1155) {
      this.nftStandard = CONTRACT_TYPE_ERC1155;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC1155,
        isSpecial: false
      };
    }
    throw new Error("Unsupported nft standard");
  }
  async contractSupportsInterface(standard, interfaceId) {
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new external_ethers_namespaceObject.Contract(this.contractAddress, abi, this.provider);
    return contract.supportsInterface(interfaceId);
  }
  async getCollectibleTokenURI(tokenId, standard = CONTRACT_TYPE_ERC721) {
    const method = standard === CONTRACT_TYPE_ERC721 ? "tokenURI" : "uri";
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new external_ethers_namespaceObject.Contract(this.contractAddress, abi, this.provider);
    return contract[method](tokenId);
  }
}
;// CONCATENATED MODULE: external "deepmerge"
const external_deepmerge_namespaceObject = require("deepmerge");
var external_deepmerge_default = /*#__PURE__*/__webpack_require__.n(external_deepmerge_namespaceObject);
;// CONCATENATED MODULE: ./src/Nfts/NftsController.ts









const DEFAULT_INTERVAL = 180 * 1000;
class NftsController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state,
    provider,
    getCustomNfts,
    getSimpleHashNfts,
    onPreferencesStateChange,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "name", "NftsController");
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "ethersProvider", void 0);
    defineProperty_default()(this, "_timer", void 0);
    defineProperty_default()(this, "getCustomNfts", void 0);
    defineProperty_default()(this, "getSimpleHashNfts", void 0);
    this.provider = provider;
    this.ethersProvider = new external_ethers_namespaceObject.BrowserProvider(this.provider, "any");
    this.getCustomNfts = getCustomNfts;
    this.getSimpleHashNfts = getSimpleHashNfts;
    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      nfts: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartNftDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartNftDetection();
      }
    });
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userNfts() {
    var _this$state$nfts$this;
    if (!this.userSelectedAddress) return [];
    return (_this$state$nfts$this = this.state.nfts[this.userSelectedAddress]) !== null && _this$state$nfts$this !== void 0 ? _this$state$nfts$this : [];
  }
  get interval() {
    return this.config.interval;
  }
  set interval(interval) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewNfts();
        this.refreshNftBalances();
      }
    }, interval);
  }
  startNftDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartNftDetection();
  }

  /**
   * Restart nft detection polling period and call detectNewNfts
   * in case of address change or user session initialization.
   *
   */
  restartNftDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewNfts();
    this.refreshNftBalances();
    this.config.interval = DEFAULT_INTERVAL;
  }
  detectNewNfts() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const nftsToDetect = []; // object[]
    if (!currentChainId) {
      this.update({
        nfts: {
          [userAddress]: [...nftsToDetect]
        }
      });
      return;
    }
    if (this.getCustomNfts) {
      const customNfts = this.getCustomNfts(userAddress);
      const reducedNfts = customNfts.reduce((acc, x) => {
        // first aggregate by contract address
        if (x.network === currentChainId) {
          const newAsset = {
            description: "",
            image: "",
            name: "",
            tokenBalance: "",
            tokenId: x.nft_id,
            customNftId: x.id.toString()
          };
          if (acc[x.nft_address]) {
            acc[x.nft_address].assets.push(newAsset);
          } else {
            const objToPush = {
              assets: [newAsset],
              chainId: x.network,
              contractAddress: x.nft_address,
              contractName: "",
              contractSymbol: "",
              contractImage: "",
              nftStandard: x.nft_contract_standard,
              contractDescription: ""
            };
            acc[x.nft_address] = objToPush;
          }
        }
        return acc;
      }, {});
      nftsToDetect.push(...Object.values(reducedNfts));
    }
    this.update({
      nfts: {
        [userAddress]: [...nftsToDetect]
      }
    });
  }
  async refreshNftBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldNfts = [...this.userNfts];
    const nonZeroNfts = [];
    try {
      const currentChainId = this.config.chainId;
      if (SIMPLEHASH_SUPPORTED_CHAINS.includes(currentChainId)) {
        const simpleHashBalances = await this.getSimpleHashNfts(userAddress, currentChainId);
        nonZeroNfts.push(...simpleHashBalances);
        this.update({
          nfts: {
            [userAddress]: nonZeroNfts
          }
        });
      }
      if (oldNfts.length > 0) {
        this.getNftBalancesUsingHandler(oldNfts);
      }
    } catch (error) {
      external_loglevel_default().error(error, "unable to fetch nft balances");
    }
  }
  async getNftBalancesUsingHandler(customNfts) {
    if (!this.userSelectedAddress) return;
    const userAddress = this.userSelectedAddress;
    const currentNetworkNfts = customNfts;
    const promiseSettledResult = await Promise.allSettled(currentNetworkNfts.map(async x => {
      try {
        const tokenInstance = new NftHandler(objectSpread2_default()(objectSpread2_default()({}, x), {}, {
          provider: this.ethersProvider
        }));
        const contractData = await tokenInstance.getContractMetadata();
        const assetData = await Promise.allSettled(x.assets.map(y => tokenInstance.getNftMetadata(userAddress, y)));
        return objectSpread2_default()(objectSpread2_default()({}, contractData), {}, {
          assets: assetData.filter(z => z.status === "fulfilled").map(z => z.value)
        });
      } catch (error) {
        external_loglevel_default().warn("Invalid contract address while fetching", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.filter(x => x.status === "fulfilled").map(x => x.value);
    this.update({
      nfts: {
        [userAddress]: external_deepmerge_default()(this.userNfts, nonZeroTokens)
      }
    });
  }
}
;// CONCATENATED MODULE: ./src/Preferences/PreferencesController.ts







class PreferencesController extends base_controllers_namespaceObject.BasePreferencesController {
  constructor({
    config,
    state,
    provider,
    signAuthMessage,
    getProviderConfig,
    setProviderConfig,
    validateSignMessage
  }) {
    super({
      config,
      state,
      defaultPreferences: {
        formattedPastTransactions: [],
        fetchedPastTx: [],
        paymentTx: [],
        etherscanTransactions: []
      },
      signAuthMessage,
      validateSignMessage
    });
    defineProperty_default()(this, "_handle", void 0);
    defineProperty_default()(this, "_mutex", new external_async_mutex_namespaceObject.Mutex());
    defineProperty_default()(this, "getProviderConfig", void 0);
    defineProperty_default()(this, "setProviderConfig", void 0);
    defineProperty_default()(this, "provider", void 0);
    this.provider = provider;
    this.getProviderConfig = getProviderConfig;
    this.setProviderConfig = setProviderConfig;
  }
  async poll(interval) {
    var _this$getAddressState;
    const releaseLock = await this._mutex.acquire();
    if (interval) this.configure({
      pollInterval: interval
    });
    if (this._handle) window.clearTimeout(this._handle);
    // call here
    const storeSelectedAddress = this.state.selectedAddress;
    if (!storeSelectedAddress) return;
    if (!((_this$getAddressState = this.getAddressState(storeSelectedAddress)) !== null && _this$getAddressState !== void 0 && _this$getAddressState.jwtToken)) return;
    // This should never throw
    await this.sync(storeSelectedAddress);
    releaseLock();
    this._handle = window.setTimeout(() => {
      this.poll(this.config.pollInterval);
    }, this.config.pollInterval);
  }
  async initPreferences(params) {
    const {
      address,
      jwtToken,
      calledFromEmbed,
      userInfo,
      rehydrate,
      locale = "en",
      type,
      signatures,
      web3AuthClientId,
      web3AuthNetwork,
      loginMode,
      sessionPubKey
    } = params;
    await super.init({
      address,
      userInfo,
      idToken: jwtToken,
      type,
      metadata: {
        email: userInfo.email,
        signatures,
        network: web3AuthNetwork
      }
    });
    const {
      aggregateVerifier,
      verifier,
      verifierId
    } = userInfo || {};
    const userExists = await this.sync(address);
    if (!userExists) {
      const accountState = this.getAddressState(address);
      await this.createUser({
        selectedCurrency: accountState.selectedCurrency,
        theme: accountState.theme,
        verifier: aggregateVerifier || verifier,
        verifierId,
        locale,
        address,
        type,
        web3AuthNetwork
      });
    }
    this.storeUserLogin({
      verifier: aggregateVerifier || verifier,
      verifierId,
      options: {
        calledFromEmbed,
        rehydrate
      },
      address,
      web3AuthClientId,
      web3AuthNetwork,
      sessionPubKey,
      loginMode
    });
  }
  getSelectedAddress() {
    return this.state.selectedAddress;
  }
  async sync(address) {
    try {
      const user = await this.getUser(address);
      if (user) {
        const {
          default_currency: defaultCurrency,
          contacts,
          theme,
          locale,
          public_address: userPublicAddress,
          default_public_address: defaultPublicAddress,
          customNetworks,
          customTokens,
          customNfts,
          account_type: accountType
        } = user || {};

        // update latest data in state.
        this.updateState({
          contacts,
          theme,
          selectedCurrency: defaultCurrency,
          locale,
          defaultPublicAddress: defaultPublicAddress || userPublicAddress,
          customTokens,
          customNfts,
          customNetworks,
          accountType: accountType
        }, address);
        return true;
      }
      return false;
    } catch (error) {
      if ((0,base_controllers_namespaceObject.isUnauthorizedError)(error)) {
        throw error;
      }
      external_loglevel_default().error(error);
      return false;
    } finally {
      this.getWalletOrders(address).then(walletTx => {
        // eslint-disable-next-line promise/always-return
        if (walletTx && walletTx.length > 0) {
          this.updateState({
            fetchedPastTx: [...walletTx]
          }, address);
          this.calculatePastTx(walletTx, address);
        }
      }).catch(error => external_loglevel_default().error(error));
    }
  }
  async patchNewTx(tx, address) {
    var _this$getAddressState2;
    const formattedTx = formatPastTx({
      transaction: tx,
      blockExplorerUrl: this.getBlockExplorerUrl()
    });
    const storePastTx = ((_this$getAddressState2 = this.getAddressState(address)) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.formattedPastTransactions) || [];
    const duplicateIndex = storePastTx.findIndex(x => x.transaction_hash === tx.transaction_hash && x.chainId === tx.chain_id);
    if (tx.status === base_controllers_namespaceObject.TransactionStatus.submitted || tx.status === base_controllers_namespaceObject.TransactionStatus.confirmed) {
      if (duplicateIndex === -1) {
        var _tx$to;
        // No duplicate found

        const finalTx = this.cancelTxCalculate([...storePastTx, formattedTx]);
        tx.is_cancel = formattedTx.is_cancel;
        tx.to = (_tx$to = tx.to) === null || _tx$to === void 0 ? void 0 : _tx$to.toLowerCase();
        tx.from = tx.from.toLowerCase();
        this.updateState({
          formattedPastTransactions: finalTx
        }, address);
        this.postPastTx(tx, address);
      } else {
        // avoid overriding is_cancel
        formattedTx.is_cancel = storePastTx[duplicateIndex].is_cancel;
        storePastTx[duplicateIndex] = formattedTx;
        this.updateState({
          formattedPastTransactions: this.cancelTxCalculate([...storePastTx])
        }, address);
      }
    }
  }
  recalculatePastTx(address) {
    // This triggers store update which calculates past Tx status for that network
    const selectedAddress = address || this.state.selectedAddress;
    const state = this.getAddressState(selectedAddress);
    if (!(state !== null && state !== void 0 && state.fetchedPastTx)) return;
    this.calculatePastTx(state.fetchedPastTx, selectedAddress);
  }
  async refetchEtherscanTx(address) {
    var _this$getAddressState3;
    const selectedAddress = address || this.state.selectedAddress;
    if (!selectedAddress) return [];
    const lowerCaseSelectedAddress = selectedAddress === null || selectedAddress === void 0 ? void 0 : selectedAddress.toLowerCase();
    if ((_this$getAddressState3 = this.getAddressState(selectedAddress)) !== null && _this$getAddressState3 !== void 0 && _this$getAddressState3.jwtToken) {
      const {
        chainId
      } = this.getProviderConfig();
      if (ETHERSCAN_SUPPORTED_CHAINS.includes(chainId)) {
        const etherscanTxn = await this.fetchEtherscanTx({
          selectedAddress,
          chainId: this.getProviderConfig().chainId
        });
        const finalEthScanTxn = await addEtherscanTransactions({
          txn: etherscanTxn,
          lowerCaseSelectedAddress,
          provider: this.provider,
          chainId,
          blockExplorerUrl: this.getBlockExplorerUrl()
        });
        external_loglevel_default().info("Formatted Etherscan Response", finalEthScanTxn);
        this.updateState({
          etherscanTransactions: finalEthScanTxn
        });
        return etherscanTxn;
      }
    }
  }
  async fetchEtherscanTx(parameters) {
    try {
      const response = await this.wsApiClient.authGet(`etherscan?chainId=${parameters.chainId}`, this.authCredentials(parameters.selectedAddress));
      external_loglevel_default().info("Etherscan Response API", response);
      return response.success ? response.data : [];
    } catch (error) {
      external_loglevel_default().error("unable to fetch etherscan tx", error);
      return [];
    }
  }
  async getEtherScanTokens(address, chainId) {
    const selectedAddress = address;
    const result = await this.wsApiClient.authGet(`tokens?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());
    return result.data;
  }
  async getSimpleHashNfts(address, chainId) {
    const selectedAddress = address;
    const result = await this.wsApiClient.authGet(`nfts?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());
    return result.data;
  }
  getCustomTokens(address) {
    var _this$getAddressState4, _this$getAddressState5;
    return (_this$getAddressState4 = (_this$getAddressState5 = this.getAddressState(address)) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.customTokens) !== null && _this$getAddressState4 !== void 0 ? _this$getAddressState4 : [];
  }
  getCustomNfts(address) {
    var _this$getAddressState6, _this$getAddressState7;
    return (_this$getAddressState6 = (_this$getAddressState7 = this.getAddressState(address)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.customNfts) !== null && _this$getAddressState6 !== void 0 ? _this$getAddressState6 : [];
  }
  isChainIdSupported(address, chainId) {
    const approveChainOptions = this.getChainOptions(address);
    const providerConfig = approveChainOptions.find(x => (0,util_namespaceObject.stripHexPrefix)(x.chainId) === chainId);
    return !!providerConfig;
  }
  async addChain(network) {
    const approveChainOptions = this.getChainOptions();
    const providerConfig = approveChainOptions.find(x => x.chainId === network.chainId);
    if (providerConfig) return;
    const newNetwork = {
      displayName: network.chainName,
      rpcTarget: network.rpcUrls[0],
      ticker: network.nativeCurrency.symbol,
      chainId: network.chainId,
      blockExplorerUrl: network.blockExplorerUrls[0],
      tickerName: network.nativeCurrency.name,
      logo: network.nativeCurrency.symbol
    };
    const isSuccess = await this.addCustomNetwork({
      network: newNetwork
    });
    if (!isSuccess) throw new Error("unable to add custom network");
  }
  switchChain(data) {
    const chainOptions = this.getChainOptions();
    const providerConfig = chainOptions.find(x => x.chainId === data.chainId);
    if (providerConfig) {
      this.setProviderConfig(providerConfig);
    } else {
      throw new Error(`chainId ${data.chainId} is not supported`);
    }
  }

  // Custom Network methods
  async addCustomNetwork({
    network
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false,
        logo: network.logo,
        symbol_name: network.tickerName
      };
      const res = await this.wsApiClient.authPost("customnetwork", payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return res.data.id;
    } catch {
      external_loglevel_default().error("error adding custom network");
      return null;
    }
  }
  async deleteCustomNetwork(id) {
    try {
      const {
        selectedAddress
      } = this.state;
      await this.wsApiClient.authRemove(`customnetwork/${id}`, {}, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      external_loglevel_default().error("error deleting custom network");
      return false;
    }
  }
  async editCustomNetwork({
    network,
    id
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker || undefined,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false
      };
      await this.wsApiClient.authPatch(`customnetwork/${id}`, payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      external_loglevel_default().error("error editing custom network");
      return false;
    }
  }
  getChainOptions(address = this.state.selectedAddress) {
    var _identities$address$c, _identities$address;
    const {
      identities
    } = this.state;
    const customNetworks = (_identities$address$c = (_identities$address = identities[address]) === null || _identities$address === void 0 ? void 0 : _identities$address.customNetworks) !== null && _identities$address$c !== void 0 ? _identities$address$c : [];
    const custom = Object.values(customNetworks).reduce((chains, network) => {
      const networkItem = {
        blockExplorerUrl: network.block_explorer_url,
        chainId: network.chain_id,
        displayName: network.network_name,
        logo: "eth.svg",
        rpcTarget: network.rpc_url,
        ticker: network.symbol,
        tickerName: network.symbol.toUpperCase(),
        isCustom: true,
        id: network.id
      };
      if (Object.keys(SUPPORTED_NETWORKS).includes(networkItem.chainId)) return chains;
      chains.push(networkItem);
      return chains;
    }, []);
    const supported = Object.values(SUPPORTED_NETWORKS).reduce((chains, network) => {
      chains.push(network);
      return chains;
    }, []);
    return [...supported, ...custom];
  }
  getBlockExplorerUrl() {
    const supportedNetworks = this.getChainOptions();
    const network = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    if (!network) return "";
    return `${network.blockExplorerUrl}`;
  }
  async calculatePastTx(txs, address) {
    const pastTx = [];
    const pendingTx = [];
    const lowerCaseSelectedAddress = address.toLowerCase();
    const supportedNetworks = this.getChainOptions(address);
    const supportedNetwork = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    for (const x of txs) {
      var _x$to;
      if ((supportedNetwork === null || supportedNetwork === void 0 ? void 0 : supportedNetwork.chainId) === x.chain_id && x.to && x.from && (lowerCaseSelectedAddress === x.from.toLowerCase() || lowerCaseSelectedAddress === ((_x$to = x.to) === null || _x$to === void 0 ? void 0 : _x$to.toLowerCase()))) {
        if (x.status !== "confirmed") {
          pendingTx.push(x);
        } else {
          const finalObject = formatPastTx({
            transaction: x,
            lowerCaseSelectedAddress,
            blockExplorerUrl: this.getBlockExplorerUrl()
          });
          pastTx.push(finalObject);
        }
      }
    }
    const pendingTxPromises = pendingTx.map(x => getEthTxStatus(x.transaction_hash, this.provider).catch(error => external_loglevel_default().error(error)));
    const resolvedTxStatuses = await Promise.all(pendingTxPromises);
    for (const [index, element] of pendingTx.entries()) {
      const finalObject = formatPastTx({
        transaction: element,
        lowerCaseSelectedAddress,
        blockExplorerUrl: this.getBlockExplorerUrl()
      });
      finalObject.status = resolvedTxStatuses[index] || base_controllers_namespaceObject.TransactionStatus.submitted;
      pastTx.push(finalObject);
      if (lowerCaseSelectedAddress === element.from.toLowerCase() && finalObject.status && finalObject.status !== element.status) this.patchPastTx({
        id: element.id,
        status: finalObject.status
      }, address);
    }
    const finalTx = this.cancelTxCalculate(pastTx);
    this.updateState({
      formattedPastTransactions: [...finalTx]
    }, address);
  }
  cancelTxCalculate(pastTx) {
    const nonceMap = {};
    for (const x of pastTx) {
      if (!nonceMap[x.nonce]) nonceMap[x.nonce] = [x];else {
        nonceMap[x.nonce].push(x);
      }
    }
    for (const [, value] of Object.entries(nonceMap)) {
      // has duplicate
      if (value.length > 1) {
        // get latest and mark it as is_cancel
        const latestTxs = value.sort((a, b) => {
          const aDate = new Date(a.date).getTime();
          const bDate = new Date(b.date).getTime();
          return bDate - aDate;
        });
        const latestCancelTx = latestTxs[0];
        latestCancelTx.is_cancel = true;
        latestTxs.slice(1).forEach(x => {
          x.hasCancel = true;
          x.status = latestCancelTx.status === "confirmed" ? base_controllers_namespaceObject.TransactionStatus.cancelled : base_controllers_namespaceObject.TransactionStatus.cancelling;
          x.cancelDateInitiated = `${formatTime(new Date(latestCancelTx.date).getTime())} - ${formatDate(latestCancelTx.date)}`;
          x.etherscanLink = latestCancelTx.etherscanLink;
          x.cancelGas = latestCancelTx.gas;
          x.cancelGasPrice = latestCancelTx.gasPrice;
        });
      }
    }
    return pastTx;
  }
}
;// CONCATENATED MODULE: ./src/Tokens/TokenHandler.ts




class TokenHandler {
  constructor({
    address,
    symbol,
    decimals,
    name,
    provider
  }) {
    defineProperty_default()(this, "address", void 0);
    defineProperty_default()(this, "symbol", void 0);
    defineProperty_default()(this, "decimals", void 0);
    defineProperty_default()(this, "name", void 0);
    defineProperty_default()(this, "contract", void 0);
    this.address = address;
    this.contract = new external_ethers_namespaceObject.Contract(address, erc20Abi, provider);
    this.symbol = symbol;
    this.decimals = decimals;
    this.name = name;
  }
  async getSymbol() {
    if (!this.symbol || this.symbol === "ERC20") this.symbol = await this.contract.symbol();
    return this.symbol;
  }
  async getDecimals() {
    try {
      if (!this.decimals) this.decimals = await this.contract.decimals();
      return this.decimals;
    } catch (error) {
      external_loglevel_default().warn(`Could not get decimals for token ${this.address}`, error);
      return 0;
    }
  }
  async getName() {
    if (!this.name) this.name = await this.contract.name();
    return this.name;
  }
  async getUserBalance(userAddress) {
    if (!this.decimals) await this.getDecimals();
    const balance = await this.contract.balanceOf(userAddress);
    return balance.toString(16);
  }
}
;// CONCATENATED MODULE: ./src/Tokens/TokenRatesController.ts







const DEFAULT_CURRENCY = "eth";
class TokenRatesController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state,
    onPreferencesStateChange,
    onNetworkStateChange,
    onTokensStateChange
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "conversionInterval", void 0);
    this.defaultState = objectSpread2_default()(objectSpread2_default()({}, this.defaultState), {}, {
      contractExchangeRates: {}
    });
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      const {
        selectedAddress
      } = preferencesState;
      this.configure({
        selectedAddress
      });
    });
    onNetworkStateChange(networkState => {
      const {
        chainId,
        ticker
      } = networkState.providerConfig;
      this.configure({
        chainId,
        nativeCurrency: ticker
      });
    });
    onTokensStateChange(tokensState => {
      const {
        tokens
      } = tokensState;
      const currentUserTokens = tokens[this.config.selectedAddress];
      if ((currentUserTokens === null || currentUserTokens === void 0 ? void 0 : currentUserTokens.length) > 0 && this.config.tokens !== tokens[this.config.selectedAddress]) {
        this.configure({
          tokens: tokens[this.config.selectedAddress]
        });
        this.updateExchangeRates();
      }
    });
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  scheduleConversionInterval() {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateExchangeRates();
      }
    }, this.config.pollInterval);
  }
  async updateExchangeRates() {
    const chainCodes = COINGECKO_PLATFORMS_CHAIN_CODE_MAP[this.config.chainId];
    let newContractExchangeRates = {};
    if (!chainCodes) {
      external_loglevel_default().info(`ChainId ${this.config.chainId} not supported by coingecko`);
      this.config.tokens.forEach(token => {
        newContractExchangeRates[token.tokenAddress] = undefined;
      });
    } else {
      newContractExchangeRates = await this.fetchExchangeRates(this.config.nativeCurrency, chainCodes);
    }
    this.update({
      contractExchangeRates: newContractExchangeRates
    });
  }
  async fetchExchangeRates(nativeCurrency, chainCodes) {
    const contractAddresses = this.config.tokens.map(token => token.tokenAddress);
    const isNativeCurrencySupported = COINGECKO_SUPPORTED_CURRENCIES.has(nativeCurrency.toLowerCase());
    if (isNativeCurrencySupported) {
      const response = await (0,http_helpers_namespaceObject.get)(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${nativeCurrency.toLowerCase()}`);
      const newContractExchangeRates = {};
      Object.keys(response).forEach(contractAddress => {
        newContractExchangeRates[contractAddress] = response[contractAddress][nativeCurrency.toLowerCase()] || 0;
      });
      return newContractExchangeRates;
    }
    const [response, currencyResponse] = await Promise.all([(0,http_helpers_namespaceObject.get)(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${DEFAULT_CURRENCY}`), (0,http_helpers_namespaceObject.get)(`${this.config.currencyApi}/currency?fsym=${nativeCurrency.toUpperCase()}&tsyms=${DEFAULT_CURRENCY.toUpperCase()}`)]);
    const newContractExchangeRates = {};
    Object.keys(response).forEach(contractAddress => {
      newContractExchangeRates[contractAddress] = response[contractAddress][DEFAULT_CURRENCY] * Number.parseFloat(currencyResponse[DEFAULT_CURRENCY]) || 0;
    });
    return newContractExchangeRates;
  }
}
;// CONCATENATED MODULE: ./src/Tokens/TokensController.ts










function getObjectFromArrayBasedonKey(oldArray, key) {
  return oldArray.reduce((acc, x) => {
    const xkey = x[key];
    if (typeof xkey === "boolean") return acc;
    acc[xkey] = x;
    return acc;
  }, {});
}
const mergeTokenArrays = (oldArray, newArray) => {
  const oldMap = getObjectFromArrayBasedonKey(oldArray || [], "tokenAddress");
  const newMap = getObjectFromArrayBasedonKey(newArray || [], "tokenAddress");
  const finalArr = newArray;
  Object.keys(oldMap).forEach(x => {
    if (!newMap[x] && oldMap[x].isEtherScan) finalArr.push(oldMap[x]);
  });
  return finalArr;
};
const TokensController_DEFAULT_INTERVAL = 180 * 1000;
class TokensController extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state,
    provider,
    getCustomTokens,
    getEtherScanTokens,
    getProviderConfig,
    onPreferencesStateChange,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    defineProperty_default()(this, "name", "TokensController");
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "ethersProvider", void 0);
    defineProperty_default()(this, "_timer", void 0);
    defineProperty_default()(this, "getProviderConfig", void 0);
    defineProperty_default()(this, "getCustomTokens", void 0);
    defineProperty_default()(this, "getEtherScanTokens", void 0);
    this.provider = provider;
    this.ethersProvider = new external_ethers_namespaceObject.BrowserProvider(this.provider, "any");
    this.getCustomTokens = getCustomTokens;
    this.getEtherScanTokens = getEtherScanTokens;
    this.getProviderConfig = getProviderConfig;
    this.defaultConfig = {
      interval: TokensController_DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      tokens: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartTokenDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartTokenDetection();
      }
    });
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userTokens() {
    var _this$state$tokens$th;
    if (!this.userSelectedAddress) return [];
    return (_this$state$tokens$th = this.state.tokens[this.userSelectedAddress]) !== null && _this$state$tokens$th !== void 0 ? _this$state$tokens$th : [];
  }
  get interval() {
    return this.config.interval;
  }
  set interval(interval) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewTokens();
        this.refreshTokenBalances();
      }
    }, interval);
  }
  startTokenDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartTokenDetection();
  }

  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */
  restartTokenDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewTokens();
    this.refreshTokenBalances();
    this.config.interval = TokensController_DEFAULT_INTERVAL;
  }
  detectNewTokens() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const tokens = []; // object[]
    if (!currentChainId) {
      this.update({
        tokens: {
          [userAddress]: [...tokens]
        }
      });
      return;
    }
    const networkConfig = this.getProviderConfig();
    if (networkConfig !== null && networkConfig !== void 0 && networkConfig.isErc20 && networkConfig !== null && networkConfig !== void 0 && networkConfig.tokenAddress) {
      tokens.push({
        tokenAddress: networkConfig.tokenAddress,
        name: networkConfig.tickerName,
        logo: networkConfig.logo,
        erc20: true,
        symbol: networkConfig.ticker,
        decimals: "18",
        chainId: currentChainId
      });
    }
    if (this.getCustomTokens) {
      const customTokens = this.getCustomTokens(userAddress);
      tokens.push(...customTokens.reduce((acc, x) => {
        if (x.network === currentChainId) acc.push({
          tokenAddress: x.token_address,
          name: x.token_name,
          logo: "eth.svg",
          erc20: true,
          symbol: x.token_symbol,
          decimals: x.decimals,
          balance: "",
          customTokenId: x.id.toString(),
          chainId: x.network
        });
        return acc;
      }, []));
    }
    this.update({
      tokens: {
        [userAddress]: [...tokens]
      }
    });
  }
  async refreshTokenBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldTokens = [...this.userTokens];
    const tokenAddresses = oldTokens.map(x => x.tokenAddress);
    const nonZeroTokens = [];
    try {
      const currentChainId = this.config.chainId;
      if (ETHERSCAN_SUPPORTED_CHAINS.includes(currentChainId)) {
        const etherscanBalances = await this.getEtherScanTokens(userAddress, currentChainId);
        nonZeroTokens.push(...etherscanBalances);
      }
      if (tokenAddresses.length > 0) {
        const currentSingleCallAddress = SINGLE_CALL_BALANCES_ADDRESSES[currentChainId];
        if (currentSingleCallAddress) {
          const ethContract = new external_ethers_namespaceObject.Contract(currentSingleCallAddress, singleBalanceCheckerAbi, this.ethersProvider);
          const result = await ethContract.balances([userAddress], tokenAddresses);
          tokenAddresses.forEach((_, index) => {
            const balance = (0,external_ethers_namespaceObject.toQuantity)(result[index]);
            if (balance && balance !== "0x0") {
              nonZeroTokens.push(objectSpread2_default()(objectSpread2_default()({}, oldTokens[index]), {}, {
                balance,
                chainId: currentChainId
              }));
            }
          });
        } else {
          this.getTokenBalancesUsingHandler(oldTokens);
        }
      }
    } catch (error) {
      external_loglevel_default().error(error, "unable to fetch token balances using single call balance address");
      this.getTokenBalancesUsingHandler(oldTokens);
    } finally {
      this.update({
        tokens: {
          [userAddress]: nonZeroTokens
        }
      });
    }
  }
  async getTokenBalancesUsingHandler(customTokens) {
    if (!this.userSelectedAddress) return;
    const currentNetworkTokens = customTokens;
    const promiseSettledResult = await Promise.allSettled(currentNetworkTokens.map(async x => {
      try {
        const tokenInstance = new TokenHandler({
          address: x.tokenAddress,
          decimals: Number.parseInt(x.decimals),
          name: x.name,
          symbol: x.symbol,
          provider: this.ethersProvider
        });
        const balance = await tokenInstance.getUserBalance(this.userSelectedAddress);
        return {
          decimals: tokenInstance.decimals.toString(),
          erc20: true,
          logo: x.logo || "eth.svg",
          name: tokenInstance.name,
          symbol: tokenInstance.symbol,
          tokenAddress: toChecksumAddressByChainId(tokenInstance.address, x.chainId),
          balance: `0x${balance}`,
          customTokenId: x.customTokenId,
          network: x.chainId,
          chainId: x.chainId
        };
      } catch (error) {
        external_loglevel_default().warn("Invalid contract address while fetching", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.filter(x => x.status === "fulfilled").map(x => x.value);
    this.update({
      tokens: {
        [this.userSelectedAddress]: mergeTokenArrays(this.userTokens, nonZeroTokens)
      }
    });
  }
}
;// CONCATENATED MODULE: ./src/Transaction/NonceTracker.ts

// import assert from 'assert'



class NonceTracker {
  constructor({
    provider,
    blockTracker,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "blockTracker", void 0);
    defineProperty_default()(this, "getPendingTransactions", void 0);
    defineProperty_default()(this, "getConfirmedTransactions", void 0);
    defineProperty_default()(this, "lockMap", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.lockMap = {};
  }
  async getGlobalLock() {
    const globalMutex = this._lookupMutex("global");
    // await global mutex free
    const releaseLock = await globalMutex.acquire();
    return {
      releaseLock
    };
  }

  /**
    this will return an object with the `nextNonce` 
    `nonceDetails`, and the releaseLock.
    Note: releaseLock must be called after adding a signed tx 
    to pending transactions (or discarding).
  */
  async getNonceLock(address) {
    // await global mutex free
    await this._globalMutexFree();
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address);
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {};
      const networkNonceResult = await this._getNetworkNextNonce(address);
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address);
      const nextNetworkNonce = networkNonceResult.nonce;
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed);
      const pendingTxs = this.getPendingTransactions(address);
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested);
      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce
      };
      nonceDetails.local = localNonceResult;
      nonceDetails.network = networkNonceResult;
      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce);

      // return nonce and release cb
      return {
        nextNonce,
        nonceDetails,
        releaseLock
      };
    } catch (error) {
      // release lock if we encounter an error
      releaseLock();
      throw error;
    }
  }
  async _globalMutexFree() {
    const globalMutex = this._lookupMutex("global");
    const releaseLock = await globalMutex.acquire();
    releaseLock();
  }
  async _takeMutex(lockId) {
    const mutex = this._lookupMutex(lockId);
    const releaseLock = await mutex.acquire();
    return releaseLock;
  }
  _lookupMutex(lockId) {
    let mutex = this.lockMap[lockId];
    if (!mutex) {
      mutex = new external_async_mutex_namespaceObject.Mutex();
      this.lockMap[lockId] = mutex;
    }
    return mutex;
  }
  async _getNetworkNextNonce(address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const block = await this.blockTracker.getLatestBlock();
    const baseCountStr = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [address, block.idempotencyKey]
    });
    const baseCount = Number.parseInt(baseCountStr, 16);
    const nonceDetails = {
      block,
      baseCount
    };
    return {
      name: "network",
      nonce: baseCount,
      details: nonceDetails
    };
  }
  _getHighestLocallyConfirmed(address) {
    const confirmedTransactions = this.getConfirmedTransactions(address);
    const highest = this._getHighestNonce(confirmedTransactions);
    return Number.isInteger(highest) ? highest + 1 : 0;
  }
  _getHighestNonce(txList) {
    const nonces = txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    });
    const highestNonce = Math.max.apply(null, nonces);
    return highestNonce;
  }
  _getHighestContinuousFrom(txList, startPoint) {
    const nonces = new Set(txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    }));
    let highest = startPoint;
    while (nonces.has(highest)) {
      highest += 1;
    }
    return {
      name: "local",
      nonce: highest,
      details: {
        startPoint,
        highest
      }
    };
  }
}
/* harmony default export */ const Transaction_NonceTracker = (NonceTracker);
;// CONCATENATED MODULE: ./src/Transaction/PendingTransactionTracker.ts





class PendingTransactionTracker extends openlogin_jrpc_namespaceObject.SafeEventEmitter {
  constructor({
    provider,
    nonceTracker,
    approveTransaction,
    publishTransaction,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    super();
    defineProperty_default()(this, "DROPPED_BUFFER_COUNT", 3);
    defineProperty_default()(this, "nonceTracker", void 0);
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "approveTransaction", void 0);
    defineProperty_default()(this, "droppedBlocksBufferByHash", void 0);
    defineProperty_default()(this, "getConfirmedTransactions", void 0);
    defineProperty_default()(this, "getPendingTransactions", void 0);
    defineProperty_default()(this, "publishTransaction", void 0);
    this.provider = provider;
    this.nonceTracker = nonceTracker;
    this.approveTransaction = approveTransaction;
    this.publishTransaction = publishTransaction;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.droppedBlocksBufferByHash = new Map();
  }

  /**
    checks the network for signed txs and releases the nonce global lock if it is
  */
  async updatePendingTxs() {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();
    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));
    } catch (error) {
      external_loglevel_default().error("PendingTransactionTracker - Error updating pending transactions");
      external_loglevel_default().error(error);
    }
    nonceGlobalLock.releaseLock();
  }
  async resubmitPendingTxs(block) {
    const pending = this.getPendingTransactions();
    // only try resubmitting if their are transactions to resubmit
    if (pending.length === 0) return;
    // Keep this as a for loop because we want to wait for each item to be submitted
    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, block.idempotencyKey);
      } catch (error) {
        var _value;
        /*
        Dont marked as failed if the error is a "known" transaction warning
        "there is already a transaction with the same sender-nonce
        but higher/same gas price"
        Also don't mark as failed if it has ever been broadcast successfully.
        A successful broadcast means it may still be mined.
        */
        const errorMessage = ((_value = error.value) === null || _value === void 0 || (_value = _value.message) === null || _value === void 0 ? void 0 : _value.toLowerCase()) || error.message.toLowerCase();
        const isKnownTx =
        // geth
        errorMessage.includes("replacement transaction underpriced") || errorMessage.includes("known transaction") ||
        // parity
        errorMessage.includes("gas price too low to replace") || errorMessage.includes("transaction with the same hash was already imported") ||
        // other
        errorMessage.includes("gateway timeout") || errorMessage.includes("nonce too low");
        // ignore resubmit warnings, return early
        if (isKnownTx) return;
        // encountered real error - transition to error state
        txMeta.warning = {
          error: errorMessage,
          message: "There was an error when resubmitting this transaction."
        };
        this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_WARNING, {
          txMeta,
          error,
          txId: txMeta.id
        });
      }
    }
  }
  async _resubmitTx(txMeta, latestBlockNumber) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_BLOCK_UPDATE, {
        txMeta,
        latestBlockNumber,
        txId: txMeta.id
      });
    }
    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);
    const retryCount = txMeta.retryCount || 0;

    // Exponential backoff to limit retries at publishing (capped at last 15 mins)
    if (txBlockDistance <= Math.min(50, 2 ** retryCount)) return undefined;

    // Only auto-submit already-signed txs:
    if (!("rawTransaction" in txMeta)) return this.approveTransaction(txMeta.id);
    const {
      rawTransaction
    } = txMeta;
    const txHash = await this.publishTransaction(rawTransaction);

    // Increment successful tries:
    this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_RETRY, {
      txMeta,
      txId: txMeta.id
    });
    return txHash;
  }
  async _checkPendingTx(foundTx) {
    const txMeta = foundTx;
    const txHash = txMeta.transactionHash;
    const txId = txMeta.id;

    // Only check submitted txs
    if (txMeta.status !== base_controllers_namespaceObject.TransactionStatus.submitted) return;

    // extra check in case there was an uncaught error during the
    // signature and submission process
    if (!txHash) {
      const noTxHashError = new Error("We had an error while submitting this transaction, please try again.");
      noTxHashError.name = "NoTxHashError";
      this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_FAILED, {
        txId,
        error: noTxHashError
      });
      return;
    }

    // If another tx with the same nonce is mined, set as failed.
    if (this._checkIfNonceIsTaken(txMeta)) {
      this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_DROPPED, {
        txId
      });
      return;
    }
    try {
      const transactionReceipt = await this.provider.request({
        method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
        params: [txHash]
      });
      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {
        const {
          baseFeePerGas,
          timestamp
        } = await this.provider.request({
          method: METHOD_TYPES.ETH_GET_BLOCK_BY_HASH,
          params: [transactionReceipt.blockHash, false]
        });
        this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_CONFIRMED, {
          txId,
          txReceipt: transactionReceipt,
          baseFeePerGas,
          blockTimestamp: timestamp
        });
        return;
      }
    } catch (error) {
      external_loglevel_default().error("error while loading tx", error);
      txMeta.warning = {
        error: error.message,
        message: "There was a problem loading this transaction."
      };
      this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_WARNING, {
        txMeta
      });
    }
    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_DROPPED, {
        txId
      });
    }
  }
  async _checkIfTxWasDropped(txMeta) {
    const {
      transactionHash: txHash,
      transaction: {
        nonce,
        from
      }
    } = txMeta;
    const networkNextNonce = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [from, "latest"]
    });
    if (Number.parseInt(nonce, 16) >= Number.parseInt(networkNextNonce, 16)) {
      return false;
    }
    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }
    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);
    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }
    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }
  _checkIfNonceIsTaken(txMeta) {
    const address = txMeta.transaction.from;
    const completed = this.getConfirmedTransactions(address);
    return completed.some(otherMeta => {
      if (otherMeta.id === txMeta.id) {
        return false;
      }
      return otherMeta.transaction.nonce === txMeta.transaction.nonce;
    });
  }
}
;// CONCATENATED MODULE: ./src/Transaction/TransactionGasUtil.ts





class TransactionGasUtil {
  constructor(provider, blockTracker) {
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "blockTracker", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.blockTracker.getLatestBlock();
    // fallback to block gasLimit
    const blockGasLimitBN = new external_bn_js_namespaceObject.BN((0,util_namespaceObject.stripHexPrefix)(block.gasLimit), 16);
    const saferGasLimitBN = blockGasLimitBN.mul(new external_bn_js_namespaceObject.BN(19)).div(new external_bn_js_namespaceObject.BN(20));
    let estimatedGasHex = (0,util_namespaceObject.addHexPrefix)(saferGasLimitBN.toString("hex"));
    let simulationFails;
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      external_loglevel_default().warn(error);
      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.idempotencyKey,
          blockGasLimit: block.gasLimit
        }
      };
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }

  /**
    Adds a gas buffer with out exceeding the block gas limit
  */
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = new external_bn_js_namespaceObject.BN((0,util_namespaceObject.stripHexPrefix)(initialGasLimitHex), 16);
    const blockGasLimitBn = new external_bn_js_namespaceObject.BN((0,util_namespaceObject.stripHexPrefix)(blockGasLimitHex), 16);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return (0,util_namespaceObject.addHexPrefix)(initialGasLimitBn.toString("hex"));
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return (0,util_namespaceObject.addHexPrefix)(bufferedGasLimitBn.toString("hex"));
    // otherwise use blockGasLimit
    return (0,util_namespaceObject.addHexPrefix)(upperGasLimitBn.toString("hex"));
  }

  /**
    Estimates the tx's gas usage
  */
  async estimateTxGas(txMeta) {
    const txParams = (0,base_controllers_namespaceObject.cloneDeep)(txMeta.transaction);

    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    return this.provider.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
  }
}
;// CONCATENATED MODULE: ./src/utils/lodashUtils.ts
function sortBy(arr, key) {
  return arr.slice().sort((a, b) => {
    if (a[key] < b[key]) return -1;
    if (a[key] > b[key]) return 1;
    return 0;
  });
}
function keyBy(arr, key) {
  return arr.reduce((acc, item) => {
    const keyValue = item[key];
    if (typeof keyValue === "string" || typeof keyValue === "number") {
      acc[keyValue.toString()] = item;
    }
    return acc;
  }, {});
}
function mapValues(obj, iteratee) {
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, iteratee(value, key)]));
}
;// CONCATENATED MODULE: external "fast-json-patch"
const external_fast_json_patch_namespaceObject = require("fast-json-patch");
var external_fast_json_patch_default = /*#__PURE__*/__webpack_require__.n(external_fast_json_patch_namespaceObject);
;// CONCATENATED MODULE: ./src/Transaction/TransactionStateHistoryHelper.ts



/**
  Generates an array of history objects sense the previous state.
  The object has the keys
    op (the operation performed),
    path (the key and if a nested object then each key will be seperated with a `/`)
    value
  with the first entry having the note and a timestamp when the change took place
*/
function generateHistoryEntry(previousState, newState, note) {
  const entry = external_fast_json_patch_default().compare(previousState, newState);
  // Add a note to the first op, since it breaks if we append it to the entry
  if (entry[0]) {
    if (note) {
      entry[0].note = note;
    }
    entry[0].timestamp = Date.now();
  }
  return entry;
}

/**
  Recovers previous txMeta state obj
*/
function replayHistory(_shortHistory) {
  const shortHistory = (0,base_controllers_namespaceObject.cloneDeep)(_shortHistory);
  return shortHistory.reduce((val, entry) => external_fast_json_patch_default().applyPatch(val, entry).newDocument);
}
function snapshotFromTxMeta(txMeta) {
  const shallow = objectSpread2_default()({}, txMeta);
  delete shallow.history;
  return (0,base_controllers_namespaceObject.cloneDeep)(shallow);
}

;// CONCATENATED MODULE: ./src/Transaction/TransactionStateManager.ts





class TransactionStateManager extends base_controllers_namespaceObject.BaseTransactionStateManager {
  constructor({
    config,
    state,
    getCurrentChainId
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
  }
  generateTxMeta(opts = {}) {
    var _opts$transaction;
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") throw new Error("Torus is having trouble connecting to the network");
    let dappSuggestedGasFees = null;

    // If we are dealing with a transaction suggested by a dapp and not
    // an internally created transaction, we need to keep record of
    // the originally submitted gasParams.
    if (opts.transaction && typeof opts.origin === "string" && opts.origin !== "torus") {
      if (typeof opts.transaction.gasPrice !== "undefined") {
        dappSuggestedGasFees = {
          gasPrice: opts.transaction.gasPrice
        };
      } else if (typeof opts.transaction.maxFeePerGas !== "undefined" || typeof opts.transaction.maxPriorityFeePerGas !== "undefined") {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.transaction.maxPriorityFeePerGas,
          maxFeePerGas: opts.transaction.maxFeePerGas
        };
      }
      if (typeof opts.transaction.gas !== "undefined") {
        dappSuggestedGasFees = objectSpread2_default()(objectSpread2_default()({}, dappSuggestedGasFees), {}, {
          gas: opts.transaction.gas
        });
      }
    }
    return objectSpread2_default()({
      id: ((_opts$transaction = opts.transaction) === null || _opts$transaction === void 0 ? void 0 : _opts$transaction.id) || (0,base_controllers_namespaceObject.randomId)(),
      time: Date.now(),
      status: base_controllers_namespaceObject.TransactionStatus.unapproved,
      loadingDefaults: true,
      chainId,
      dappSuggestedGasFees
    }, opts);
  }
  addTransactionToState(txMeta) {
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }
    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    });
    // initialize history
    txMeta.history = [];
    // capture initial snapshot of txMeta for history
    const snapshot = snapshotFromTxMeta(txMeta);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this.config;

    // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.
    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce
      } = tx.transaction;
      const {
        chainId,
        status
      } = tx;
      const key = `${nonce}-${chainId}`;
      if (nonceNetworkSet.has(key)) {
        return false;
      }
      if (nonceNetworkSet.size < txHistoryLimit - 1 || getFinalStates().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }
      return true;
    }).map(tx => tx.id);
    this._deleteTransactions(txsToDelete);
    this._addTransactionsToState([txMeta]);
    return txMeta;
  }

  /**
    Removes transaction from the given address for the current network
    from the txList
  */
  wipeTransactions(address) {
    const {
      transactions
    } = this.state;
    const chainId = this.getCurrentChainId();
    this.update({
      transactions: (0,base_controllers_namespaceObject.omitBy)(transactions, txMeta => {
        const transactionMatch = (0,base_controllers_namespaceObject.transactionMatchesNetwork)(txMeta, chainId);
        return txMeta.transaction.from === address && transactionMatch;
      })
    });
  }
  getTransactions({
    searchCriteria = {},
    initialList = undefined,
    filterToCurrentNetwork = true,
    limit = undefined
  } = {}) {
    const chainId = this.getCurrentChainId();
    // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.
    const predicateMethods = mapValues(searchCriteria, predicate => typeof predicate === "function" ? predicate : v => v === predicate);

    // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.
    const transactionsToFilter = initialList ? keyBy(initialList, "id") : this.state.transactions;

    // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.
    const filteredTransactions = sortBy(Object.values((0,base_controllers_namespaceObject.pickBy)(transactionsToFilter, txMeta => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      const transactionMatches = (0,base_controllers_namespaceObject.transactionMatchesNetwork)(txMeta, chainId);
      if (filterToCurrentNetwork && !transactionMatches) {
        return false;
      }
      // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria
      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in txMeta.transaction) {
          if (predicate(txMeta.transaction[key]) === false) {
            return false;
          }
        } else if (predicate(txMeta[key]) === false) {
          return false;
        }
      }
      return true;
    })), "time");
    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = [];
      // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.
      for (let i = filteredTransactions.length - 1; i > -1; i -= 1) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.transaction;
        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        }
        // Push transaction into the beginning of our array to ensure the
        // original order is preserved.
        txs.unshift(txMeta);
      }
      return txs;
    }
    return filteredTransactions;
  }
  getApprovedTransactions(address) {
    const searchCriteria = {
      status: base_controllers_namespaceObject.TransactionStatus.approved
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getSubmittedTransactions(address) {
    const searchCriteria = {
      status: base_controllers_namespaceObject.TransactionStatus.submitted
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getPendingTransactions(address) {
    const submitted = this.getSubmittedTransactions(address);
    const approved = this.getApprovedTransactions(address);
    return [...submitted, ...approved];
  }
  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: base_controllers_namespaceObject.TransactionStatus.confirmed
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    return (0,base_controllers_namespaceObject.pickBy)(this.state.transactions, transaction => {
      const transactionMatches = (0,base_controllers_namespaceObject.transactionMatchesNetwork)(transaction, chainId);
      return transaction.status === base_controllers_namespaceObject.TransactionStatus.unapproved && transactionMatches;
    });
  }
  updateTransactionInState(txMeta, note) {
    // validate txParams
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }

    // create txMeta snapshot for history
    const currentState = snapshotFromTxMeta(txMeta);
    // recover previous tx state obj
    const previousState = replayHistory(txMeta.history);
    // generate history entry and add to history
    const entry = generateHistoryEntry(previousState, currentState, note);
    if (entry.length > 0) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      txMeta.history.push(entry);
    }

    // commit txMeta to state
    this.updateTransaction(txMeta);
  }
  _setTransactionStatus(txId, status, isFinalStep) {
    const txMeta = this.getTransaction(txId);
    if (!txMeta) {
      return;
    }
    txMeta.status = status;
    this.updateTransactionInState(txMeta);
    this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_STATUS_UPDATE, {
      txId,
      status
    });
    if (this.isFinalState(status) || isFinalStep) {
      this.emit(`${txMeta.id}:finished`, txMeta);
    } else {
      this.emit(`${txMeta.id}:${status}`, txId);
    }
  }
}
;// CONCATENATED MODULE: ./src/Transaction/TransactionController.ts
















class TransactionController extends TransactionStateManager {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    signEthTx,
    getCurrentChainId,
    getCurrentNetworkEIP1559Compatibility,
    getProviderConfig,
    getCurrentAccountEIP1559Compatibility,
    getSelectedAddress,
    getEIP1559GasFeeEstimates
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
    defineProperty_default()(this, "getSelectedAddress", void 0);
    defineProperty_default()(this, "getEIP1559GasFeeEstimates", void 0);
    defineProperty_default()(this, "nonceTracker", void 0);
    defineProperty_default()(this, "pendingTxTracker", void 0);
    defineProperty_default()(this, "txGasUtil", void 0);
    defineProperty_default()(this, "_getCurrentNetworkEIP1559Compatibility", void 0);
    defineProperty_default()(this, "_getCurrentAccountEIP1559Compatibility", void 0);
    defineProperty_default()(this, "getProviderConfig", void 0);
    defineProperty_default()(this, "signEthTx", void 0);
    defineProperty_default()(this, "provider", void 0);
    defineProperty_default()(this, "blockTracker", void 0);
    defineProperty_default()(this, "inProcessOfSigning", new Set());
    defineProperty_default()(this, "getUnapprovedTxCount", () => Object.keys(this.getUnapprovedTxList()).length);
    defineProperty_default()(this, "getPendingTxCount", account => this.getPendingTransactions(account).length);
    this.blockTracker = blockTracker;
    this.getProviderConfig = getProviderConfig;
    this._getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.getSelectedAddress = getSelectedAddress;
    this.getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.signEthTx = signEthTx;
    this.provider = provider;
    this.txGasUtil = new TransactionGasUtil(this.provider, this.blockTracker);
    this.nonceTracker = new Transaction_NonceTracker({
      provider,
      blockTracker,
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      getPendingTransactions: this.getSubmittedTransactions.bind(this) // nonce tracker should only care about submitted transactions
    });
    this.pendingTxTracker = new PendingTransactionTracker({
      provider,
      nonceTracker: this.nonceTracker,
      getPendingTransactions: this.getPendingTransactions.bind(this),
      // pending tx tracker should only care about submitted and approved transactions
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      approveTransaction: this.approveTransaction.bind(this),
      publishTransaction: rawTx => this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      })
    });
    this._setupListeners();
  }
  addTransactionUnapproved(txMeta) {
    this.addTransactionToState(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);
  }
  async addNewUnapprovedTransaction(txParams, req) {
    const txMeta = await this.createTransaction(txParams, req);
    return this.processApproval(txMeta);
  }
  async processApproval(txMeta) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === base_controllers_namespaceObject.TransactionStatus.rejected) {
          return reject(openlogin_jrpc_namespaceObject.providerErrors.userRejectedRequest(`Transaction Signature: User denied message signature`));
        }
        if (msg.status === base_controllers_namespaceObject.TransactionStatus.failed) {
          return reject(openlogin_jrpc_namespaceObject.rpcErrors.internal(`Transaction Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === base_controllers_namespaceObject.TransactionStatus.submitted) {
          return resolve(msg.transactionHash);
        }
        return reject(openlogin_jrpc_namespaceObject.rpcErrors.internal(`Transaction Signature: Unknown problem: ${JSON.stringify(txMeta.transaction)}`));
      };
      this.once(`${txMeta.id}:finished`, handleFinished);
    });
  }
  async approveTransaction(transactionID) {
    const txMeta = this.getTransaction(transactionID);
    if (this.inProcessOfSigning.has(transactionID)) {
      return;
    }
    this.inProcessOfSigning.add(transactionID);
    let nonceLock;
    try {
      this.setTxStatusApproved(transactionID);
      const fromAddress = txMeta.transaction.from;
      const {
        customNonceValue
      } = txMeta.transaction;
      const customNonceValueNumber = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);
      // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated
      const nonce = nonceLock.nextNonce;
      const customOrNonce = customNonceValueNumber === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.transaction.nonce = (0,util_namespaceObject.addHexPrefix)(customOrNonce.toString(16));
      // add nonce debugging information to txMeta
      txMeta.nonceDetails = nonceLock.nonceDetails;
      this.updateTransactionInState(txMeta, "transactions#approveTransaction");
      // sign transaction
      const rawTx = await this.signTransaction(transactionID);
      await this.publishTransaction(transactionID, rawTx);
      nonceLock.releaseLock();
    } catch (err) {
      try {
        this.setTxStatusFailed(transactionID, err);
      } catch (err2) {
        external_loglevel_default().error(err2);
      }
      // must set transaction to submitted/failed before releasing lock
      if (nonceLock) {
        nonceLock.releaseLock();
      }
      // continue with error chain
      throw err;
    } finally {
      this.inProcessOfSigning.delete(transactionID);
    }
  }
  async signTransaction(txId) {
    const txMeta = this.getTransaction(txId);
    const chainId = this.getCurrentChainId();
    const type = isEIP1559Transaction(txMeta) ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
    const txParams = objectSpread2_default()(objectSpread2_default()({}, txMeta.transaction), {}, {
      type,
      chainId,
      gasLimit: txMeta.transaction.gas
    });
    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(fromAddress);
    const {
      TransactionFactory
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 81, 23));
    const unsignedEthTx = TransactionFactory.fromTxData(txParams, {
      common
    });
    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);
    txMeta.r = (0,util_namespaceObject.addHexPrefix)(signedEthTx.r.toString(16));
    txMeta.s = (0,util_namespaceObject.addHexPrefix)(signedEthTx.s.toString(16));
    txMeta.v = (0,util_namespaceObject.addHexPrefix)(signedEthTx.v.toString(16));
    this.updateTransactionInState(txMeta, "transactions#signTransaction: add r, s, v values");
    this.setTxStatusSigned(txId);
    const rawTx = (0,util_namespaceObject.addHexPrefix)(Buffer.from(signedEthTx.serialize()).toString("hex"));
    return rawTx;
  }
  async publishTransaction(txId, rawTx) {
    const txMeta = this.getTransaction(txId);
    txMeta.rawTransaction = rawTx;
    this.updateTransactionInState(txMeta, "transactions#publishTransaction");
    let txHash;
    try {
      txHash = await this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      });
    } catch (error) {
      if (error.message.toLowerCase().includes("known transaction")) {
        txHash = (0,external_ethers_namespaceObject.keccak256)((0,util_namespaceObject.addHexPrefix)(rawTx));
        txHash = (0,util_namespaceObject.addHexPrefix)(txHash);
      } else {
        throw error;
      }
    }
    this.setTxHash(txId, txHash);
    this.setTxStatusSubmitted(txId);
  }
  async confirmTransaction(params) {
    const {
      txId,
      txReceipt
    } = params;
    external_loglevel_default().info(params, "confirm params");
    const txMeta = this.getTransaction(txId);
    if (!txMeta) return;
    try {
      txMeta.txReceipt = objectSpread2_default()({}, txReceipt);
      this.setTxStatusConfirmed(txId);
      this.markNonceDuplicatesDropped(txId);
      this.updateTransactionInState(txMeta, "transactions#confirmTransaction - add txReceipt");
    } catch (error) {
      external_loglevel_default().error(error);
    }
  }
  cancelTransaction(transactionID) {
    throw new Error(`Method not implemented. ${transactionID}`);
  }
  async getEIP1559Compatibility(fromAddress) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }
  async addTransactionGasDefaults(txMeta) {
    let updateTxMeta = txMeta;
    try {
      updateTxMeta = await this.addTxGasDefaults(txMeta);
    } catch (error) {
      external_loglevel_default().warn(error);
      updateTxMeta = this.getTransaction(txMeta.id);
      updateTxMeta.loadingDefaults = false;
      this.updateTransactionInState(txMeta, "Failed to calculate gas defaults.");
      throw error;
    }
    updateTxMeta.loadingDefaults = false;
    this.updateTransactionInState(updateTxMeta, "Added new unapproved transaction.");
    return updateTxMeta;
  }
  async addTxGasDefaults(txMeta) {
    const eip1559Compatibility = txMeta.transaction.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this.getDefaultGasFees(txMeta, eip1559Compatibility);
    const {
      gasLimit: defaultGasLimit,
      simulationFails
    } = await this.getDefaultGasLimit(txMeta);
    txMeta = this.getTransaction(txMeta.id);
    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }
    if (eip1559Compatibility) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (txMeta.transaction.gasPrice && !txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
        txMeta.transaction.maxFeePerGas = txMeta.transaction.gasPrice;
        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
        // then we set maxFeePerGas to the suggested gasPrice.

        txMeta.transaction.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? (0,util_namespaceObject.stripHexPrefix)(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof txMeta.transaction.gasPrice === "string" ? (0,util_namespaceObject.stripHexPrefix)(txMeta.transaction.gasPrice) : txMeta.transaction.gasPrice) ? defaultMaxPriorityFeePerGas : txMeta.transaction.gasPrice;
      } else {
        if (defaultMaxFeePerGas && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxFeePerGas = defaultMaxFeePerGas;
        }
        if (defaultMaxPriorityFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }
        if (defaultGasPrice && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.transaction.maxFeePerGas = defaultGasPrice;
        }
        if (txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.transaction.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.transaction.maxPriorityFeePerGas = txMeta.transaction.maxFeePerGas;
        }
      }

      // We remove the gasPrice param entirely when on an eip1559 compatible network

      delete txMeta.transaction.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network

      delete txMeta.transaction.maxPriorityFeePerGas;
      delete txMeta.transaction.maxFeePerGas;
    }

    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on transaction, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.
    if (defaultGasPrice && !txMeta.transaction.gasPrice && !txMeta.transaction.maxPriorityFeePerGas && !txMeta.transaction.maxFeePerGas) {
      txMeta.transaction.gasPrice = defaultGasPrice;
    }
    if (defaultGasLimit && !txMeta.transaction.gas) {
      txMeta.transaction.gas = defaultGasLimit;
    }
    return txMeta;
  }
  setTxHash(txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.getTransaction(txId);
    txMeta.transactionHash = txHash;
    this.updateTransactionInState(txMeta, "transactions#setTxHash");
  }
  async getDefaultGasFees(txMeta, eip1559Compatibility) {
    if (!eip1559Compatibility && txMeta.transaction.gasPrice || eip1559Compatibility && txMeta.transaction.maxFeePerGas && txMeta.transaction.maxPriorityFeePerGas) {
      return {};
    }
    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this.getEIP1559GasFeeEstimates();
      if (eip1559Compatibility && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        // this is in dec gwei
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;
        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            // send to controller in hex wei
            maxFeePerGas: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(new (external_bignumber_js_default())(suggestedMaxFeePerGas)).toString(16)),
            maxPriorityFeePerGas: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(new (external_bignumber_js_default())(suggestedMaxPriorityFeePerGas)).toString(16))
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        const {
          medium
        } = gasFeeEstimates;
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(new (external_bignumber_js_default())(medium)).toString(16))
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        const {
          gasPrice
        } = gasFeeEstimates;
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: (0,util_namespaceObject.addHexPrefix)(decGWEIToHexWEI(new (external_bignumber_js_default())(gasPrice)).toString(16))
        };
      }
    } catch (error) {
      external_loglevel_default().error(error);
    }
    const gasPrice = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_GAS_PRICE
    });
    return {
      gasPrice: gasPrice && (0,util_namespaceObject.addHexPrefix)(gasPrice)
    };
  }
  async getDefaultGasLimit(txMeta) {
    const chainId = this.getCurrentChainId();
    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = getChainType(chainId);
    if (txMeta.transaction.gas) {
      return {};
    }
    if (txMeta.transaction.to && txMeta.transactionCategory === base_controllers_namespaceObject.TRANSACTION_TYPES.SENT_ETHER && chainType !== "custom" && !txMeta.transaction.data) {
      // This is a standard ether simple send, gas requirement is exactly 21k
      return {
        gasLimit: GAS_LIMITS.SIMPLE
      };
    }
    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.txGasUtil.analyzeGasUsage(txMeta);

    // add additional gas buffer to our estimation for safety
    const gasLimit = this.txGasUtil.addGasBuffer((0,util_namespaceObject.addHexPrefix)(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return {
      gasLimit,
      simulationFails
    };
  }
  async createTransaction(txParameters, req) {
    const normalizedTxParameters = normalizeTxParameters(txParameters);
    const eip1559Compatibility = await this.getEIP1559Compatibility(txParameters.from);
    validateTxParameters(normalizedTxParameters, eip1559Compatibility);
    let txMeta = this.generateTxMeta({
      transaction: normalizedTxParameters,
      origin: req.origin
    });
    const {
      type,
      category,
      methodParams
    } = await determineTransactionType(txParameters, this.provider);
    txMeta.contractType = type;
    txMeta.transactionCategory = category;
    txMeta.methodParams = methodParams;
    txMeta.transaction.value = txMeta.transaction.value ? (0,util_namespaceObject.addHexPrefix)(txMeta.transaction.value) : "0x0";
    this.emit(`${txMeta.id}:unapproved`, txMeta);
    txMeta = this.addTransactionToState(txMeta);
    txMeta = await this.addTransactionGasDefaults(txMeta);
    this.emit(base_controllers_namespaceObject.TX_EVENTS.TX_UNAPPROVED, {
      txMeta,
      req
    });
    return txMeta;
  }
  _setupListeners() {
    this.setupBlockTrackerListener();
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_WARNING, data => {
      this.updateTransactionInState(data.txMeta);
    });
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_DROPPED, data => this.setTxStatusDropped(data.txId));
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_BLOCK_UPDATE, ({
      txMeta,
      latestBlockNumber
    }) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber;
        this.updateTransactionInState(txMeta);
      }
    });
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_RETRY, txMeta => {
      if (!("retryCount" in txMeta)) {
        txMeta.retryCount = 0;
      }
      txMeta.retryCount += 1;
      this.updateTransactionInState(txMeta);
    });
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_FAILED, data => {
      this.setTxStatusFailed(data.txId, data.error);
    });
    this.pendingTxTracker.on(base_controllers_namespaceObject.TX_EVENTS.TX_CONFIRMED, data => this.confirmTransaction(data));
  }
  setupBlockTrackerListener() {
    let listenersAreActive = false;
    const latestBlockHandler = this.onLatestBlock.bind(this);
    this.on(base_controllers_namespaceObject.TX_EVENTS.TX_STATUS_UPDATE, () => {
      const pendingTxs = this.getPendingTransactions();
      if (!listenersAreActive && pendingTxs.length > 0) {
        this.blockTracker.on("latest", latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        this.blockTracker.removeListener("latest", latestBlockHandler);
        listenersAreActive = false;
      }
    });
  }
  async onLatestBlock(blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (error) {
      external_loglevel_default().error(error);
    }
    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (error) {
      external_loglevel_default().error(error);
    }
  }
  async getCommonConfiguration(fromAddress) {
    const {
      chainId,
      displayName
    } = this.getProviderConfig();
    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress);
    const {
      Common,
      Hardfork
    } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 652, 23));
    const hardfork = supportsEIP1559 ? Hardfork.Paris : Hardfork.Berlin;
    return Common.custom({
      chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
      defaultHardfork: hardfork,
      name: displayName,
      networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16)
    });
  }
  markNonceDuplicatesDropped(txId) {
    const txMeta = this.getTransaction(txId);
    const {
      nonce,
      from
    } = txMeta.transaction;
    const sameNonceTxs = this.getTransactions({
      searchCriteria: {
        from,
        nonce
      }
    });
    if (!sameNonceTxs.length) return;
    sameNonceTxs.forEach(tx => {
      if (tx.id === txId) return;
      this.updateTransactionInState(txMeta, "transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce");
      if (tx.status !== base_controllers_namespaceObject.TransactionStatus.failed) this.setTxStatusDropped(tx.id);
    });
  }
}
;// CONCATENATED MODULE: ./src/index.ts







































/**
 * Pending controllers
 * - Transaction Controllers
//  * - AA Controller
 */

/**
 * Backend apis
 * - Preferences Controller
 */
module.exports = __webpack_exports__;
/******/ })()
;