import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { CHAIN_NAMESPACES, BaseController, randomId, TransactionStatus, TRANSACTION_TYPES, formatSmallNumbers, addressSlicer, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, significantDigits, BaseBlockTracker, timeout, BaseCurrencyController, cloneDeep, BaseKeyringController, PROVIDER_JRPC_METHODS, createFetchMiddleware, createInflightCacheMiddleware, createSwappableProxy, createEventEmitterProxy, BasePreferencesController, isUnauthorizedError, TX_EVENTS, BaseTransactionStateManager, omitBy, transactionMatchesNetwork as transactionMatchesNetwork$1, pickBy } from '@toruslabs/base-controllers';
import { Mutex } from 'async-mutex';
import { BrowserProvider, toQuantity, Contract, Interface, isHexString as isHexString$1, JsonRpcProvider, keccak256 } from 'ethers';
import log from 'loglevel';
import { isHexString, addHexPrefix, isValidAddress, stripHexPrefix, toChecksumAddress, bytesToHex, privateToPublic, privateToAddress, ecsign, bigIntToBytes } from '@ethereumjs/util';
import BigNumber from 'bignumber.js';
import { rpcErrors, providerErrors, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware, providerFromMiddleware, JRPCEngine, providerFromEngine, SafeEventEmitter } from '@toruslabs/openlogin-jrpc';
import { get } from '@toruslabs/http-helpers';
import _objectDestructuringEmpty from '@babel/runtime/helpers/objectDestructuringEmpty';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import BN, { BN as BN$1 } from 'bn.js';
import { concatSig, personalSign, signTypedData, getEncryptionPublicKey, decrypt, typedSignatureHash, TYPED_MESSAGE_SCHEMA, SignTypedDataVersion } from '@metamask/eth-sig-util';
import stringify from 'fast-safe-stringify';
import deepmerge from 'deepmerge';
import jsonDiffer from 'fast-json-patch';

const erc20Abi = [{
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "decimals",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "balance",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_to",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_spender",
    type: "address"
  }, {
    name: "_value",
    type: "uint256"
  }, {
    name: "_extraData",
    type: "bytes"
  }],
  name: "approveAndCall",
  outputs: [{
    name: "success",
    type: "bool"
  }],
  payable: false,
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_spender",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    name: "remaining",
    type: "uint256"
  }],
  payable: false,
  type: "function"
}, {
  inputs: [{
    name: "_initialAmount",
    type: "uint256"
  }, {
    name: "_tokenName",
    type: "string"
  }, {
    name: "_decimalUnits",
    type: "uint8"
  }, {
    name: "_tokenSymbol",
    type: "string"
  }],
  type: "constructor"
}, {
  payable: false,
  type: "fallback"
}];
const erc721Abi = [{
  constant: true,
  inputs: [{
    name: "interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    type: "bool"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "name",
  outputs: [{
    name: "_name",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_approved",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "approve",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }, {
    name: "_index",
    type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: false,
  inputs: [{
    name: "_from",
    type: "address"
  }, {
    name: "_to",
    type: "address"
  }, {
    name: "_tokenId",
    type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  payable: true,
  stateMutability: "payable",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_index",
    type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
    name: "",
    type: "address"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_owner",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "_symbol",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "_tokenId",
    type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
    name: "",
    type: "string"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}];
const erc1155Abi = [{
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "balanceOf",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address[]",
    name: "_owners",
    type: "address[]"
  }, {
    internalType: "uint256[]",
    name: "_ids",
    type: "uint256[]"
  }],
  name: "balanceOfBatch",
  outputs: [{
    internalType: "uint256[]",
    name: "",
    type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_owner",
    type: "address"
  }, {
    internalType: "address",
    name: "_operator",
    type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
    internalType: "bool",
    name: "isOperator",
    type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_from",
    type: "address"
  }, {
    internalType: "address",
    name: "_to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }, {
    internalType: "uint256",
    name: "_amount",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "_operator",
    type: "address"
  }, {
    internalType: "bool",
    name: "_approved",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes4",
    name: "_interfaceID",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "pure",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "_id",
    type: "uint256"
  }],
  name: "uri",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const singleBalanceCheckerAbi = [{
  payable: true,
  stateMutability: "payable",
  type: "fallback"
}, {
  constant: true,
  inputs: [{
    name: "user",
    type: "address"
  }, {
    name: "token",
    type: "address"
  }],
  name: "tokenBalance",
  outputs: [{
    name: "",
    type: "uint256"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  constant: true,
  inputs: [{
    name: "users",
    type: "address[]"
  }, {
    name: "tokens",
    type: "address[]"
  }],
  name: "balances",
  outputs: [{
    name: "",
    type: "uint256[]"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}];

const LOCALHOST = "localhost";
const CONTRACT_TYPE_ETH = "eth";
const CONTRACT_TYPE_ERC20 = "erc20";
const CONTRACT_TYPE_ERC721 = "erc721";
const CONTRACT_TYPE_ERC1155 = "erc1155";
const ERC1155_INTERFACE_ID = "0xd9b67a26";
const ERC721_INTERFACE_ID = "0x80ac58cd";
const ERC721_METADATA_INTERFACE_ID = "0x5b5e139f";
const ERC721_ENUMERABLE_INTERFACE_ID = "0x780e9d63";
const MAINNET_CHAIN_ID = "0x1";
const POLYGON_CHAIN_ID = "0x89";
const BSC_MAINNET_CHAIN_ID = "0x38";
const AVALANCHE_MAINNET_CHAIN_ID = "0xa86a";
const XDAI_CHAIN_ID = "0x64";
const ARBITRUM_MAINNET_CHAIN_ID = "0xa4b1";
const OPTIMISM_MAINNET_CHAIN_ID = "0xa";
const CELO_MAINNET_CHAIN_ID = "0xa4ec";
const BASE_CHAIN_ID = "0x2105";
const SEPOLIA_CHAIN_ID = "0xaa36a7";
const POLYGON_AMOY_CHAIN_ID = "0x13882";
const BSC_TESTNET_CHAIN_ID = "0x61";
const AVALANCHE_TESTNET_CHAIN_ID = "0xa869";
const ARBITRUM_TESTNET_CHAIN_ID = "0x66eee";
const OPTIMISM_TESTNET_CHAIN_ID = "0xaa37dc";
const BASE_TESTNET_CHAIN_ID = "0x14a34";
const INFURA_KEY = process.env.VITE_APP_INFURA_PROJECT_KEY;
const SUPPORTED_NETWORKS = {
  [MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://etherscan.io",
    chainId: MAINNET_CHAIN_ID,
    displayName: "Ethereum",
    logo: "eth.svg",
    rpcTarget: `https://mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [POLYGON_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://polygonscan.com",
    chainId: POLYGON_CHAIN_ID,
    displayName: "Polygon",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://bscscan.com",
    chainId: BSC_MAINNET_CHAIN_ID,
    displayName: "Binance Smart Chain (BSC)",
    logo: "bnb_logo.svg",
    rpcTarget: `https://bsc-dataseed.binance.org`,
    ticker: "BNB",
    tickerName: "Binance Coin"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://snowtrace.io",
    chainId: AVALANCHE_MAINNET_CHAIN_ID,
    displayName: "Avalanche",
    logo: "avax.svg",
    rpcTarget: `https://api.avax.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://optimistic.etherscan.io",
    chainId: OPTIMISM_MAINNET_CHAIN_ID,
    displayName: "Optimism",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://explorer.celo.org",
    chainId: CELO_MAINNET_CHAIN_ID,
    displayName: "Celo Mainnet",
    logo: "celo.svg",
    rpcTarget: `https://celo-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "CELO",
    tickerName: "Celo"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://arbiscan.io",
    chainId: ARBITRUM_MAINNET_CHAIN_ID,
    displayName: "Arbitrum One",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-mainnet.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [XDAI_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://gnosis.blockscout.com",
    chainId: XDAI_CHAIN_ID,
    displayName: "xDai",
    logo: "xDai.svg",
    rpcTarget: `https://rpc.gnosischain.com`,
    ticker: "DAI",
    tickerName: "xDai Token"
  },
  [BASE_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://basescan.org",
    chainId: BASE_CHAIN_ID,
    displayName: "Base",
    logo: "base.svg",
    rpcTarget: `https://mainnet.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum"
  },
  [SEPOLIA_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.etherscan.io",
    chainId: SEPOLIA_CHAIN_ID,
    displayName: "Sepolia Test Network",
    logo: "eth.svg",
    rpcTarget: `https://sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [POLYGON_AMOY_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://amoy.polygonscan.com",
    chainId: POLYGON_AMOY_CHAIN_ID,
    displayName: "Polygon Amoy",
    logo: "polygon.svg",
    rpcTarget: `https://polygon-amoy.infura.io/v3/${INFURA_KEY}`,
    ticker: "MATIC",
    tickerName: "Matic Network Token",
    isTestnet: true
  },
  [BSC_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.bscscan.com",
    chainId: BSC_TESTNET_CHAIN_ID,
    displayName: "Binance Smart Chain Testnet",
    logo: "bnb_logo.svg",
    rpcTarget: `https://data-seed-prebsc-1-s1.binance.org:8545`,
    ticker: "BNB",
    tickerName: "Binance Coin",
    isTestnet: true
  },
  [AVALANCHE_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://testnet.snowtrace.io",
    chainId: AVALANCHE_TESTNET_CHAIN_ID,
    displayName: "Avalanche Testnet C-Chain",
    logo: "avax.svg",
    rpcTarget: `https://api.avax-test.network/ext/bc/C/rpc`,
    ticker: "AVAX",
    tickerName: "Avalanche",
    isTestnet: true
  },
  [ARBITRUM_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.arbiscan.io",
    chainId: ARBITRUM_TESTNET_CHAIN_ID,
    displayName: "Arbitrum Sepolia",
    logo: "arbitrum.svg",
    rpcTarget: `https://arbitrum-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [OPTIMISM_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia-optimistic.etherscan.io",
    chainId: OPTIMISM_TESTNET_CHAIN_ID,
    displayName: "Optimism Sepolia",
    logo: "optimism.svg",
    rpcTarget: `https://optimism-sepolia.infura.io/v3/${INFURA_KEY}`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  },
  [BASE_TESTNET_CHAIN_ID]: {
    chainNamespace: CHAIN_NAMESPACES.EIP155,
    decimals: 18,
    blockExplorerUrl: "https://sepolia.basescan.org",
    chainId: BASE_TESTNET_CHAIN_ID,
    displayName: "Base Sepolia",
    logo: "base.svg",
    rpcTarget: `https://sepolia.base.org`,
    ticker: "ETH",
    tickerName: "Ethereum",
    isTestnet: true
  }
};
const METHOD_TYPES = {
  GET_ACCOUNTS: "eth_accounts",
  ETH_TRANSACTION: "eth_sendTransaction",
  ETH_REQUEST_ACCOUNTS: "eth_requestAccounts",
  ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  PERSONAL_SIGN: "personal_sign",
  ETH_GET_TRANSACTION_COUNT: "eth_getTransactionCount",
  ETH_GET_TRANSACTION_BY_HASH: "eth_getTransactionByHash",
  ETH_GET_ENCRYPTION_PUBLIC_KEY: "eth_getEncryptionPublicKey",
  ETH_DECRYPT: "eth_decrypt",
  ETH_GET_TRANSACTION_RECEIPT: "eth_getTransactionReceipt",
  WATCH_ASSET: "wallet_watchAsset",
  ETH_GET_BLOCK_BY_HASH: "eth_getBlockByHash",
  ETH_GET_CODE: "eth_getCode",
  ETH_GET_GAS_PRICE: "eth_gasPrice",
  SWITCH_CHAIN: "wallet_switchEthereumChain",
  ADD_CHAIN: "wallet_addEthereumChain"
};
const TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
};
const GAS_ESTIMATE_TYPES = {
  // Fee Market describes the way gas is set after the london hardfork, and was
  // defined by EIP-1559.
  FEE_MARKET: "fee-market",
  // Legacy describes gasPrice estimates from before london hardfork, when the
  // user is connected to mainnet and are presented with fast/average/slow
  // estimate levels to choose from.
  LEGACY: "legacy",
  // EthGasPrice describes a gasPrice estimate received from eth_gasPrice. Post
  // london this value should only be used for legacy type transactions when on
  // networks that support EIP-1559. This type of estimate is the most accurate
  // to display on custom networks that don't support EIP-1559.
  ETH_GASPRICE: "eth_gasPrice",
  // NoEstimate describes the state of the controller before receiving its first
  // estimate.
  NONE: "none"
};

// https://help.optimism.io/hc/en-us/articles/4411895794715-Transaction-fees
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [OPTIMISM_MAINNET_CHAIN_ID]: 1,
  [OPTIMISM_TESTNET_CHAIN_ID]: 1
};
const OLD_ERC721_LIST = {
  "0x06012c8cf97bead5deae237070f9587f8e7a266d": {
    name: "Cryptokitties",
    logo: "dapp-cryptokitty.svg",
    erc20: true,
    symbol: "CK",
    decimals: 0
  }
};
const TEST_CHAINS = [SEPOLIA_CHAIN_ID];
const ETHERSCAN_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, CELO_MAINNET_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];
const SIMPLEHASH_SUPPORTED_CHAINS = [MAINNET_CHAIN_ID, POLYGON_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, CELO_MAINNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, SEPOLIA_CHAIN_ID, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID];
const COINGECKO_SUPPORTED_CURRENCIES = new Set(["btc", "eth", "ltc", "bch", "bnb", "eos", "xrp", "xlm", "link", "dot", "yfi", "usd", "aed", "ars", "aud", "bdt", "bhd", "bmd", "brl", "cad", "chf", "clp", "cny", "czk", "dkk", "eur", "gbp", "hkd", "huf", "idr", "ils", "inr", "jpy", "krw", "kwd", "lkr", "mmk", "mxn", "myr", "ngn", "nok", "nzd", "php", "pkr", "pln", "rub", "sar", "sek", "sgd", "thb", "try", "twd", "uah", "vef", "vnd", "zar", "xdr", "xag", "xau", "bits", "sats"]);
const COINGECKO_PLATFORMS_CHAIN_CODE_MAP = {
  [POLYGON_CHAIN_ID]: {
    platform: "polygon-pos",
    currency: "matic"
  },
  [BSC_MAINNET_CHAIN_ID]: {
    platform: "binance-smart-chain",
    currency: "bnb"
  },
  [MAINNET_CHAIN_ID]: {
    platform: "ethereum",
    currency: "eth"
  },
  [ARBITRUM_MAINNET_CHAIN_ID]: {
    platform: "arbitrum-one",
    currency: "eth"
  },
  [OPTIMISM_MAINNET_CHAIN_ID]: {
    platform: "optimistic-ethereum",
    currency: "eth"
  },
  [CELO_MAINNET_CHAIN_ID]: {
    platform: "celo",
    currency: "celo"
  },
  [XDAI_CHAIN_ID]: {
    platform: "xdai",
    currency: "xDAI"
  },
  [AVALANCHE_MAINNET_CHAIN_ID]: {
    platform: "avalanche",
    currency: "avax"
  },
  [BASE_CHAIN_ID]: {
    platform: "base",
    currency: "eth"
  }
};
const MessageStatus = {
  UNAPPROVED: "unapproved",
  SIGNED: "signed",
  PENDING: "pending",
  APPROVED: "approved",
  REJECTED: "rejected",
  FAILED: "failed"
};
const MESSAGE_EVENTS = {
  UNAPPROVED_MESSAGE: "unapprovedMessage"
};

const SINGLE_CALL_BALANCES_ADDRESSES = {
  [MAINNET_CHAIN_ID]: "0xb1f8e55c7f64d203c1400b9d8555d050f94adf39",
  // [SEPOLIA_CHAIN_ID]: SINGLE_CALL_BALANCES_ADDRESS_SEPOLIA,
  // [FANTOM_CHAIN_ID]: "0x07f697424ABe762bB808c109860c04eA488ff92B",
  [BSC_MAINNET_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [OPTIMISM_MAINNET_CHAIN_ID]: "0xB1c568e9C3E6bdaf755A60c7418C269eb11524FC",
  [POLYGON_CHAIN_ID]: "0x2352c63A83f9Fd126af8676146721Fa00924d7e4",
  [AVALANCHE_MAINNET_CHAIN_ID]: "0xD023D153a0DFa485130ECFdE2FAA7e612EF94818",
  [ARBITRUM_MAINNET_CHAIN_ID]: "0x151E24A486D7258dd7C33Fb67E4bB01919B7B32c"
};

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

/**
 * Tracks accounts based on blocks.
 * If block tracker provides latest block, we query accounts from it.
 * Preferences state changes also retrigger accounts update.
 * Network state changes also retrigger accounts update.
 */
class AccountTrackerController extends BaseController {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    getIdentities,
    onPreferencesStateChange,
    getCurrentChainId
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "mutex", new Mutex());
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "getIdentities", void 0);
    _defineProperty(this, "getCurrentChainId", void 0);
    this.defaultState = {
      accounts: {}
    };
    this.initialize();
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.ethersProvider = new BrowserProvider(this.provider, "any");
    this.getIdentities = getIdentities;
    this.getCurrentChainId = getCurrentChainId;
    onPreferencesStateChange(() => {
      const refreshNeeded = this.syncAccounts();
      if (refreshNeeded) {
        log.info("onPreferencesStateChange called");
        this.refresh();
      }
    });
    this.blockTrackerListener = this.blockTrackerListener.bind(this);
  }
  blockTrackerListener() {
    this.refresh();
  }
  startPolling() {
    this.stopPolling();
    // Initiate block tracker internal tracking.
    if (Object.keys(this.state.accounts).length > 0) {
      // Adding this listener on block tracker triggers it to start polling.
      this.blockTracker.on("latest", this.blockTrackerListener);
    }
  }
  stopPolling() {
    this.blockTracker.removeListener("latest", this.blockTrackerListener);
  }
  syncAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(this.getIdentities());
    const existing = Object.keys(accounts);
    const newAddresses = addresses.filter(address => existing.indexOf(address) === -1);
    const oldAddresses = existing.filter(address => addresses.indexOf(address) === -1);
    let isUpdated = false;
    newAddresses.forEach(address => {
      isUpdated = true;
      accounts[address] = {
        balance: "0x0"
      };
    });
    oldAddresses.forEach(address => {
      isUpdated = true;
      delete accounts[address];
    });
    this.update({
      accounts: _objectSpread({}, accounts)
    });
    return isUpdated;
  }
  async refresh() {
    const releaseLock = await this.mutex.acquire();
    try {
      this._updateAccounts();
    } catch (error) {} finally {
      releaseLock();
    }
  }
  async _updateAccounts() {
    const {
      accounts
    } = this.state;
    const addresses = Object.keys(accounts);
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") return;
    if (addresses.length > 0) {
      if (SINGLE_CALL_BALANCES_ADDRESSES[chainId]) {
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESSES[chainId]);
        return;
      }
      log.info("falling back to ethQuery.getBalance");
      await Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
  async _updateAccount(address) {
    const balance = await this.provider.request({
      method: "eth_getBalance",
      params: [address, "latest"]
    });
    const {
      accounts
    } = this.state;
    if (!accounts[address]) return;
    accounts[address] = {
      balance: toQuantity(balance)
    };
    this.update({
      accounts
    });
  }
  async _updateAccountsViaBalanceChecker(addresses, deployedContractAddress) {
    const ethContract = new Contract(deployedContractAddress, singleBalanceCheckerAbi, this.ethersProvider);
    try {
      const result = await ethContract.balances(addresses, [ZERO_ADDRESS]);
      const {
        accounts
      } = this.state;
      addresses.forEach((address, index) => {
        const balance = toQuantity(result[index]);
        if (!accounts[address]) return;
        accounts[address] = {
          balance
        };
      });
      return this.update({
        accounts
      });
    } catch (error) {
      log.warn("Torus - Account Tracker single call balance fetch failed", error);
      return Promise.all(addresses.map(x => this._updateAccount(x)));
    }
  }
}

const erc20Interface = new Interface(erc20Abi);
const erc721Interface = new Interface(erc721Abi);
const erc1155Interface = new Interface(erc1155Abi);

// functions that handle normalizing of that key in txParams

const normalizers = {
  from: (from, LowerCase = true) => LowerCase ? addHexPrefix(from).toLowerCase() : addHexPrefix(from),
  to: (to, LowerCase = true) => LowerCase ? addHexPrefix(to).toLowerCase() : addHexPrefix(to),
  nonce: nonce => addHexPrefix(nonce),
  customNonceValue: nonce => addHexPrefix(nonce),
  value: value => addHexPrefix(value),
  data: data => addHexPrefix(data),
  gas: gas => addHexPrefix(gas),
  gasPrice: gasPrice => addHexPrefix(gasPrice),
  type: addHexPrefix,
  maxFeePerGas: addHexPrefix,
  maxPriorityFeePerGas: addHexPrefix
};

/**
 * normalizes txParams
 */
function normalizeTxParameters(txParameters, lowerCase = true) {
  // apply only keys in the normalizers
  const normalizedTxParameters = {
    id: txParameters.id || randomId(),
    from: txParameters.from
  };
  for (const key in normalizers) {
    const currentKey = key;
    if (txParameters[currentKey])
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      normalizedTxParameters[currentKey] = normalizers[currentKey](txParameters[currentKey], lowerCase);
  }
  return normalizedTxParameters;
}
function transactionMatchesNetwork(transaction, chainId) {
  if (typeof transaction.chainId !== "undefined") {
    return transaction.chainId === chainId;
  }
  return false;
}

/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *  the transaction to check
 * @returns true if transaction uses valid EIP1559 fields
 */
function isEIP1559Transaction(transaction) {
  var _transaction$transact, _transaction$transact2;
  return isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact = transaction.transaction) === null || _transaction$transact === void 0 ? void 0 : _transaction$transact.maxFeePerGas)) && isHexString(addHexPrefix(transaction === null || transaction === void 0 || (_transaction$transact2 = transaction.transaction) === null || _transaction$transact2 === void 0 ? void 0 : _transaction$transact2.maxPriorityFeePerGas));
}

/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 * transaction -
 *  the transaction to check
 * @returns true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */
function isLegacyTransaction(transaction) {
  return typeof transaction.transaction.maxFeePerGas === "undefined" && typeof transaction.transaction.maxPriorityFeePerGas === "undefined" && (typeof transaction.transaction.gasPrice === "undefined" || isHexString(addHexPrefix(transaction.transaction.gasPrice)));
}

/**
 * Given two fields, ensure that the second field is not included in txParams,
 * and if it is throw an invalidParams error.
 */
function ensureMutuallyExclusiveFieldsNotProvided(txParams, fieldBeingValidated, mutuallyExclusiveField) {
  if (typeof txParams[mutuallyExclusiveField] !== "undefined") {
    throw rpcErrors.invalidParams(`Invalid transaction params: specified ${fieldBeingValidated} but also included ${mutuallyExclusiveField}, these cannot be mixed`);
  }
}

/**
 * Ensures that the provided value for field is a string, throws an
 * invalidParams error if field is not a string.
 */
function ensureFieldIsString(txParams, field) {
  if (typeof txParams[field] !== "string") {
    throw rpcErrors.invalidParams(`Invalid transaction params: ${field} is not a string. got: (${txParams[field]})`);
  }
}

/**
 * Ensures that the provided txParams has the proper 'type' specified for the
 * given field, if it is provided. If types do not match throws an
 * invalidParams error.
 */
function ensureProperTransactionEnvelopeTypeProvided(txParams, field) {
  switch (field) {
    case "maxFeePerGas":
    case "maxPriorityFeePerGas":
      if (txParams.type && txParams.type !== TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + `including maxFeePerGas and maxPriorityFeePerGas requires type: "${TRANSACTION_ENVELOPE_TYPES.FEE_MARKET}"`);
      }
      break;
    case "gasPrice":
    default:
      if (txParams.type && txParams.type === TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        throw rpcErrors.invalidParams(`Invalid transaction envelope type: specified type "${txParams.type}" but ` + "included a gasPrice instead of maxFeePerGas and maxPriorityFeePerGas");
      }
  }
}

/**
 * validates the from field in  txParams
 */
function validateFrom(txParams) {
  if (!(typeof txParams.from === "string")) {
    throw rpcErrors.invalidParams(`Invalid "from" address "${txParams.from}": not a string.`);
  }
  if (!isValidAddress(txParams.from)) {
    throw rpcErrors.invalidParams('Invalid "from" address.');
  }
}

/**
 * validates the to field in  txParams
 */
function validateRecipient(txParameters) {
  if (txParameters.to === "0x" || txParameters.to === null) {
    if (txParameters.data) {
      delete txParameters.to;
    } else {
      throw rpcErrors.invalidParams('Invalid "to" address.');
    }
  } else if (txParameters.to !== undefined && !isValidAddress(txParameters.to)) {
    throw rpcErrors.invalidParams('Invalid "to" address.');
  }
  return txParameters;
}

/**
 * Validates the given tx parameters
 * @throws if the tx params contains invalid fields
 */
function validateTxParameters(txParams, eip1559Compatibility = true) {
  if (!txParams || typeof txParams !== "object" || Array.isArray(txParams)) {
    throw rpcErrors.invalidParams("Invalid transaction params: must be an object.");
  }
  if (!txParams.to && !txParams.data) {
    throw rpcErrors.invalidParams('Invalid transaction params: must specify "data" for contract deployments, or "to" (and optionally "data") for all other types of transactions.');
  }
  if (isEIP1559Transaction({
    transaction: txParams
  }) && !eip1559Compatibility) {
    throw rpcErrors.invalidParams("Invalid transaction params: params specify an EIP-1559 transaction but the current network does not support EIP-1559");
  }
  Object.entries(txParams).forEach(([key, value]) => {
    // validate types
    switch (key) {
      case "from":
        validateFrom(txParams);
        break;
      case "to":
        validateRecipient(txParams);
        break;
      case "gasPrice":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "gasPrice");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "gasPrice", "maxPriorityFeePerGas");
        ensureFieldIsString(txParams, "gasPrice");
        break;
      case "maxFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxFeePerGas");
        break;
      case "maxPriorityFeePerGas":
        ensureProperTransactionEnvelopeTypeProvided(txParams, "maxPriorityFeePerGas");
        ensureMutuallyExclusiveFieldsNotProvided(txParams, "maxPriorityFeePerGas", "gasPrice");
        ensureFieldIsString(txParams, "maxPriorityFeePerGas");
        break;
      case "value":
        ensureFieldIsString(txParams, "value");
        if (value.toString().includes("-")) {
          throw rpcErrors.invalidParams(`Invalid transaction value "${value}": not a positive number.`);
        }
        if (value.toString().includes(".")) {
          throw rpcErrors.invalidParams(`Invalid transaction value of "${value}": number must be in wei.`);
        }
        break;
      case "chainId":
        if (typeof value !== "number" && typeof value !== "string") {
          throw rpcErrors.invalidParams(`Invalid transaction params: ${key} is not a Number or hex string. got: (${value})`);
        }
        break;
      default:
        ensureFieldIsString(txParams, key);
    }
  });
}
function normalizeAndValidateTxParams(txParams, lowerCase = true) {
  const normalizedTxParams = normalizeTxParameters(txParams, lowerCase);
  validateTxParameters(normalizedTxParams);
  return normalizedTxParams;
}

/**
 * @returns an array of states that can be considered final
 */
function getFinalStates() {
  return [TransactionStatus.rejected,
  // the user has responded no!
  TransactionStatus.confirmed,
  // the tx has been included in a block.
  TransactionStatus.failed,
  // the tx failed for some reason, included on tx data.
  TransactionStatus.dropped // the tx nonce was already used
  ];
}
function parseStandardTokenTransactionData(data) {
  try {
    const txDesc = erc20Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC20
    };
  } catch {
    // ignore and next try to parse with erc721 ABI
  }
  try {
    const txDesc = erc721Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC721
    };
  } catch {
    // ignore and next try to parse with erc1155 ABI
  }
  try {
    const txDesc = erc1155Interface.parseTransaction({
      data
    });
    if (txDesc) return {
      name: txDesc.name,
      methodParams: txDesc.args.toArray(),
      type: CONTRACT_TYPE_ERC1155
    };
  } catch {
    // ignore and return undefined
  }
  return undefined;
}
const readAddressAsContract = async (provider, address) => {
  let contractCode;
  try {
    contractCode = await provider.request({
      method: METHOD_TYPES.ETH_GET_CODE,
      params: [address, "latest"]
    });
  } catch (e) {
    contractCode = null;
  }
  const isContractAddress = contractCode ? contractCode !== "0x" && contractCode !== "0x0" : false;
  return {
    contractCode,
    isContractAddress
  };
};
async function determineTransactionType(txParams, provider) {
  const {
    data,
    to
  } = txParams;
  let name = "";
  let methodParams = [];
  let type = "";
  try {
    ({
      name,
      methodParams,
      type
    } = data && parseStandardTokenTransactionData(data) || {});
  } catch (error) {
    log.debug("Failed to parse transaction data", error);
  }
  let result;
  let contractCode = "";
  if (data && !to) {
    result = TRANSACTION_TYPES.DEPLOY_CONTRACT;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await readAddressAsContract(provider, to);
    contractCode = resultCode;
    if (isContractAddress) {
      const valueExists = txParams.value && Number(txParams.value) !== 0;
      const tokenMethodName = [TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, TRANSACTION_TYPES.COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM, TRANSACTION_TYPES.SET_APPROVAL_FOR_ALL].find(x => {
        var _name;
        return x.toLowerCase() === ((_name = name) === null || _name === void 0 ? void 0 : _name.toLowerCase());
      });
      result = data && tokenMethodName && !valueExists ? tokenMethodName : TRANSACTION_TYPES.CONTRACT_INTERACTION;
    } else {
      result = TRANSACTION_TYPES.SENT_ETHER;
    }
  }
  return {
    type: type || CONTRACT_TYPE_ETH,
    category: result,
    methodParams,
    getCodeResponse: contractCode
  };
}

function hexToBn(hex) {
  return new BigNumber(stripHexPrefix(hex), 16);
}
function BNToHex(bn) {
  return addHexPrefix(bn.toString(16));
}
function getEtherScanHashLink(txHash, chainId) {
  if (!SUPPORTED_NETWORKS[chainId]) return "";
  return `${SUPPORTED_NETWORKS[chainId].blockExplorerUrl}/tx/${txHash}`;
}
const formatPastTx = params => {
  var _transaction$to;
  const {
    transaction,
    lowerCaseSelectedAddress,
    blockExplorerUrl
  } = params;
  let totalAmountString = "";
  if (transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155) totalAmountString = transaction.symbol;else if (transaction.type === CONTRACT_TYPE_ERC20) totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.symbol, true);else totalAmountString = formatSmallNumbers(Number.parseFloat(transaction.total_amount), transaction.type_name, true);
  const currencyAmountString = transaction.type === CONTRACT_TYPE_ERC721 || transaction.type === CONTRACT_TYPE_ERC1155 || transaction.isEtherscan ? "" : formatSmallNumbers(Number.parseFloat(transaction.currency_amount), transaction.selected_currency, true);
  const finalObject = {
    id: transaction.created_at.toString(),
    date: new Date(transaction.created_at).toString(),
    from: transaction.from,
    from_aa_address: transaction.from_aa_address,
    slicedFrom: typeof transaction.from === "string" ? addressSlicer(transaction.from) : "",
    to: transaction.to,
    slicedTo: typeof transaction.to === "string" ? addressSlicer(transaction.to) : "",
    action: lowerCaseSelectedAddress === ((_transaction$to = transaction.to) === null || _transaction$to === void 0 ? void 0 : _transaction$to.toLowerCase()) || "" ? ACTIVITY_ACTION_RECEIVE : ACTIVITY_ACTION_SEND,
    totalAmount: transaction.total_amount,
    totalAmountString,
    currencyAmount: transaction.currency_amount,
    currencyAmountString,
    amount: `${totalAmountString} / ${currencyAmountString}`,
    status: transaction.status,
    etherscanLink: blockExplorerUrl ? `${blockExplorerUrl}/tx/${transaction.transaction_hash}` : "",
    chainId: transaction.chain_id,
    ethRate: Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.total_amount) && Number.parseFloat(transaction === null || transaction === void 0 ? void 0 : transaction.currency_amount) ? `1 ${transaction.symbol} = ${significantDigits(Number.parseFloat(transaction.currency_amount) / Number.parseFloat(transaction.total_amount))}` : "",
    currencyUsed: transaction.selected_currency,
    type: transaction.type,
    type_name: transaction.type_name,
    type_image_link: transaction.type_image_link,
    transaction_hash: transaction.transaction_hash,
    transaction_category: transaction.transaction_category,
    isEtherscan: transaction.isEtherscan,
    input: transaction.input || "",
    token_id: transaction.token_id || "",
    contract_address: transaction.contract_address || "",
    nonce: transaction.nonce || "",
    is_cancel: !!transaction.is_cancel || false,
    gas: transaction.gas || "",
    gasPrice: transaction.gasPrice || ""
  };
  return finalObject;
};

/**
 * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt
 */
const getEthTxStatus = async (hash, provider) => {
  try {
    const result = await provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
      params: [hash]
    });
    if (result === null) return TransactionStatus.submitted;
    if (result && result.status === "0x1") return TransactionStatus.confirmed;
    if (result && result.status === "0x0") return TransactionStatus.rejected;
    return undefined;
  } catch (err) {
    log.warn("unable to fetch transaction status", err);
    return undefined;
  }
};
function formatDate(inputDate) {
  const monthList = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const date = new Date(inputDate);
  const day = date.getDate();
  const month = monthList[date.getMonth()];
  const year = date.getFullYear();
  return `${day} ${month} ${year}`;
}
function formatTime(time) {
  return new Date(time).toTimeString().slice(0, 8);
}
const idleTimeTracker = (activityThresholdTime => {
  let isIdle = false;
  let idleTimeout = null;
  const resetTimer = () => {
    if (idleTimeout) {
      window.clearTimeout(idleTimeout);
    }
    isIdle = false;
    idleTimeout = window.setTimeout(() => {
      isIdle = true;
    }, activityThresholdTime * 1000);
  };
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    window.addEventListener("load", resetTimer);
    document.addEventListener("mousemove", resetTimer);
    document.addEventListener("keydown", resetTimer);
  }
  function checkIfIdle() {
    return isIdle;
  }
  return {
    checkIfIdle
  };
})(60 * 3);
function isAddressByChainId(address, _chainId) {
  // TOOD: add rsk network checks.
  return isValidAddress(address);
}
function toChecksumAddressByChainId(address, chainId) {
  // TOOD: add rsk network checks.
  if (!isAddressByChainId(address)) return address;
  return toChecksumAddress(address);
}
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: addHexPrefix(21000 .toString(16)),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: addHexPrefix(100000 .toString(16))
};
function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }
  return new BigNumber(a, 10).lt(b, 10);
}
const getIpfsEndpoint = path => `https://infura-ipfs.io/${path}`;
function sanitizeNftMetdataUrl(url) {
  let finalUri = url;
  if (url !== null && url !== void 0 && url.startsWith("ipfs")) {
    const ipfsPath = url.split("ipfs://")[1];
    finalUri = getIpfsEndpoint(ipfsPath);
  }
  return finalUri;
}
function getChainType(chainId) {
  if (chainId === MAINNET_CHAIN_ID) {
    return "mainnet";
  } else if (TEST_CHAINS.includes(chainId)) {
    return "testnet";
  }
  return "custom";
}
const addEtherscanTransactions = async params => {
  const {
    txn,
    lowerCaseSelectedAddress,
    provider,
    chainId,
    blockExplorerUrl
  } = params;
  const transactionPromises = await Promise.all(txn.map(async tx => {
    var _SUPPORTED_NETWORKS$c, _SUPPORTED_NETWORKS$c2;
    const {
      category,
      type
    } = await determineTransactionType(_objectSpread(_objectSpread({}, tx), {}, {
      data: tx.input
    }), provider);
    tx.transaction_category = tx.transaction_category || category;
    tx.type_image_link = ((_SUPPORTED_NETWORKS$c = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c === void 0 ? void 0 : _SUPPORTED_NETWORKS$c.logo) || "";
    tx.type_name = (_SUPPORTED_NETWORKS$c2 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c2 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c2.ticker;
    tx.type = type;
    return tx;
  }));
  const finalTxs = transactionPromises.reduce((accumulator, x) => {
    var _SUPPORTED_NETWORKS$c3, _SUPPORTED_NETWORKS$c4;
    let totalAmountString = x.value ? new BigNumber(x.value).div(new BigNumber(10).pow(new BigNumber(x.tokenDecimal || 18))).toString() : "";
    let type = CONTRACT_TYPE_ETH;
    if (x.contractAddress !== "") {
      if (x.tokenID) {
        type = x.tokenValue ? CONTRACT_TYPE_ERC1155 : CONTRACT_TYPE_ERC721;
      } else {
        type = CONTRACT_TYPE_ERC20;
      }
    }
    if (type === CONTRACT_TYPE_ERC1155) {
      totalAmountString = x.tokenValue;
    }
    const etherscanTransaction = {
      type,
      type_image_link: x.type_image_link || "n/a",
      type_name: x.tokenName || ((_SUPPORTED_NETWORKS$c3 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c3 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c3.ticker) || "n/a",
      symbol: x.tokenSymbol || ((_SUPPORTED_NETWORKS$c4 = SUPPORTED_NETWORKS[chainId]) === null || _SUPPORTED_NETWORKS$c4 === void 0 ? void 0 : _SUPPORTED_NETWORKS$c4.ticker),
      token_id: x.tokenID || "",
      total_amount: totalAmountString,
      created_at: new Date(Number(x.timeStamp) * 1000),
      from: x.from,
      to: x.to,
      transaction_hash: x.hash,
      status: x.txreceipt_status && x.txreceipt_status === "0" ? TransactionStatus.failed : TransactionStatus.confirmed,
      isEtherscan: true,
      input: x.input,
      contract_address: x.contractAddress,
      transaction_category: x.transaction_category,
      gas: `0x${new BigNumber(x.gasUsed || 0, 10).toString(16)}`,
      gasPrice: `0x${new BigNumber(x.gasPrice || 0, 10).toString(16)}`,
      chain_id: chainId,
      currency_amount: "",
      nonce: x.nonce,
      from_aa_address: "",
      is_cancel: false,
      selected_currency: ""
    };
    accumulator.push(formatPastTx({
      transaction: etherscanTransaction,
      lowerCaseSelectedAddress,
      blockExplorerUrl
    }));
    return accumulator;
  }, []);
  return finalTxs;
};

const DEFAULT_POLLING_INTERVAL = 20;
const DEFAULT_RETRY_TIMEOUT = 2;
const SEC = 1000;
class PollingBlockTracker extends BaseBlockTracker {
  constructor({
    config,
    state = {}
  }) {
    if (!config.provider) {
      throw new Error("PollingBlockTracker - no provider specified.");
    }
    super({
      config,
      state
    });
    const pollingInterval = config.pollingInterval || DEFAULT_POLLING_INTERVAL;
    const retryTimeout = config.retryTimeout || DEFAULT_RETRY_TIMEOUT;

    // merge default + provided config.
    this.defaultConfig = {
      provider: config.provider,
      pollingInterval: pollingInterval * SEC,
      retryTimeout: retryTimeout * SEC,
      setSkipCacheFlag: config.setSkipCacheFlag || false
    };
    this.initialize();
  }
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return this.getLatestBlock();
  }

  // overrides the BaseBlockTracker._start method.
  _start() {
    this._synchronize().catch(err => this.emit("error", err));
  }
  async _synchronize() {
    while (this.state._isRunning) {
      if (idleTimeTracker.checkIfIdle()) return;
      try {
        await this._updateLatestBlock();
        await timeout(this.config.pollingInterval);
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          log.error(newErr);
        }
        await timeout(this.config.retryTimeout);
      }
    }
  }
  async _updateLatestBlock() {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    try {
      const block = await this.config.provider.request({
        method: "eth_getBlockByNumber",
        params: ["latest", false]
      });
      return {
        blockHash: block.hash,
        idempotencyKey: block.number,
        timestamp: block.timestamp,
        baseFeePerGas: block.baseFeePerGas,
        gasLimit: block.gasLimit
      };
    } catch (error) {
      log.error("Polling Block Tracker: ", error);
      throw new Error(`PollingBlockTracker - encountered error fetching block:\n${error.message}`);
    }
  }
}

class CurrencyController extends BaseCurrencyController {
  constructor({
    config,
    state,
    onNetworkChanged
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "conversionInterval", void 0);
    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {
      commonDenomination: "USD",
      commonDenominatorPrice: 0
    });
    this.initialize();
    onNetworkChanged(networkState => {
      // to be called as (listener) => this.networkController.on('networkDidChange', listener);
      if (networkState.providerConfig.ticker.toUpperCase() !== this.state.nativeCurrency.toUpperCase()) {
        this.setNativeCurrency(networkState.providerConfig.ticker);
        this.updateConversionRate();
      }
    });
  }
  setCommonDenomination(commonDenomination) {
    this.update({
      commonDenomination
    });
  }
  getCommonDenomination() {
    return this.state.commonDenomination;
  }
  setCommonDenominatorPrice(commonDenominatorPrice) {
    this.update({
      commonDenominatorPrice
    });
  }
  getCommonDenominatorPrice() {
    return this.state.commonDenominatorPrice;
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  scheduleConversionInterval() {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateConversionRate();
      }
    }, this.config.pollInterval);
  }

  /**
   * Updates the conversionRate and conversionDate properties associated with the currentCurrency. Updated info is
   * fetched from an external API
   */
  async updateConversionRate() {
    const currentCurrency = this.getCurrentCurrency();
    const nativeCurrency = this.getNativeCurrency();
    const commonDenomination = this.getCommonDenomination();
    const conversionRate = await this.retrieveConversionRate(nativeCurrency, currentCurrency, commonDenomination);
    const currentCurrencyRate = Number.parseFloat(conversionRate[currentCurrency.toUpperCase()]);
    const commonDenominationRate = Number.parseFloat(conversionRate[commonDenomination.toUpperCase()]);
    // set conversion rate
    if (currentCurrencyRate || commonDenominationRate) {
      // ETC
      this.setConversionRate(currentCurrencyRate);
      this.setConversionDate(Math.floor(Date.now() / 1000).toString());
      if (currentCurrency.toUpperCase() === commonDenomination.toUpperCase()) {
        this.setCommonDenominatorPrice(currentCurrencyRate);
      } else {
        this.setCommonDenominatorPrice(commonDenominationRate);
      }
    } else {
      this.setConversionRate(0);
      this.setConversionDate("N/A");
    }
  }
  async retrieveConversionRate(fromCurrency, toCurrency, commonDenomination) {
    try {
      let apiUrl = `${this.config.api}/currency?fsym=${fromCurrency.toUpperCase()}&tsyms=${toCurrency.toUpperCase()}`;
      if (commonDenomination && commonDenomination.toUpperCase() !== toCurrency.toUpperCase()) {
        apiUrl += `,${commonDenomination.toUpperCase()}`;
      }
      const parsedResponse = await get(apiUrl);
      return parsedResponse;
    } catch (error) {
      log.error(error, `CurrencyController - updateCommonDenominatorPrice: Failed to query rate for currency: ${fromCurrency}/ ${toCurrency}`);
    }
    return {
      [toCurrency.toUpperCase()]: "0",
      [commonDenomination.toUpperCase()]: "0"
    };
  }
}

const _excluded$1 = ["aBase", "bBase"],
  _excluded2 = ["aBase", "bBase"],
  _excluded3 = ["multiplicandBase", "multiplierBase"];

// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1000000000000000000");
const BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1000000000");
const BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1");
// Setter Maps
const toBigNumber = {
  hex: n => new BigNumber(stripHexPrefix(n), 16),
  dec: n => new BigNumber(String(n), 10),
  BN: n => new BigNumber(n.toString(16), 16)
};
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)
};
const baseChange = {
  hex: n => n.toString(16),
  dec: n => new BigNumber(n).toString(10),
  BN: n => new BN(n.toString(16))
};

// Utility function for checking base types
const isValidBase = base => Number.isInteger(base) && base > 1;

/**
 * Utility method to convert a value between denominations, formats and currencies.
 */
const converter = ({
  value,
  fromNumericBase,
  fromDenomination,
  fromCurrency,
  toNumericBase,
  toDenomination,
  toCurrency,
  numberOfDecimals,
  conversionRate,
  invertConversionRate,
  roundDown
}) => {
  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (fromCurrency !== toCurrency) {
    if (conversionRate === null || conversionRate === undefined) {
      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
    }
    let rate = toBigNumber.dec(conversionRate);
    if (invertConversionRate) {
      rate = new BigNumber(1).div(conversionRate);
    }
    convertedValue = convertedValue.times(rate);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);
  }
  if (roundDown) {
    convertedValue = convertedValue.dp(roundDown, BigNumber.ROUND_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
const conversionUtil = (value, {
  fromCurrency = null,
  toCurrency = fromCurrency,
  fromNumericBase,
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals,
  conversionRate,
  invertConversionRate
}) => {
  if (fromCurrency !== toCurrency && !conversionRate) {
    return 0;
  }
  return converter({
    fromCurrency,
    toCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
    value
  });
};
const getBigNumber = (value, base) => {
  if (!isValidBase(base)) {
    throw new Error("Must specificy valid base");
  }

  // We don't include 'number' here, because BigNumber will throw if passed
  // a number primitive it considers unsafe.
  if (typeof value === "string" || value instanceof BigNumber) {
    return new BigNumber(value, base);
  }
  return new BigNumber(String(value), base);
};
const addCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded$1);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).plus(getBigNumber(b, bBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const subtractCurrencies = (a, b, options = {}) => {
  const {
      aBase,
      bBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded2);
  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error("Must specify valid aBase and bBase");
  }
  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const multiplyCurrencies = (a, b, options = {}) => {
  const {
      multiplicandBase,
      multiplierBase
    } = options,
    conversionOptions = _objectWithoutProperties(options, _excluded3);
  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
    throw new Error("Must specify valid multiplicandBase and multiplierBase");
  }
  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));
  return converter(_objectSpread({
    value
  }, conversionOptions));
};
const conversionGreaterThan = (_ref, _ref2) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref2), _ref2));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.gt(secondValue);
};
const conversionLessThan = (_ref3, _ref4) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref4), _ref4));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref3), _ref3));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.lt(secondValue);
};
const conversionMax = (_ref5, _ref6) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref6), _ref6));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref5), _ref5));
  const firstIsGreater = conversionGreaterThan(_objectSpread({}, firstProps), _objectSpread({}, secondProps));
  return firstIsGreater ? firstProps.value : secondProps.value;
};
const conversionGTE = (_ref7, _ref8) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref8), _ref8));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref7), _ref7));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.isGreaterThanOrEqualTo(secondValue);
};
const conversionLTE = (_ref9, _ref10) => {
  let secondProps = Object.assign({}, (_objectDestructuringEmpty(_ref10), _ref10));
  let firstProps = Object.assign({}, (_objectDestructuringEmpty(_ref9), _ref9));
  const firstValue = converter(_objectSpread({}, firstProps));
  const secondValue = converter(_objectSpread({}, secondProps));
  return firstValue.isLessThanOrEqualTo(secondValue);
};
const toNegative = (n, options = {}) => multiplyCurrencies(n, -1, options);
const decGWEIToHexWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
};
const hexWEIToDecGWEI = decGWEI => {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
};

function normalizeGWEIDecimalNumbers(n) {
  const numberAsWEIHex = decGWEIToHexWEI(new BigNumber(n));
  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);
  return numberAsGWEI;
}
async function fetchGasEstimates(url) {
  const estimates = await get(url);
  const normalizedEstimates = {
    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee).toString(10),
    low: _objectSpread(_objectSpread({}, estimates.low), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas).toString(10)
    }),
    medium: _objectSpread(_objectSpread({}, estimates.medium), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas).toString(10)
    }),
    high: _objectSpread(_objectSpread({}, estimates.high), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas).toString(10),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas).toString(10)
    })
  };
  return normalizedEstimates;
}
async function fetchGasEstimatesViaEthFeeHistory(provider) {
  const noOfBlocks = 10;
  const newestBlock = "latest";
  // get the 10, 50 and 95th percentile of the tip fees from the last 10 blocks
  const percentileValues = [10, 50, 95];
  const feeHistory = await provider.request({
    method: "eth_feeHistory",
    params: [noOfBlocks, newestBlock, percentileValues]
  });
  // this is in hex wei
  const finalBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];
  // this is in hex wei
  const priorityFeeCalcs = feeHistory.reward.reduce((acc, curr) => {
    return {
      slow: acc.slow.plus(new BigNumber(curr[0], 16)),
      average: acc.average.plus(new BigNumber(curr[1], 16)),
      fast: acc.fast.plus(new BigNumber(curr[2], 16))
    };
  }, {
    slow: new BigNumber(0),
    average: new BigNumber(0),
    fast: new BigNumber(0)
  });
  return {
    estimatedBaseFee: hexWEIToDecGWEI(finalBaseFeePerGas).toString(10),
    high: {
      maxWaitTimeEstimate: 30000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.toString(16)).toString()
    },
    medium: {
      maxWaitTimeEstimate: 45000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.toString(16)).toString()
    },
    low: {
      maxWaitTimeEstimate: 60000,
      minWaitTimeEstimate: 15000,
      suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.plus(finalBaseFeePerGas).toString(16)).toString(),
      suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.toString(16)).toString()
    }
  };
}

/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 */
async function fetchLegacyGasPriceEstimates(url) {
  const result = await get(url, {
    referrer: url,
    referrerPolicy: "no-referrer-when-downgrade",
    method: "GET"
  });
  // this returns decimal gwei
  return {
    low: result.SafeGasPrice,
    medium: result.ProposeGasPrice,
    high: result.FastGasPrice
  };
}
async function fetchEthGasPriceEstimate(provider) {
  const gasPrice = await provider.request({
    method: METHOD_TYPES.ETH_GET_GAS_PRICE
  });
  return {
    gasPrice: hexWEIToDecGWEI(gasPrice).toString()
  };
}
function calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {
  // all are in dec gwei
  const {
    low,
    medium,
    high,
    estimatedBaseFee
  } = gasFeeEstimates;
  const maxPriorityFeePerGasInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(maxPriorityFeePerGas)), 16);
  const maxFeePerGasInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(maxFeePerGas)), 16);
  const estimatedBaseFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(estimatedBaseFee)), 16);
  const effectiveMaxPriorityFee = BigNumber.min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.minus(estimatedBaseFeeInWEI));
  const lowMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(low.suggestedMaxPriorityFeePerGas)), 16);
  const mediumMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(medium.suggestedMaxPriorityFeePerGas)), 16);
  const highMaxPriorityFeeInWEI = new BigNumber(decGWEIToHexWEI(new BigNumber(high.suggestedMaxPriorityFeePerGas)), 16);
  let lowerTimeBound;
  let upperTimeBound;
  if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {
    lowerTimeBound = null;
    upperTimeBound = "unknown";
  } else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {
    lowerTimeBound = low.minWaitTimeEstimate;
    upperTimeBound = low.maxWaitTimeEstimate;
  } else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) && effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {
    lowerTimeBound = medium.minWaitTimeEstimate;
    upperTimeBound = medium.maxWaitTimeEstimate;
  } else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {
    lowerTimeBound = high.minWaitTimeEstimate;
    upperTimeBound = high.maxWaitTimeEstimate;
  } else {
    lowerTimeBound = 0;
    upperTimeBound = high.maxWaitTimeEstimate;
  }
  return {
    lowerTimeBound,
    upperTimeBound
  };
}

const GAS_FEE_API = "https://mock-gas-server.herokuapp.com/";
const LEGACY_GAS_PRICES_API_URL = "https://api.metaswap.codefi.network/gasPrices";
/**
 * Returns gas prices in dec gwei
 */
class GasFeeController extends BaseController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    getProvider,
    fetchGasEstimates: fetchGasEstimates$1 = fetchGasEstimates,
    fetchEthGasPriceEstimate: fetchEthGasPriceEstimate$1 = fetchEthGasPriceEstimate,
    fetchLegacyGasPriceEstimates: fetchLegacyGasPriceEstimates$1 = fetchLegacyGasPriceEstimates,
    fetchGasEstimatesViaEthFeeHistory: fetchGasEstimatesViaEthFeeHistory$1 = fetchGasEstimatesViaEthFeeHistory,
    getCurrentNetworkLegacyGasAPICompatibility,
    getCurrentNetworkEIP1559Compatibility,
    getCurrentAccountEIP1559Compatibility,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "GasFeeController");
    // https://0x.org/docs/introduction/0x-cheat-sheet#swap-api-endpoints
    _defineProperty(this, "API_SUPPORTED_CHAINIDS", new Set(["0x1", "0x5", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"]));
    _defineProperty(this, "intervalId", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "currentChainId", void 0);
    _defineProperty(this, "getNetworkIdentifier", void 0);
    _defineProperty(this, "getProvider", void 0);
    _defineProperty(this, "fetchGasEstimates", void 0);
    _defineProperty(this, "fetchGasEstimatesViaEthFeeHistory", void 0);
    _defineProperty(this, "fetchEthGasPriceEstimate", void 0);
    _defineProperty(this, "fetchLegacyGasPriceEstimates", void 0);
    _defineProperty(this, "getCurrentNetworkEIP1559Compatibility", void 0);
    _defineProperty(this, "getCurrentAccountEIP1559Compatibility", void 0);
    _defineProperty(this, "getCurrentNetworkLegacyGasAPICompatibility", void 0);
    this.getNetworkIdentifier = getNetworkIdentifier;
    this.getProvider = getProvider;
    this.fetchGasEstimates = fetchGasEstimates$1;
    this.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate$1;
    this.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates$1;
    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.fetchGasEstimatesViaEthFeeHistory = fetchGasEstimatesViaEthFeeHistory$1;
    this.defaultConfig = {
      interval: 30000,
      legacyAPIEndpoint: LEGACY_GAS_PRICES_API_URL,
      EIP1559APIEndpoint: GAS_FEE_API
    };
    this.defaultState = {
      gasFeeEstimates: {},
      estimatedGasFeeTimeBounds: {},
      gasEstimateType: GAS_ESTIMATE_TYPES.NONE
    };
    // Initialize.
    this.currentChainId = this.getNetworkIdentifier();
    this.provider = this.getProvider();
    this.initialize();
    onNetworkStateChange(() => {
      this.onNetworkStateChange();
    });
  }
  async onNetworkStateChange() {
    this.provider = this.getProvider();
    const newChainId = this.getNetworkIdentifier();
    if (this.currentChainId !== newChainId) {
      this.currentChainId = newChainId;
      await this.fetchGasFeeEstimates();
    }
  }
  async resetPolling() {
    this.stopPolling();
    await this.getGasFeeEstimatesAndStartPolling();
  }
  async fetchGasFeeEstimates() {
    return this._fetchGasFeeEstimateData();
  }
  async getGasFeeEstimatesAndStartPolling() {
    await this._fetchGasFeeEstimateData();
    this._startPolling();
  }
  disconnectPoller() {
    this.stopPolling();
  }

  /**
   * Prepare to discard this controller.
   *
   * This stops any active polling.
   */
  destroy() {
    this.stopPolling();
  }
  stopPolling() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
    this.resetState();
  }

  /**
   * Gets and sets gasFeeEstimates in state
   *
   * @returns GasFeeEstimates
   */
  async _fetchGasFeeEstimateData() {
    let isEIP1559Compatible;
    const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
    const chainId = this.getNetworkIdentifier();
    if (chainId === "loading") return;
    let chainIdInt;
    if (typeof chainId === "string" && isHexString(addHexPrefix(chainId))) {
      chainIdInt = Number.parseInt(chainId, 16);
    }
    try {
      isEIP1559Compatible = await this.getEIP1559Compatibility();
      log.info("eip1559 compatible", isEIP1559Compatible);
    } catch (error) {
      log.warn(error);
      isEIP1559Compatible = false;
    }
    let newState = cloneDeep(this.defaultState);
    try {
      if (isEIP1559Compatible) {
        let estimates;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(chainId)) {
            estimates = await this.fetchGasEstimates(this.config.EIP1559APIEndpoint.replace("<chain_id>", `${chainIdInt}`));
          } else {
            throw new Error("ChainId not supported by api");
          }
        } catch (error) {
          estimates = await this.fetchGasEstimatesViaEthFeeHistory(this.provider);
        }
        const {
          suggestedMaxPriorityFeePerGas,
          suggestedMaxFeePerGas
        } = estimates.medium;
        const estimatedGasFeeTimeBounds = this.getTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
        };
      } else if (isLegacyGasAPICompatible) {
        const estimates = await this.fetchLegacyGasPriceEstimates(this.config.legacyAPIEndpoint.replace("<chain_id>", `${chainIdInt}`));
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
        };
      } else {
        throw new Error("Main gas fee/price estimation failed. Use fallback");
      }
    } catch {
      try {
        const estimates = await this.fetchEthGasPriceEstimate(this.provider);
        newState = {
          gasFeeEstimates: estimates,
          estimatedGasFeeTimeBounds: {},
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
        };
      } catch (error) {
        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
      }
    }
    this.update(newState);
    return newState;
  }
  async _startPolling() {
    this._poll();
  }
  async _poll() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
    }
    this.intervalId = window.setInterval(async () => {
      if (!idleTimeTracker.checkIfIdle()) {
        await this._fetchGasFeeEstimateData();
      }
    }, this.config.interval);
  }
  resetState() {
    this.update(cloneDeep(this.defaultState));
  }
  async getEIP1559Compatibility() {
    var _this$getCurrentAccou, _this$getCurrentAccou2;
    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility();
    const currentAccountIsEIP1559Compatible = (_this$getCurrentAccou = (_this$getCurrentAccou2 = this.getCurrentAccountEIP1559Compatibility) === null || _this$getCurrentAccou2 === void 0 ? void 0 : _this$getCurrentAccou2.call(this)) !== null && _this$getCurrentAccou !== void 0 ? _this$getCurrentAccou : true;
    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
  }
  getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
    if (!this.state.gasFeeEstimates || this.state.gasEstimateType !== GAS_ESTIMATE_TYPES.FEE_MARKET) {
      return {};
    }
    return calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
  }
}

class KeyringController extends BaseKeyringController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    this.defaultState = {
      wallets: []
    };
    this.initialize();
  }
  async signTransaction(tx, address) {
    const txPayload = tx;
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const signedTx = txPayload.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }
  getAccounts() {
    return this.state.wallets.map(w => w.publicKey);
  }
  importAccount(accountPrivateKey) {
    const hexPrivateKey = accountPrivateKey.padStart(64, "0");
    const bufferPrivKey = Buffer.from(hexPrivateKey, "hex");
    const publicKey = bytesToHex(privateToPublic(bufferPrivKey));
    const address = toChecksumAddress(bytesToHex(privateToAddress(bufferPrivKey)));
    const existingWallet = this.state.wallets.find(w => w.address === address);
    if (existingWallet) return existingWallet.address;
    this.update({
      wallets: [...this.state.wallets, {
        publicKey,
        privateKey: accountPrivateKey,
        address
      }]
    });
    return address;
  }
  removeAccount(address) {
    const newWallets = [...this.state.wallets];
    const idx = newWallets.findIndex(w => w.address === address);
    if (idx !== -1) {
      newWallets.splice(idx, 1);
      this.update({
        wallets: newWallets
      });
    }
  }
  getBufferPrivateKey(privateKey) {
    const stripped = stripHexPrefix(privateKey);
    return Buffer.from(stripped, "hex");
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const messageSig = ecsign(Buffer.from(stripHexPrefix(data), "hex"), privKey);
    const sig = concatSig(Buffer.from(bigIntToBytes(messageSig.v)), Buffer.from(messageSig.r), Buffer.from(messageSig.s));
    return sig;
  }

  // For personal_sign, we need to prefix the message: ensure input is hashed and not buffer of utf-8
  async signPersonalMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    const sig = personalSign({
      privateKey: privKey,
      data
    });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(typedData, address, version) {
    const wallet = this._getWalletForAccount(address);
    const privKey = this.getBufferPrivateKey(wallet.privateKey);
    return signTypedData({
      privateKey: privKey,
      data: typedData,
      version
    });
  }
  signEncryptionPublicKey(address) {
    const wallet = this._getWalletForAccount(address);
    return getEncryptionPublicKey(stripHexPrefix(wallet.privateKey));
  }
  decryptMessage(data, address) {
    const wallet = this._getWalletForAccount(address);
    return decrypt({
      encryptedData: data,
      privateKey: stripHexPrefix(wallet.privateKey)
    });
  }
  _getWalletForAccount(account) {
    const address = account.toLowerCase();
    const wallet = this.state.wallets.find(w => w.address.toLowerCase() === address);
    if (!wallet) throw new Error("Torus Keyring - Unable to find matching address.");
    return wallet;
  }
}

class AbstractMessageController extends BaseController {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   */
  constructor({
    config,
    state,
    getNetworkIdentifier
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "messages", void 0);
    _defineProperty(this, "getNetworkIdentifier", void 0);
    this.defaultState = {
      unapprovedMessages: {},
      unapprovedMessagesCount: 0
    };
    this.messages = [];
    this.defaultConfig = {};
    this.getNetworkIdentifier = getNetworkIdentifier;
    super.initialize();
  }
  getMessage(messageId) {
    return this.messages.find(message => message.id === messageId);
  }
  getAllMessages() {
    return this.messages;
  }
  setMetadata(messageId, metadata) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.metadata = metadata;
    this.updateMessage(message);
  }
  getUnapprovedMessages() {
    return this.messages.filter(message => message.status === MessageStatus.UNAPPROVED).reduce((result, message) => {
      result[message.id] = message;
      return result;
    }, {});
  }
  async addMessage(message) {
    this.messages.push(message);
    this.saveMessageList();
  }
  approveMessage(messageId, messageParams) {
    this.setMessageStatus(messageId, MessageStatus.APPROVED);
    return this.prepMessageForSigning(messageParams);
  }
  setMessageStatus(messageId, status) {
    const message = this.getMessage(messageId);
    if (!message) {
      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
    }
    message.status = status;
    this.updateMessage(message);
    this.emit(`${messageId}:${status}`, message);
    if (status === MessageStatus.REJECTED || status === MessageStatus.SIGNED || status === MessageStatus.FAILED) {
      this.emit(`${messageId}:finished`, message);
    }
  }
  async waitForFinishStatus(msgParams, messageName) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === MessageStatus.REJECTED) {
          return reject(providerErrors.userRejectedRequest(`${messageName} Signature: User denied message signature`));
        }
        if (msg.status === MessageStatus.FAILED) {
          return reject(rpcErrors.internal(`${messageName} Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === MessageStatus.SIGNED) {
          return resolve(msg.rawSig);
        }
        return reject(rpcErrors.internal(`${messageName} Signature: Unknown problem: ${JSON.stringify(msgParams)}`));
      };
      this.once(`${msgParams.id}:finished`, handleFinished);
    });
  }
  updateMessage(message) {
    const index = this.messages.findIndex(msg => message.id === msg.id);
    if (index !== -1) {
      this.messages[index] = message;
    }
    this.saveMessageList();
  }
  saveMessageList() {
    const unapprovedMessages = this.getUnapprovedMessages();
    const unapprovedMessagesCount = Object.keys(unapprovedMessages).length;
    this.update({
      unapprovedMessages,
      unapprovedMessagesCount
    });
  }
}

const hexRe = /^[0-9A-Fa-f]+$/gu;
function validateAddress(address, propertyName) {
  if (!address || typeof address !== "string" || !isValidAddress(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}
function validateSignMessageData(messageData) {
  const {
    from,
    data
  } = messageData;
  validateAddress(from, "from");
  if (!data || typeof data !== "string") {
    throw new Error(`Invalid message "data": ${data} must be a valid string.`);
  }
}
function normalizeMessageData(data) {
  try {
    const stripped = stripHexPrefix(data);
    if (stripped.match(hexRe)) {
      return addHexPrefix(stripped);
    }
  } catch (e) {}
  return bytesToHex(Buffer.from(data, "utf8"));
}
function validateTypedSignMessageDataV1(messageData) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || !Array.isArray(messageData.data)) {
    throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
  }
  try {
    // typedSignatureHash will throw if the data is invalid.
    typedSignatureHash(messageData.data);
  } catch (e) {
    throw new Error(`Expected EIP712 typed data.`);
  }
}
async function validateTypedSignMessageDataV3V4(messageData, currentChainId) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== "object" && typeof messageData.data !== "string") {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }
  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch (e) {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }
  const {
    validate
  } = await import('jsonschema');
  const validation = validate(data, TYPED_MESSAGE_SCHEMA);
  if (validation.errors.length > 0) {
    throw new Error("Data must conform to EIP-712 schema. See https://git.io/fNtcx.");
  }
  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }
  let {
    chainId
  } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }
    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because MetaMask is switching networks.`);
    }
    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}
function validateEncryptionPublicKeyMessageData(messageData) {
  const {
    from
  } = messageData;
  validateAddress(from, "from");
}
function validateDecryptedMessageData(messageData) {
  const {
    from
  } = messageData;
  validateAddress(from, "from");
}
function parseDecryptMessageData(data) {
  const stripped = stripHexPrefix(data);
  const buffer = Buffer.from(stripped, "hex");
  return JSON.parse(buffer.toString("utf8"));
}
async function validateAddChainData(data) {
  const {
    chainId,
    rpcUrls,
    nativeCurrency
  } = data || {};
  if (!chainId) {
    throw new Error("Invalid add chain params: please pass chainId in params");
  }
  if (!isHexString$1(chainId)) {
    throw new Error("Invalid add chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
  if (!rpcUrls || rpcUrls.length === 0) throw new Error("params.rpcUrls not provided");
  if (!nativeCurrency) throw new Error("params.nativeCurrency not provided");
  const {
    name,
    symbol,
    decimals
  } = nativeCurrency;
  if (!name) throw new Error("params.nativeCurrency.name not provided");
  if (!symbol) throw new Error("params.nativeCurrency.symbol not provided");
  if (decimals === undefined) throw new Error("params.nativeCurrency.decimals not provided");
  const _web3 = new JsonRpcProvider(rpcUrls[0], "any");
  const {
    chainId: networkChainID
  } = await _web3.getNetwork();
  if (Number.parseInt(networkChainID.toString()) !== Number.parseInt(chainId, 16)) {
    throw new Error(`Provided rpc url's chainId version is not matching with provided chainId, expected: ${toQuantity(networkChainID)}, received: ${chainId}`);
  }
}
function validateSwitchChainData(data) {
  const {
    chainId
  } = data || {};
  if (!chainId) {
    throw new Error("Invalid switch chain params: please pass chainId in params");
  }
  if (!isHexString$1(chainId)) {
    throw new Error("Invalid switch chain params: please pass a valid hex chainId in params, for: ex: 0x1");
  }
}

class AddChainController extends AbstractMessageController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    addChain
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "AddChainController");
    _defineProperty(this, "addChain", void 0);
    this.addChain = addChain;
    this.initialize();
  }
  async processAddChain(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error("Message not found");
    }
    try {
      await this.approveMessage(messageId, msgObject.messageParams);
      await this.addChain(msgObject.messageParams);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig: JSON.stringify(msgObject.messageParams)
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    // set message params origin first to satisfy the eslint rule (origin won't be checked by validateAddChainData)
    // for "Possible race condition: `messageParams.origin` might be assigned based on an outdated state of `messageParams`"
    if (req) {
      messageParams.origin = req.origin;
    }
    await validateAddChainData(messageParams);
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ADD_CHAIN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

class DecryptMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    decryptMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "DecryptMessageController");
    _defineProperty(this, "decryptMessage", void 0);
    this.decryptMessage = decryptMessage;
    this.initialize();
  }
  async processDecryptMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error("Message not found");
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const parsedData = parseDecryptMessageData(cleanMsgParams.data);
      const rawSig = this.decryptMessage(parsedData, cleanMsgParams.from);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateDecryptedMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_DECRYPT
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(_objectSpread({}, messageParams));
  }
}

class EncryptionPublicKeyController extends AbstractMessageController {
  constructor({
    config,
    state,
    signEncryptionPublicKey,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "EncryptionPublicKeyController");
    _defineProperty(this, "signEncryptionPublicKey", void 0);
    this.signEncryptionPublicKey = signEncryptionPublicKey;
    this.initialize();
  }
  async processGetEncryptionPublicKey(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const publicKey = this.signEncryptionPublicKey(cleanMsgParams.from);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig: publicKey
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return publicKey;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateEncryptionPublicKeyMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    // From should be the public key for the encryption
    return Promise.resolve(_objectSpread(_objectSpread({}, messageParams), {}, {
      from: messageParams.data
    }));
  }
}

class MessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "MessageController");
    _defineProperty(this, "signMessage", void 0);
    this.signMessage = signMessage;
    this.initialize();
  }
  async processSignMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const rawSig = await this.signMessage(cleanMsgParams.data, cleanMsgParams.from);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSignMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.ETH_SIGN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

class PersonalMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signPersonalMessage,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "PersonalMessageController");
    _defineProperty(this, "signPersonalMessage", void 0);
    this.signPersonalMessage = signPersonalMessage;
    this.initialize();
  }
  async processSignPersonalMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const rawSig = await this.signPersonalMessage(cleanMsgParams.data, cleanMsgParams.from);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSignMessageData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.data = normalizeMessageData(messageParams.data);
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.PERSONAL_SIGN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

class SwitchChainController extends AbstractMessageController {
  constructor({
    config,
    state,
    getNetworkIdentifier,
    switchChain
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "SwitchChainController");
    _defineProperty(this, "switchChain", void 0);
    this.switchChain = switchChain;
    this.initialize();
  }
  async processSwitchChain(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      await this.approveMessage(messageId, msgObject.messageParams);
      this.switchChain({
        chainId: msgObject.messageParams.chainId
      });
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig: JSON.stringify(msgObject.messageParams)
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return null;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req) {
    await this.addUnapprovedMessage(messageParams, req);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req) {
    validateSwitchChainData(messageParams);
    if (req) {
      messageParams.origin = req.origin;
    }
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: METHOD_TYPES.SWITCH_CHAIN
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

function getMessageType(version) {
  switch (version) {
    case SignTypedDataVersion.V1:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
    case SignTypedDataVersion.V3:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3;
    case SignTypedDataVersion.V4:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4;
    default:
      return METHOD_TYPES.ETH_SIGN_TYPED_DATA;
  }
}
class TypedMessageController extends AbstractMessageController {
  constructor({
    config,
    state,
    signTypedData,
    getNetworkIdentifier
  }) {
    super({
      config,
      state,
      getNetworkIdentifier
    });
    _defineProperty(this, "name", "TypedMessageController");
    _defineProperty(this, "signTypedData", void 0);
    this.signTypedData = signTypedData;
    this.initialize();
  }
  async processSignTypedMessage(messageId) {
    const msgObject = this.getMessage(messageId);
    if (!msgObject) {
      throw new Error(`Message not found`);
    }
    try {
      const cleanMsgParams = await this.approveMessage(messageId, msgObject.messageParams);
      const msgData = cleanMsgParams.version === SignTypedDataVersion.V1 ? cleanMsgParams.data : JSON.parse(cleanMsgParams.data);
      const rawSig = await this.signTypedData(msgData, cleanMsgParams.from, cleanMsgParams.version);
      this.updateMessage(_objectSpread(_objectSpread({}, msgObject), {}, {
        rawSig
      }));
      this.setMessageStatus(messageId, MessageStatus.SIGNED);
      return rawSig;
    } catch (error) {
      log.error(error);
      msgObject.error = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
      this.setMessageStatus(messageId, MessageStatus.FAILED);
    }
  }
  async addNewUnapprovedMessage(messageParams, req, version) {
    await this.addUnapprovedMessage(messageParams, req, version);
    return this.waitForFinishStatus(messageParams, this.name);
  }
  async addUnapprovedMessage(messageParams, req, version) {
    if (version === SignTypedDataVersion.V1) {
      validateTypedSignMessageDataV1(messageParams);
    }
    if (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4) {
      const currentChainId = this.getNetworkIdentifier();
      await validateTypedSignMessageDataV3V4(messageParams, currentChainId);
    }
    if (typeof messageParams.data !== "string" && (version === SignTypedDataVersion.V3 || version === SignTypedDataVersion.V4)) {
      messageParams.data = JSON.stringify(messageParams.data);
    }
    if (req) {
      messageParams.origin = req.origin;
    }
    messageParams.version = version;
    const messageId = messageParams.id || randomId();
    const messageData = {
      id: messageId,
      messageParams,
      status: MessageStatus.UNAPPROVED,
      time: Date.now(),
      type: getMessageType(version)
    };
    await this.addMessage(messageData);
    this.emit(MESSAGE_EVENTS.UNAPPROVED_MESSAGE, {
      messageData,
      req
    });
    return messageId;
  }
  prepMessageForSigning(messageParams) {
    return Promise.resolve(messageParams);
  }
}

function createGetAccountsMiddleware({
  getAccounts
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.GET_ACCOUNTS) return next();
    if (!getAccounts) throw new Error("WalletMiddleware - opts.getAccounts not provided");
    const accounts = await getAccounts(request);
    response.result = accounts;
  });
}
function createProcessTransactionMiddleware({
  processTransaction
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_TRANSACTION) return next();
    if (!processTransaction) throw new Error("WalletMiddleware - opts.processTransaction not provided");
    response.result = await processTransaction(request.params, request);
  });
}
function createProcessEthSignMessage({
  processEthSignMessage
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN) return next();
    if (!processEthSignMessage) throw new Error("WalletMiddleware - opts.processEthSignMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, message]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message
      };
    }
    response.result = await processEthSignMessage(msgParams, request);
  });
}
function createProcessTypedMessage({
  processTypedMessage
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA) return next();
    if (!processTypedMessage) throw new Error("WalletMiddleware - opts.processTypedMessage not  provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [typedData, address]`);
      const params = request.params;
      const message = typeof params[0] === "string" ? JSON.parse(params[0]) : params[0];
      const address = params[1];
      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V1
      };
    }
    response.result = await processTypedMessage(msgParams, request);
  });
}
function createProcessTypedMessageV3({
  processTypedMessageV3
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V3) return next();
    if (!processTypedMessageV3) throw new Error("WalletMiddleware - opts.processTypedMessageV3 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V3
      };
    }
    response.result = await processTypedMessageV3(msgParams, request);
  });
}
function createProcessTypedMessageV4({
  processTypedMessageV4
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4) return next();
    if (!processTypedMessageV4) throw new Error("WalletMiddleware - opts.processTypedMessageV4 is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address, typedData]`);
      const params = request.params;
      const address = params[0];
      const message = params[1];
      msgParams = {
        from: address,
        data: message,
        version: SignTypedDataVersion.V4
      };
    }
    response.result = await processTypedMessageV4(msgParams, request);
  });
}
function createProcessPersonalMessage({
  processPersonalMessage
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.PERSONAL_SIGN) return next();
    if (!processPersonalMessage) throw new Error("WalletMiddleware - opts.processPersonalMessage is not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const params = request.params;
      if (typeof params[0] === "object") {
        const {
          challenge,
          address
        } = params[0];
        msgParams = {
          from: address,
          data: challenge
        };
      } else {
        const message = params[0];
        const address = params[1];
        msgParams = {
          from: address,
          data: message
        };
      }
    }
    response.result = await processPersonalMessage(msgParams, request);
  });
}
function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_COUNT) return next();
    const {
      blockReference
    } = params;
    if (blockReference !== "pending") return next();
    response.result = await getPendingNonce(params, request);
  });
}
function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    txReceipt,
    transaction,
    transactionHash,
    accessList
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = transaction;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash: transactionHash,
    nonce,
    input: data || "0x",
    value: value || "0x0",
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null,
    type: null
  };
  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }
  return formattedTxMeta;
}
function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      params,
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_TRANSACTION_BY_HASH) return next();
    if (!getPendingTransactionByHash) throw new Error("WalletMiddleware - opts.getPendingTransactionByHash not provided");
    const txMeta = await getPendingTransactionByHash(params, request);
    if (!txMeta) {
      return next();
    }
    response.result = formatTxMetaForRpcResult(txMeta);
    return undefined;
  });
}
function createProcessEncryptionPublicKeyMiddleware({
  processEncryptionPublicKey
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_GET_ENCRYPTION_PUBLIC_KEY) return next();
    if (!processEncryptionPublicKey) throw new Error("WalletMiddleware - opts.processEncryptionPublicKey not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [address]`);
      const [address] = request.params;
      msgParams = {
        data: address,
        from: address
      };
    }
    response.result = await processEncryptionPublicKey(msgParams, request);
  });
}
function createProcessDecryptMessageMiddleware({
  processDecryptMessage
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ETH_DECRYPT) return next();
    if (!processDecryptMessage) throw new Error("WalletMiddleware - opts.processDecryptMessage not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [message, address]`);
      const [message, address] = request.params;
      msgParams = {
        data: message,
        from: address
      };
    }
    response.result = await processDecryptMessage(msgParams, request);
  });
}
function createProcessSwitchEthereumChain({
  processSwitchEthereumChain
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.SWITCH_CHAIN) return next();
    if (!processSwitchEthereumChain) throw new Error("WalletMiddleware - opts.processSwitchEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processSwitchEthereumChain(msgParams, request);
  });
}
function createProcessAddEthereumChain({
  processAddEthereumChain
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== METHOD_TYPES.ADD_CHAIN) return next();
    if (!processAddEthereumChain) throw new Error("WalletMiddleware - opts.processAddEthereumChain not provided");
    if (!(request !== null && request !== void 0 && request.params)) throw new Error("WalletMiddleware - missing params");
    let msgParams = request.params;
    if (Array.isArray(request.params)) {
      if (!(request.params.length === 1)) throw new Error(`WalletMiddleware - incorrect params for ${method} method. expected [data]`);
      const [message] = request.params;
      msgParams = message;
    }
    response.result = await processAddEthereumChain(msgParams, request);
  });
}
function createRequestAccountsMiddleware({
  requestAccounts
}) {
  return createAsyncMiddleware(async (request, response, next) => {
    const {
      method
    } = request;
    if (method !== "eth_requestAccounts") return next();
    if (!requestAccounts) throw new Error("WalletMiddleware - opts.requestAccounts not provided");
    // This calls the UI login function
    const accounts = await requestAccounts(request);
    response.result = accounts;
    return undefined;
  });
}
function createEthereumMiddleware(providerHandlers) {
  const {
    requestAccounts,
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    getPendingNonce,
    getPendingTransactionByHash,
    processEncryptionPublicKey,
    processDecryptMessage,
    processSwitchEthereumChain,
    processAddEthereumChain,
    getProviderState,
    version
  } = providerHandlers;
  return mergeMiddleware([createScaffoldMiddleware({
    version,
    [PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState
  }), createRequestAccountsMiddleware({
    requestAccounts
  }), createGetAccountsMiddleware({
    getAccounts
  }), createProcessTransactionMiddleware({
    processTransaction
  }), createProcessEthSignMessage({
    processEthSignMessage
  }), createProcessTypedMessage({
    processTypedMessage
  }), createProcessTypedMessageV3({
    processTypedMessageV3
  }), createProcessTypedMessageV4({
    processTypedMessageV4
  }), createProcessPersonalMessage({
    processPersonalMessage
  }), createPendingNonceMiddleware({
    getPendingNonce
  }), createPendingTxMiddleware({
    getPendingTransactionByHash
  }), createProcessEncryptionPublicKeyMiddleware({
    processEncryptionPublicKey
  }), createProcessDecryptMessageMiddleware({
    processDecryptMessage
  }), createProcessSwitchEthereumChain({
    processSwitchEthereumChain
  }), createProcessAddEthereumChain({
    processAddEthereumChain
  })]);
}

let CacheStrategy = /*#__PURE__*/function (CacheStrategy) {
  CacheStrategy["Block"] = "block";
  CacheStrategy["Fork"] = "fork";
  CacheStrategy["Never"] = "never";
  CacheStrategy["Permanent"] = "perma";
  return CacheStrategy;
}({});
function blockTagParamIndex(method) {
  switch (method) {
    // blockTag is at index 2
    case "eth_getStorageAt":
      return 2;
    // blockTag is at index 1
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    // blockTag is at index 0
    case "eth_getBlockByNumber":
      return 0;
    // there is no blockTag
    default:
      return undefined;
  }
}
function cacheTypeForMethod(method) {
  switch (method) {
    // cache permanently
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return CacheStrategy.Permanent;

    // cache until fork
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return CacheStrategy.Fork;

    // cache for block
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return CacheStrategy.Block;

    // never cache
    default:
      return CacheStrategy.Never;
  }
}
function canCache(method) {
  return cacheTypeForMethod(method) !== CacheStrategy.Never;
}
function paramsWithoutBlockTag(request) {
  if (!request.params) {
    return [];
  }
  const index = blockTagParamIndex(request.method);

  // Block tag param not passed.
  if (index === undefined || !Array.isArray(request.params) || index >= request.params.length) {
    return request.params;
  }

  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
  if (request.method === "eth_getBlockByNumber") {
    return request.params.slice(1);
  }
  return request.params.slice(0, index);
}
function cacheIdentifierForRequest(request, skipBlockRef) {
  var _request$params;
  const simpleParams = skipBlockRef ? paramsWithoutBlockTag(request) : (_request$params = request.params) !== null && _request$params !== void 0 ? _request$params : [];
  if (canCache(request.method)) {
    return `${request.method}:${stringify(simpleParams)}`;
  }
  return null;
}

function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    if (req.method === "net_version") {
      // convert to decimal
      res.result = Number.parseInt(chainId, 16).toString(10);
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig, networkConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  const blockProvider = providerFromMiddleware(fetchMiddleware);
  const blockTracker = new PollingBlockTracker({
    config: _objectSpread(_objectSpread({}, networkConfig), {}, {
      provider: blockProvider
    }),
    state: {}
  });
  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig),
  // No need for the following middlewares for web because all browser sessions are quite short lived and each session is limited to scope of a window/tab
  // createBlockRefRewriteMiddleware({ blockTracker }),
  // createBlockCacheMiddleware({ blockTracker }),
  createInflightCacheMiddleware({
    cacheIdentifierForRequest
  }),
  // createBlockTrackerInspectorMiddleware({ blockTracker }),
  fetchMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

const _excluded = ["chainId", "rpcTarget"];
class NetworkController extends BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "NetworkController");
    _defineProperty(this, "providerProxy", void 0);
    _defineProperty(this, "blockTrackerProxy", void 0);
    _defineProperty(this, "mutex", new Mutex());
    _defineProperty(this, "provider", null);
    _defineProperty(this, "blockTracker", null);
    _defineProperty(this, "baseProviderHandlers", void 0);
    this.defaultState = {
      chainId: "loading",
      properties: {
        EIPS_1559: undefined
      },
      providerConfig: SUPPORTED_NETWORKS[MAINNET_CHAIN_ID]
    };

    // when a new network is set,
    // we set to loading first and
    // then when connection succeeds,
    // we update the network
    this.initialize();
  }
  getNetworkIdentifier() {
    return this.state.chainId;
  }
  getNetworkRPCUrl() {
    return this.state.providerConfig.rpcTarget;
  }

  /**
   * Called by orchestrator once while initializing the class
   * @param providerHandlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */
  initializeProvider(providerHandlers) {
    this.baseProviderHandlers = providerHandlers;
    this.configureProvider();
    this.lookupNetwork(); // Not awaiting this, because we don't want to block the initialization
    return this.providerProxy;
  }
  getProvider() {
    return this.providerProxy;
  }
  getBlockTracker() {
    return this.blockTrackerProxy;
  }
  getProviderConfig() {
    return this.state.providerConfig;
  }
  setProviderConfig(config) {
    this.update({
      providerConfig: _objectSpread({}, config)
    });
    this.refreshNetwork();
  }
  async getEIP1559Compatibility() {
    const {
      EIPS_1559
    } = this.state.properties;
    // log.info('checking eip 1559 compatibility')
    if (EIPS_1559 !== undefined) {
      return EIPS_1559;
    }
    const latestBlock = await this.blockTracker.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.update({
      properties: {
        EIPS_1559: supportsEIP1559
      }
    });
    return supportsEIP1559;
  }

  /**
   * Refreshes the current network code
   */
  async lookupNetwork() {
    const {
      chainId,
      rpcTarget
    } = this.getProviderConfig();
    if (!chainId || !rpcTarget || !this.provider) {
      this.update({
        chainId: "loading",
        properties: {}
      });
      return;
    }
    const releaseLock = await this.mutex.acquire();
    try {
      // use eth_chainId
      const [networkChainId] = await Promise.all([this.provider.request({
        method: "eth_chainId"
      }), this.getEIP1559Compatibility()]);
      log.info("network fetched chain id", networkChainId);
      // update chain ID
      this.update({
        chainId: networkChainId
      });
      this.emit("networkDidChange");
    } catch {
      this.update({
        chainId: "loading"
      });
    } finally {
      releaseLock();
    }
  }
  configureProvider() {
    const _this$getProviderConf = this.getProviderConfig(),
      {
        chainId,
        rpcTarget
      } = _this$getProviderConf,
      rest = _objectWithoutProperties(_this$getProviderConf, _excluded);
    if (!chainId || !rpcTarget) {
      throw new Error("chainId and rpcTarget must be provider in providerConfig");
    }
    this.configureStandardProvider(_objectSpread({
      chainId,
      rpcTarget
    }, rest));
  }
  setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const ethereumMiddleware = createEthereumMiddleware(this.baseProviderHandlers);
    const engine = new JRPCEngine();
    engine.push(ethereumMiddleware);
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.setProvider({
      provider,
      blockTracker
    });
  }
  setProvider({
    provider,
    blockTracker
  }) {
    if (this.providerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.providerProxy.setTarget(provider);
    } else {
      this.providerProxy = createSwappableProxy(provider);
    }
    if (this.blockTrackerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.blockTrackerProxy.setTarget(blockTracker);
    } else {
      this.blockTrackerProxy = createEventEmitterProxy(blockTracker, {
        eventFilter: "skipInternal"
      });
    }

    // set new provider and blockTracker
    this.provider = provider;
    provider.setMaxListeners(10);
    this.blockTracker = blockTracker;
  }
  configureStandardProvider(providerConfig) {
    const networkClient = createJsonRpcClient(providerConfig, this.config);
    log.info("networkClient", networkClient);
    this.setNetworkClient(networkClient);
  }
  refreshNetwork() {
    this.update({
      chainId: "loading",
      properties: {}
    });
    this.configureProvider();
    this.lookupNetwork();
  }
}

class NftHandler {
  constructor({
    chainId,
    contractAddress,
    contractImage,
    contractName,
    contractSymbol,
    nftStandard,
    provider,
    contractDescription,
    contractFallbackLogo,
    contractSupply
  }) {
    _defineProperty(this, "contractAddress", void 0);
    _defineProperty(this, "contractName", void 0);
    _defineProperty(this, "contractSymbol", void 0);
    _defineProperty(this, "contractImage", void 0);
    _defineProperty(this, "contractSupply", void 0);
    _defineProperty(this, "contractFallbackLogo", void 0);
    _defineProperty(this, "nftStandard", void 0);
    _defineProperty(this, "contractDescription", void 0);
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "isSpecial", void 0);
    this.chainId = chainId;
    this.contractAddress = contractAddress;
    this.contractImage = contractImage;
    this.contractName = contractName;
    this.contractSymbol = contractSymbol;
    this.nftStandard = nftStandard;
    this.provider = provider;
    this.contractDescription = contractDescription;
    this.contractFallbackLogo = contractFallbackLogo;
    this.contractSupply = contractSupply;
  }
  async getNftMetadata(userAddress, tokenInfo) {
    const returnNftItem = _objectSpread({
      description: "",
      image: "",
      name: "",
      tokenBalance: "",
      tokenId: "",
      decimals: "1"
    }, tokenInfo);
    const [tokenURI, balance] = await Promise.all([this.getCollectibleTokenURI(returnNftItem.tokenId, this.nftStandard), !returnNftItem.tokenBalance ? this.fetchNftBalance(userAddress, returnNftItem.tokenId) : Promise.resolve("0")]);
    returnNftItem.tokenBalance = returnNftItem.tokenBalance || balance;
    // some people put full json object in uri
    try {
      const object = JSON.parse(tokenURI);
      returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
      returnNftItem.name = returnNftItem.name || object.name;
      returnNftItem.description = returnNftItem.description || object.description;
      returnNftItem.decimals = returnNftItem.decimals || object.decimals;
    } catch (error) {
      log.warn("Token uri is not a valid json object", error);
    }
    const finalTokenMetaUri = sanitizeNftMetdataUrl(tokenURI);
    try {
      if (!returnNftItem.description || !returnNftItem.image || !returnNftItem.name) {
        // this call might fail, if metadata url available in smart contract is not reachable
        const object = await get(finalTokenMetaUri);
        returnNftItem.image = returnNftItem.image || sanitizeNftMetdataUrl(object.image);
        returnNftItem.name = returnNftItem.name || object.name;
        returnNftItem.description = returnNftItem.description || object.description;
        returnNftItem.decimals = returnNftItem.decimals || object.decimals;
      }
    } catch (error) {
      log.error("Failed to fetch nft metadata", error);
    }
    return returnNftItem;
  }
  async getContractMetadata() {
    const returnNft = {
      chainId: this.chainId,
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      contractSymbol: this.contractSymbol,
      nftStandard: this.nftStandard,
      contractImage: this.contractImage,
      contractDescription: this.contractDescription,
      contractFallbackLogo: this.contractFallbackLogo,
      contractSupply: this.contractSupply
    };
    if (!this.nftStandard) {
      const {
        standard,
        isSpecial
      } = await this.checkNftStandard();
      returnNft.nftStandard = standard;
      this.nftStandard = standard;
      this.isSpecial = isSpecial;
    }
    if (!this.contractName || !this.contractSymbol || !this.contractDescription) {
      const abi = this.nftStandard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
      const contract = new Contract(this.contractAddress, abi, this.provider);
      const [name, symbol] = await Promise.all([contract.name(), contract.symbol()]);
      returnNft.contractName = name;
      returnNft.contractSymbol = symbol;
      if (!this.contractName) this.contractName = name;
      if (!this.contractSymbol) this.contractSymbol = symbol;
    }
    return returnNft;
  }
  async fetchNftBalance(userAddress, tokenId) {
    const {
      standard
    } = await this.checkNftStandard();
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    if (standard === CONTRACT_TYPE_ERC1155) {
      const balance = await contract.balanceOf(userAddress, tokenId);
      return balance;
    }
    let owner = "";
    try {
      owner = await contract.ownerOf(tokenId);
    } catch {
      throw new Error("Token id doesn't exists");
    }
    if (owner.toLowerCase() === userAddress.toLowerCase()) {
      return "1";
    }
    return "0";
  }
  async checkNftStandard() {
    // For Cryptokitties
    if (this.nftStandard && this.isSpecial !== undefined) return;
    if (Object.prototype.hasOwnProperty.call(OLD_ERC721_LIST, this.contractAddress.toLowerCase())) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = true;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: true
      };
    }
    const isErc721 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC721, ERC721_INTERFACE_ID);
    if (isErc721) {
      this.nftStandard = CONTRACT_TYPE_ERC721;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC721,
        isSpecial: false
      };
    }
    const isErc1155 = await this.contractSupportsInterface(CONTRACT_TYPE_ERC1155, ERC1155_INTERFACE_ID);
    if (isErc1155) {
      this.nftStandard = CONTRACT_TYPE_ERC1155;
      this.isSpecial = false;
      return {
        standard: CONTRACT_TYPE_ERC1155,
        isSpecial: false
      };
    }
    throw new Error("Unsupported nft standard");
  }
  async contractSupportsInterface(standard, interfaceId) {
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract.supportsInterface(interfaceId);
  }
  async getCollectibleTokenURI(tokenId, standard = CONTRACT_TYPE_ERC721) {
    const method = standard === CONTRACT_TYPE_ERC721 ? "tokenURI" : "uri";
    const abi = standard === CONTRACT_TYPE_ERC721 ? erc721Abi : erc1155Abi;
    const contract = new Contract(this.contractAddress, abi, this.provider);
    return contract[method](tokenId);
  }
}

const DEFAULT_INTERVAL$1 = 180 * 1000;
class NftsController extends BaseController {
  constructor({
    config,
    state,
    provider,
    getCustomNfts,
    getSimpleHashNfts,
    onPreferencesStateChange,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "NftsController");
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "_timer", void 0);
    _defineProperty(this, "getCustomNfts", void 0);
    _defineProperty(this, "getSimpleHashNfts", void 0);
    this.provider = provider;
    this.ethersProvider = new BrowserProvider(this.provider, "any");
    this.getCustomNfts = getCustomNfts;
    this.getSimpleHashNfts = getSimpleHashNfts;
    this.defaultConfig = {
      interval: DEFAULT_INTERVAL$1,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      nfts: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartNftDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartNftDetection();
      }
    });
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userNfts() {
    var _this$state$nfts$this;
    if (!this.userSelectedAddress) return [];
    return (_this$state$nfts$this = this.state.nfts[this.userSelectedAddress]) !== null && _this$state$nfts$this !== void 0 ? _this$state$nfts$this : [];
  }
  get interval() {
    return this.config.interval;
  }
  set interval(interval) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewNfts();
        this.refreshNftBalances();
      }
    }, interval);
  }
  startNftDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartNftDetection();
  }

  /**
   * Restart nft detection polling period and call detectNewNfts
   * in case of address change or user session initialization.
   *
   */
  restartNftDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewNfts();
    this.refreshNftBalances();
    this.config.interval = DEFAULT_INTERVAL$1;
  }
  detectNewNfts() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const nftsToDetect = []; // object[]
    if (!currentChainId) {
      this.update({
        nfts: {
          [userAddress]: [...nftsToDetect]
        }
      });
      return;
    }
    if (this.getCustomNfts) {
      const customNfts = this.getCustomNfts(userAddress);
      const reducedNfts = customNfts.reduce((acc, x) => {
        // first aggregate by contract address
        if (x.network === currentChainId) {
          const newAsset = {
            description: "",
            image: "",
            name: "",
            tokenBalance: "",
            tokenId: x.nft_id,
            customNftId: x.id.toString()
          };
          if (acc[x.nft_address]) {
            acc[x.nft_address].assets.push(newAsset);
          } else {
            const objToPush = {
              assets: [newAsset],
              chainId: x.network,
              contractAddress: x.nft_address,
              contractName: "",
              contractSymbol: "",
              contractImage: "",
              nftStandard: x.nft_contract_standard,
              contractDescription: ""
            };
            acc[x.nft_address] = objToPush;
          }
        }
        return acc;
      }, {});
      nftsToDetect.push(...Object.values(reducedNfts));
    }
    this.update({
      nfts: {
        [userAddress]: [...nftsToDetect]
      }
    });
  }
  async refreshNftBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldNfts = [...this.userNfts];
    const nonZeroNfts = [];
    try {
      const currentChainId = this.config.chainId;
      if (SIMPLEHASH_SUPPORTED_CHAINS.includes(currentChainId)) {
        const simpleHashBalances = await this.getSimpleHashNfts(userAddress, currentChainId);
        nonZeroNfts.push(...simpleHashBalances);
        this.update({
          nfts: {
            [userAddress]: nonZeroNfts
          }
        });
      }
      if (oldNfts.length > 0) {
        this.getNftBalancesUsingHandler(oldNfts);
      }
    } catch (error) {
      log.error(error, "unable to fetch nft balances");
    }
  }
  async getNftBalancesUsingHandler(customNfts) {
    if (!this.userSelectedAddress) return;
    const userAddress = this.userSelectedAddress;
    const currentNetworkNfts = customNfts;
    const promiseSettledResult = await Promise.allSettled(currentNetworkNfts.map(async x => {
      try {
        const tokenInstance = new NftHandler(_objectSpread(_objectSpread({}, x), {}, {
          provider: this.ethersProvider
        }));
        const contractData = await tokenInstance.getContractMetadata();
        const assetData = await Promise.allSettled(x.assets.map(y => tokenInstance.getNftMetadata(userAddress, y)));
        return _objectSpread(_objectSpread({}, contractData), {}, {
          assets: assetData.filter(z => z.status === "fulfilled").map(z => z.value)
        });
      } catch (error) {
        log.warn("Invalid contract address while fetching", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.filter(x => x.status === "fulfilled").map(x => x.value);
    this.update({
      nfts: {
        [userAddress]: deepmerge(this.userNfts, nonZeroTokens)
      }
    });
  }
}

class PreferencesController extends BasePreferencesController {
  constructor({
    config,
    state,
    provider,
    signAuthMessage,
    getProviderConfig,
    setProviderConfig,
    validateSignMessage
  }) {
    super({
      config,
      state,
      defaultPreferences: {
        formattedPastTransactions: [],
        fetchedPastTx: [],
        paymentTx: [],
        etherscanTransactions: []
      },
      signAuthMessage,
      validateSignMessage
    });
    _defineProperty(this, "_handle", void 0);
    _defineProperty(this, "_mutex", new Mutex());
    _defineProperty(this, "getProviderConfig", void 0);
    _defineProperty(this, "setProviderConfig", void 0);
    _defineProperty(this, "provider", void 0);
    this.provider = provider;
    this.getProviderConfig = getProviderConfig;
    this.setProviderConfig = setProviderConfig;
  }
  async poll(interval) {
    var _this$getAddressState;
    const releaseLock = await this._mutex.acquire();
    if (interval) this.configure({
      pollInterval: interval
    });
    if (this._handle) window.clearTimeout(this._handle);
    // call here
    const storeSelectedAddress = this.state.selectedAddress;
    if (!storeSelectedAddress) return;
    if (!((_this$getAddressState = this.getAddressState(storeSelectedAddress)) !== null && _this$getAddressState !== void 0 && _this$getAddressState.jwtToken)) return;
    // This should never throw
    await this.sync(storeSelectedAddress);
    releaseLock();
    this._handle = window.setTimeout(() => {
      this.poll(this.config.pollInterval);
    }, this.config.pollInterval);
  }
  async initPreferences(params) {
    const {
      address,
      jwtToken,
      calledFromEmbed,
      userInfo,
      rehydrate,
      locale = "en",
      type,
      signatures,
      web3AuthClientId,
      web3AuthNetwork,
      loginMode,
      sessionPubKey
    } = params;
    await super.init({
      address,
      userInfo,
      idToken: jwtToken,
      type,
      metadata: {
        email: userInfo.email,
        signatures,
        network: web3AuthNetwork
      }
    });
    const {
      aggregateVerifier,
      verifier,
      verifierId
    } = userInfo || {};
    const userExists = await this.sync(address);
    if (!userExists) {
      const accountState = this.getAddressState(address);
      await this.createUser({
        selectedCurrency: accountState.selectedCurrency,
        theme: accountState.theme,
        verifier: aggregateVerifier || verifier,
        verifierId,
        locale,
        address,
        type,
        web3AuthNetwork
      });
    }
    this.storeUserLogin({
      verifier: aggregateVerifier || verifier,
      verifierId,
      options: {
        calledFromEmbed,
        rehydrate
      },
      address,
      web3AuthClientId,
      web3AuthNetwork,
      sessionPubKey,
      loginMode
    });
  }
  getSelectedAddress() {
    return this.state.selectedAddress;
  }
  async sync(address) {
    try {
      const user = await this.getUser(address);
      if (user) {
        const {
          default_currency: defaultCurrency,
          contacts,
          theme,
          locale,
          public_address: userPublicAddress,
          default_public_address: defaultPublicAddress,
          customNetworks,
          customTokens,
          customNfts,
          account_type: accountType
        } = user || {};

        // update latest data in state.
        this.updateState({
          contacts,
          theme,
          selectedCurrency: defaultCurrency,
          locale,
          defaultPublicAddress: defaultPublicAddress || userPublicAddress,
          customTokens,
          customNfts,
          customNetworks,
          accountType: accountType
        }, address);
        return true;
      }
      return false;
    } catch (error) {
      if (isUnauthorizedError(error)) {
        throw error;
      }
      log.error(error);
      return false;
    } finally {
      this.getWalletOrders(address).then(walletTx => {
        // eslint-disable-next-line promise/always-return
        if (walletTx && walletTx.length > 0) {
          this.updateState({
            fetchedPastTx: [...walletTx]
          }, address);
          this.calculatePastTx(walletTx, address);
        }
      }).catch(error => log.error(error));
    }
  }
  async patchNewTx(tx, address) {
    var _this$getAddressState2;
    const formattedTx = formatPastTx({
      transaction: tx,
      blockExplorerUrl: this.getBlockExplorerUrl()
    });
    const storePastTx = ((_this$getAddressState2 = this.getAddressState(address)) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.formattedPastTransactions) || [];
    const duplicateIndex = storePastTx.findIndex(x => x.transaction_hash === tx.transaction_hash && x.chainId === tx.chain_id);
    if (tx.status === TransactionStatus.submitted || tx.status === TransactionStatus.confirmed) {
      if (duplicateIndex === -1) {
        var _tx$to;
        // No duplicate found

        const finalTx = this.cancelTxCalculate([...storePastTx, formattedTx]);
        tx.is_cancel = formattedTx.is_cancel;
        tx.to = (_tx$to = tx.to) === null || _tx$to === void 0 ? void 0 : _tx$to.toLowerCase();
        tx.from = tx.from.toLowerCase();
        this.updateState({
          formattedPastTransactions: finalTx
        }, address);
        this.postPastTx(tx, address);
      } else {
        // avoid overriding is_cancel
        formattedTx.is_cancel = storePastTx[duplicateIndex].is_cancel;
        storePastTx[duplicateIndex] = formattedTx;
        this.updateState({
          formattedPastTransactions: this.cancelTxCalculate([...storePastTx])
        }, address);
      }
    }
  }
  recalculatePastTx(address) {
    // This triggers store update which calculates past Tx status for that network
    const selectedAddress = address || this.state.selectedAddress;
    const state = this.getAddressState(selectedAddress);
    if (!(state !== null && state !== void 0 && state.fetchedPastTx)) return;
    this.calculatePastTx(state.fetchedPastTx, selectedAddress);
  }
  async refetchEtherscanTx(address) {
    var _this$getAddressState3;
    const selectedAddress = address || this.state.selectedAddress;
    if (!selectedAddress) return [];
    const lowerCaseSelectedAddress = selectedAddress === null || selectedAddress === void 0 ? void 0 : selectedAddress.toLowerCase();
    if ((_this$getAddressState3 = this.getAddressState(selectedAddress)) !== null && _this$getAddressState3 !== void 0 && _this$getAddressState3.jwtToken) {
      const {
        chainId
      } = this.getProviderConfig();
      if (ETHERSCAN_SUPPORTED_CHAINS.includes(chainId)) {
        const etherscanTxn = await this.fetchEtherscanTx({
          selectedAddress,
          chainId: this.getProviderConfig().chainId
        });
        const finalEthScanTxn = await addEtherscanTransactions({
          txn: etherscanTxn,
          lowerCaseSelectedAddress,
          provider: this.provider,
          chainId,
          blockExplorerUrl: this.getBlockExplorerUrl()
        });
        log.info("Formatted Etherscan Response", finalEthScanTxn);
        this.updateState({
          etherscanTransactions: finalEthScanTxn
        });
        return etherscanTxn;
      }
    }
  }
  async fetchEtherscanTx(parameters) {
    try {
      const response = await this.wsApiClient.authGet(`etherscan?chainId=${parameters.chainId}`, this.authCredentials(parameters.selectedAddress));
      log.info("Etherscan Response API", response);
      return response.success ? response.data : [];
    } catch (error) {
      log.error("unable to fetch etherscan tx", error);
      return [];
    }
  }
  async getEtherScanTokens(address, chainId) {
    const selectedAddress = address;
    const result = await this.wsApiClient.authGet(`tokens?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());
    return result.data;
  }
  async getSimpleHashNfts(address, chainId) {
    const selectedAddress = address;
    const result = await this.wsApiClient.authGet(`nfts?chainId=${chainId}&address=${selectedAddress}`, this.authCredentials());
    return result.data;
  }
  getCustomTokens(address) {
    var _this$getAddressState4, _this$getAddressState5;
    return (_this$getAddressState4 = (_this$getAddressState5 = this.getAddressState(address)) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.customTokens) !== null && _this$getAddressState4 !== void 0 ? _this$getAddressState4 : [];
  }
  getCustomNfts(address) {
    var _this$getAddressState6, _this$getAddressState7;
    return (_this$getAddressState6 = (_this$getAddressState7 = this.getAddressState(address)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.customNfts) !== null && _this$getAddressState6 !== void 0 ? _this$getAddressState6 : [];
  }
  isChainIdSupported(address, chainId) {
    const approveChainOptions = this.getChainOptions(address);
    const providerConfig = approveChainOptions.find(x => stripHexPrefix(x.chainId) === chainId);
    return !!providerConfig;
  }
  async addChain(network) {
    const approveChainOptions = this.getChainOptions();
    const providerConfig = approveChainOptions.find(x => x.chainId === network.chainId);
    if (providerConfig) return;
    const newNetwork = {
      displayName: network.chainName,
      rpcTarget: network.rpcUrls[0],
      ticker: network.nativeCurrency.symbol,
      chainId: network.chainId,
      blockExplorerUrl: network.blockExplorerUrls[0],
      tickerName: network.nativeCurrency.name,
      logo: network.nativeCurrency.symbol
    };
    const isSuccess = await this.addCustomNetwork({
      network: newNetwork
    });
    if (!isSuccess) throw new Error("unable to add custom network");
  }
  switchChain(data) {
    const chainOptions = this.getChainOptions();
    const providerConfig = chainOptions.find(x => x.chainId === data.chainId);
    if (providerConfig) {
      this.setProviderConfig(providerConfig);
    } else {
      throw new Error(`chainId ${data.chainId} is not supported`);
    }
  }

  // Custom Network methods
  async addCustomNetwork({
    network
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false,
        logo: network.logo,
        symbol_name: network.tickerName
      };
      const res = await this.wsApiClient.authPost("customnetwork", payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return res.data.id;
    } catch {
      log.error("error adding custom network");
      return null;
    }
  }
  async deleteCustomNetwork(id) {
    try {
      const {
        selectedAddress
      } = this.state;
      await this.wsApiClient.authRemove(`customnetwork/${id}`, {}, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error deleting custom network");
      return false;
    }
  }
  async editCustomNetwork({
    network,
    id
  }) {
    try {
      const {
        selectedAddress
      } = this.state;
      const payload = {
        network_name: network.displayName,
        rpc_url: network.rpcTarget,
        chain_id: network.chainId,
        symbol: network.ticker || undefined,
        block_explorer_url: network.blockExplorerUrl || undefined,
        is_testnet: network.isTestnet || false
      };
      await this.wsApiClient.authPatch(`customnetwork/${id}`, payload, this.authCredentials(selectedAddress), {
        useAPIKey: true
      });
      await this.sync(selectedAddress);
      return true;
    } catch {
      log.error("error editing custom network");
      return false;
    }
  }
  getChainOptions(address = this.state.selectedAddress) {
    var _identities$address$c, _identities$address;
    const {
      identities
    } = this.state;
    const customNetworks = (_identities$address$c = (_identities$address = identities[address]) === null || _identities$address === void 0 ? void 0 : _identities$address.customNetworks) !== null && _identities$address$c !== void 0 ? _identities$address$c : [];
    const custom = Object.values(customNetworks).reduce((chains, network) => {
      const networkItem = {
        blockExplorerUrl: network.block_explorer_url,
        chainId: network.chain_id,
        displayName: network.network_name,
        logo: "eth.svg",
        rpcTarget: network.rpc_url,
        ticker: network.symbol,
        tickerName: network.symbol.toUpperCase(),
        isCustom: true,
        id: network.id
      };
      if (Object.keys(SUPPORTED_NETWORKS).includes(networkItem.chainId)) return chains;
      chains.push(networkItem);
      return chains;
    }, []);
    const supported = Object.values(SUPPORTED_NETWORKS).reduce((chains, network) => {
      chains.push(network);
      return chains;
    }, []);
    return [...supported, ...custom];
  }
  getBlockExplorerUrl() {
    const supportedNetworks = this.getChainOptions();
    const network = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    if (!network) return "";
    return `${network.blockExplorerUrl}`;
  }
  async calculatePastTx(txs, address) {
    const pastTx = [];
    const pendingTx = [];
    const lowerCaseSelectedAddress = address.toLowerCase();
    const supportedNetworks = this.getChainOptions(address);
    const supportedNetwork = supportedNetworks.find(x => x.chainId === this.getProviderConfig().chainId);
    for (const x of txs) {
      var _x$to;
      if ((supportedNetwork === null || supportedNetwork === void 0 ? void 0 : supportedNetwork.chainId) === x.chain_id && x.to && x.from && (lowerCaseSelectedAddress === x.from.toLowerCase() || lowerCaseSelectedAddress === ((_x$to = x.to) === null || _x$to === void 0 ? void 0 : _x$to.toLowerCase()))) {
        if (x.status !== "confirmed") {
          pendingTx.push(x);
        } else {
          const finalObject = formatPastTx({
            transaction: x,
            lowerCaseSelectedAddress,
            blockExplorerUrl: this.getBlockExplorerUrl()
          });
          pastTx.push(finalObject);
        }
      }
    }
    const pendingTxPromises = pendingTx.map(x => getEthTxStatus(x.transaction_hash, this.provider).catch(error => log.error(error)));
    const resolvedTxStatuses = await Promise.all(pendingTxPromises);
    for (const [index, element] of pendingTx.entries()) {
      const finalObject = formatPastTx({
        transaction: element,
        lowerCaseSelectedAddress,
        blockExplorerUrl: this.getBlockExplorerUrl()
      });
      finalObject.status = resolvedTxStatuses[index] || TransactionStatus.submitted;
      pastTx.push(finalObject);
      if (lowerCaseSelectedAddress === element.from.toLowerCase() && finalObject.status && finalObject.status !== element.status) this.patchPastTx({
        id: element.id,
        status: finalObject.status
      }, address);
    }
    const finalTx = this.cancelTxCalculate(pastTx);
    this.updateState({
      formattedPastTransactions: [...finalTx]
    }, address);
  }
  cancelTxCalculate(pastTx) {
    const nonceMap = {};
    for (const x of pastTx) {
      if (!nonceMap[x.nonce]) nonceMap[x.nonce] = [x];else {
        nonceMap[x.nonce].push(x);
      }
    }
    for (const [, value] of Object.entries(nonceMap)) {
      // has duplicate
      if (value.length > 1) {
        // get latest and mark it as is_cancel
        const latestTxs = value.sort((a, b) => {
          const aDate = new Date(a.date).getTime();
          const bDate = new Date(b.date).getTime();
          return bDate - aDate;
        });
        const latestCancelTx = latestTxs[0];
        latestCancelTx.is_cancel = true;
        latestTxs.slice(1).forEach(x => {
          x.hasCancel = true;
          x.status = latestCancelTx.status === "confirmed" ? TransactionStatus.cancelled : TransactionStatus.cancelling;
          x.cancelDateInitiated = `${formatTime(new Date(latestCancelTx.date).getTime())} - ${formatDate(latestCancelTx.date)}`;
          x.etherscanLink = latestCancelTx.etherscanLink;
          x.cancelGas = latestCancelTx.gas;
          x.cancelGasPrice = latestCancelTx.gasPrice;
        });
      }
    }
    return pastTx;
  }
}

class TokenHandler {
  constructor({
    address,
    symbol,
    decimals,
    name,
    provider
  }) {
    _defineProperty(this, "address", void 0);
    _defineProperty(this, "symbol", void 0);
    _defineProperty(this, "decimals", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "contract", void 0);
    this.address = address;
    this.contract = new Contract(address, erc20Abi, provider);
    this.symbol = symbol;
    this.decimals = decimals;
    this.name = name;
  }
  async getSymbol() {
    if (!this.symbol || this.symbol === "ERC20") this.symbol = await this.contract.symbol();
    return this.symbol;
  }
  async getDecimals() {
    try {
      if (!this.decimals) this.decimals = await this.contract.decimals();
      return this.decimals;
    } catch (error) {
      log.warn(`Could not get decimals for token ${this.address}`, error);
      return 0;
    }
  }
  async getName() {
    if (!this.name) this.name = await this.contract.name();
    return this.name;
  }
  async getUserBalance(userAddress) {
    if (!this.decimals) await this.getDecimals();
    const balance = await this.contract.balanceOf(userAddress);
    return balance.toString(16);
  }
}

const DEFAULT_CURRENCY = "eth";
class TokenRatesController extends BaseController {
  constructor({
    config,
    state,
    onPreferencesStateChange,
    onNetworkStateChange,
    onTokensStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "conversionInterval", void 0);
    this.defaultState = _objectSpread(_objectSpread({}, this.defaultState), {}, {
      contractExchangeRates: {}
    });
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      const {
        selectedAddress
      } = preferencesState;
      this.configure({
        selectedAddress
      });
    });
    onNetworkStateChange(networkState => {
      const {
        chainId,
        ticker
      } = networkState.providerConfig;
      this.configure({
        chainId,
        nativeCurrency: ticker
      });
    });
    onTokensStateChange(tokensState => {
      const {
        tokens
      } = tokensState;
      const currentUserTokens = tokens[this.config.selectedAddress];
      if ((currentUserTokens === null || currentUserTokens === void 0 ? void 0 : currentUserTokens.length) > 0 && this.config.tokens !== tokens[this.config.selectedAddress]) {
        this.configure({
          tokens: tokens[this.config.selectedAddress]
        });
        this.updateExchangeRates();
      }
    });
  }

  /**
   * Creates a new poll, using setInterval, to periodically call updateConversionRate. The id of the interval is
   * stored at the controller's conversionInterval property. If it is called and such an id already exists, the
   * previous interval is clear and a new one is created.
   */
  scheduleConversionInterval() {
    if (this.conversionInterval) {
      window.clearInterval(this.conversionInterval);
    }
    this.conversionInterval = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.updateExchangeRates();
      }
    }, this.config.pollInterval);
  }
  async updateExchangeRates() {
    const chainCodes = COINGECKO_PLATFORMS_CHAIN_CODE_MAP[this.config.chainId];
    let newContractExchangeRates = {};
    if (!chainCodes) {
      log.info(`ChainId ${this.config.chainId} not supported by coingecko`);
      this.config.tokens.forEach(token => {
        newContractExchangeRates[token.tokenAddress] = undefined;
      });
    } else {
      newContractExchangeRates = await this.fetchExchangeRates(this.config.nativeCurrency, chainCodes);
    }
    this.update({
      contractExchangeRates: newContractExchangeRates
    });
  }
  async fetchExchangeRates(nativeCurrency, chainCodes) {
    const contractAddresses = this.config.tokens.map(token => token.tokenAddress);
    const isNativeCurrencySupported = COINGECKO_SUPPORTED_CURRENCIES.has(nativeCurrency.toLowerCase());
    if (isNativeCurrencySupported) {
      const response = await get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${nativeCurrency.toLowerCase()}`);
      const newContractExchangeRates = {};
      Object.keys(response).forEach(contractAddress => {
        newContractExchangeRates[contractAddress] = response[contractAddress][nativeCurrency.toLowerCase()] || 0;
      });
      return newContractExchangeRates;
    }
    const [response, currencyResponse] = await Promise.all([get(`${this.config.currencyApi}/currency/exchange-rates?platform=${chainCodes.platform}&contract_addresses=${contractAddresses.join(",")}&vs_currencies=${DEFAULT_CURRENCY}`), get(`${this.config.currencyApi}/currency?fsym=${nativeCurrency.toUpperCase()}&tsyms=${DEFAULT_CURRENCY.toUpperCase()}`)]);
    const newContractExchangeRates = {};
    Object.keys(response).forEach(contractAddress => {
      newContractExchangeRates[contractAddress] = response[contractAddress][DEFAULT_CURRENCY] * Number.parseFloat(currencyResponse[DEFAULT_CURRENCY]) || 0;
    });
    return newContractExchangeRates;
  }
}

function getObjectFromArrayBasedonKey(oldArray, key) {
  return oldArray.reduce((acc, x) => {
    const xkey = x[key];
    if (typeof xkey === "boolean") return acc;
    acc[xkey] = x;
    return acc;
  }, {});
}
const mergeTokenArrays = (oldArray, newArray) => {
  const oldMap = getObjectFromArrayBasedonKey(oldArray || [], "tokenAddress");
  const newMap = getObjectFromArrayBasedonKey(newArray || [], "tokenAddress");
  const finalArr = newArray;
  Object.keys(oldMap).forEach(x => {
    if (!newMap[x] && oldMap[x].isEtherScan) finalArr.push(oldMap[x]);
  });
  return finalArr;
};
const DEFAULT_INTERVAL = 180 * 1000;
class TokensController extends BaseController {
  constructor({
    config,
    state,
    provider,
    getCustomTokens,
    getEtherScanTokens,
    getProviderConfig,
    onPreferencesStateChange,
    onNetworkStateChange
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "TokensController");
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "ethersProvider", void 0);
    _defineProperty(this, "_timer", void 0);
    _defineProperty(this, "getProviderConfig", void 0);
    _defineProperty(this, "getCustomTokens", void 0);
    _defineProperty(this, "getEtherScanTokens", void 0);
    this.provider = provider;
    this.ethersProvider = new BrowserProvider(this.provider, "any");
    this.getCustomTokens = getCustomTokens;
    this.getEtherScanTokens = getEtherScanTokens;
    this.getProviderConfig = getProviderConfig;
    this.defaultConfig = {
      interval: DEFAULT_INTERVAL,
      selectedAddress: "",
      chainId: ""
    };
    this.defaultState = {
      tokens: {}
    };
    this.initialize();
    onPreferencesStateChange(preferencesState => {
      if (preferencesState.selectedAddress !== this.config.selectedAddress) {
        this.configure({
          selectedAddress: preferencesState.selectedAddress
        });
        this.restartTokenDetection();
      }
    });
    onNetworkStateChange(networkState => {
      const {
        chainId
      } = networkState.providerConfig;
      if (chainId !== this.config.chainId) {
        this.configure({
          chainId
        });
        this.restartTokenDetection();
      }
    });
  }
  get userSelectedAddress() {
    return this.config.selectedAddress;
  }
  get userTokens() {
    var _this$state$tokens$th;
    if (!this.userSelectedAddress) return [];
    return (_this$state$tokens$th = this.state.tokens[this.userSelectedAddress]) !== null && _this$state$tokens$th !== void 0 ? _this$state$tokens$th : [];
  }
  get interval() {
    return this.config.interval;
  }
  set interval(interval) {
    if (this._timer) window.clearInterval(this._timer);
    if (!interval) {
      return;
    }
    this._timer = window.setInterval(() => {
      if (!idleTimeTracker.checkIfIdle()) {
        this.detectNewTokens();
        this.refreshTokenBalances();
      }
    }, interval);
  }
  startTokenDetection(selectedAddress) {
    this.configure({
      selectedAddress
    });
    this.restartTokenDetection();
  }

  /**
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */
  restartTokenDetection() {
    if (!this.userSelectedAddress) {
      return;
    }
    this.detectNewTokens();
    this.refreshTokenBalances();
    this.config.interval = DEFAULT_INTERVAL;
  }
  detectNewTokens() {
    const userAddress = this.userSelectedAddress;
    if (!userAddress) return;
    const currentChainId = this.config.chainId;
    const tokens = []; // object[]
    if (!currentChainId) {
      this.update({
        tokens: {
          [userAddress]: [...tokens]
        }
      });
      return;
    }
    const networkConfig = this.getProviderConfig();
    if (networkConfig !== null && networkConfig !== void 0 && networkConfig.isErc20 && networkConfig !== null && networkConfig !== void 0 && networkConfig.tokenAddress) {
      tokens.push({
        tokenAddress: networkConfig.tokenAddress,
        name: networkConfig.tickerName,
        logo: networkConfig.logo,
        erc20: true,
        symbol: networkConfig.ticker,
        decimals: "18",
        chainId: currentChainId
      });
    }
    if (this.getCustomTokens) {
      const customTokens = this.getCustomTokens(userAddress);
      tokens.push(...customTokens.reduce((acc, x) => {
        if (x.network === currentChainId) acc.push({
          tokenAddress: x.token_address,
          name: x.token_name,
          logo: "eth.svg",
          erc20: true,
          symbol: x.token_symbol,
          decimals: x.decimals,
          balance: "",
          customTokenId: x.id.toString(),
          chainId: x.network
        });
        return acc;
      }, []));
    }
    this.update({
      tokens: {
        [userAddress]: [...tokens]
      }
    });
  }
  async refreshTokenBalances() {
    const userAddress = this.userSelectedAddress;
    if (userAddress === "") return;
    const oldTokens = [...this.userTokens];
    const tokenAddresses = oldTokens.map(x => x.tokenAddress);
    const nonZeroTokens = [];
    try {
      const currentChainId = this.config.chainId;
      if (ETHERSCAN_SUPPORTED_CHAINS.includes(currentChainId)) {
        const etherscanBalances = await this.getEtherScanTokens(userAddress, currentChainId);
        nonZeroTokens.push(...etherscanBalances);
      }
      if (tokenAddresses.length > 0) {
        const currentSingleCallAddress = SINGLE_CALL_BALANCES_ADDRESSES[currentChainId];
        if (currentSingleCallAddress) {
          const ethContract = new Contract(currentSingleCallAddress, singleBalanceCheckerAbi, this.ethersProvider);
          const result = await ethContract.balances([userAddress], tokenAddresses);
          tokenAddresses.forEach((_, index) => {
            const balance = toQuantity(result[index]);
            if (balance && balance !== "0x0") {
              nonZeroTokens.push(_objectSpread(_objectSpread({}, oldTokens[index]), {}, {
                balance,
                chainId: currentChainId
              }));
            }
          });
        } else {
          this.getTokenBalancesUsingHandler(oldTokens);
        }
      }
    } catch (error) {
      log.error(error, "unable to fetch token balances using single call balance address");
      this.getTokenBalancesUsingHandler(oldTokens);
    } finally {
      this.update({
        tokens: {
          [userAddress]: nonZeroTokens
        }
      });
    }
  }
  async getTokenBalancesUsingHandler(customTokens) {
    if (!this.userSelectedAddress) return;
    const currentNetworkTokens = customTokens;
    const promiseSettledResult = await Promise.allSettled(currentNetworkTokens.map(async x => {
      try {
        const tokenInstance = new TokenHandler({
          address: x.tokenAddress,
          decimals: Number.parseInt(x.decimals),
          name: x.name,
          symbol: x.symbol,
          provider: this.ethersProvider
        });
        const balance = await tokenInstance.getUserBalance(this.userSelectedAddress);
        return {
          decimals: tokenInstance.decimals.toString(),
          erc20: true,
          logo: x.logo || "eth.svg",
          name: tokenInstance.name,
          symbol: tokenInstance.symbol,
          tokenAddress: toChecksumAddressByChainId(tokenInstance.address, x.chainId),
          balance: `0x${balance}`,
          customTokenId: x.customTokenId,
          network: x.chainId,
          chainId: x.chainId
        };
      } catch (error) {
        log.warn("Invalid contract address while fetching", error);
        return undefined;
      }
    }));
    const nonZeroTokens = promiseSettledResult.filter(x => x.status === "fulfilled").map(x => x.value);
    this.update({
      tokens: {
        [this.userSelectedAddress]: mergeTokenArrays(this.userTokens, nonZeroTokens)
      }
    });
  }
}

class NonceTracker {
  constructor({
    provider,
    blockTracker,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "getPendingTransactions", void 0);
    _defineProperty(this, "getConfirmedTransactions", void 0);
    _defineProperty(this, "lockMap", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.lockMap = {};
  }
  async getGlobalLock() {
    const globalMutex = this._lookupMutex("global");
    // await global mutex free
    const releaseLock = await globalMutex.acquire();
    return {
      releaseLock
    };
  }

  /**
    this will return an object with the `nextNonce` 
    `nonceDetails`, and the releaseLock.
    Note: releaseLock must be called after adding a signed tx 
    to pending transactions (or discarding).
  */
  async getNonceLock(address) {
    // await global mutex free
    await this._globalMutexFree();
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address);
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {};
      const networkNonceResult = await this._getNetworkNextNonce(address);
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address);
      const nextNetworkNonce = networkNonceResult.nonce;
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed);
      const pendingTxs = this.getPendingTransactions(address);
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested);
      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce
      };
      nonceDetails.local = localNonceResult;
      nonceDetails.network = networkNonceResult;
      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce);

      // return nonce and release cb
      return {
        nextNonce,
        nonceDetails,
        releaseLock
      };
    } catch (error) {
      // release lock if we encounter an error
      releaseLock();
      throw error;
    }
  }
  async _globalMutexFree() {
    const globalMutex = this._lookupMutex("global");
    const releaseLock = await globalMutex.acquire();
    releaseLock();
  }
  async _takeMutex(lockId) {
    const mutex = this._lookupMutex(lockId);
    const releaseLock = await mutex.acquire();
    return releaseLock;
  }
  _lookupMutex(lockId) {
    let mutex = this.lockMap[lockId];
    if (!mutex) {
      mutex = new Mutex();
      this.lockMap[lockId] = mutex;
    }
    return mutex;
  }
  async _getNetworkNextNonce(address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const block = await this.blockTracker.getLatestBlock();
    const baseCountStr = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [address, block.idempotencyKey]
    });
    const baseCount = Number.parseInt(baseCountStr, 16);
    const nonceDetails = {
      block,
      baseCount
    };
    return {
      name: "network",
      nonce: baseCount,
      details: nonceDetails
    };
  }
  _getHighestLocallyConfirmed(address) {
    const confirmedTransactions = this.getConfirmedTransactions(address);
    const highest = this._getHighestNonce(confirmedTransactions);
    return Number.isInteger(highest) ? highest + 1 : 0;
  }
  _getHighestNonce(txList) {
    const nonces = txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    });
    const highestNonce = Math.max.apply(null, nonces);
    return highestNonce;
  }
  _getHighestContinuousFrom(txList, startPoint) {
    const nonces = new Set(txList.map(txMeta => {
      const {
        nonce
      } = txMeta.transaction;
      return Number.parseInt(nonce, 16);
    }));
    let highest = startPoint;
    while (nonces.has(highest)) {
      highest += 1;
    }
    return {
      name: "local",
      nonce: highest,
      details: {
        startPoint,
        highest
      }
    };
  }
}

class PendingTransactionTracker extends SafeEventEmitter {
  constructor({
    provider,
    nonceTracker,
    approveTransaction,
    publishTransaction,
    getPendingTransactions,
    getConfirmedTransactions
  }) {
    super();
    _defineProperty(this, "DROPPED_BUFFER_COUNT", 3);
    _defineProperty(this, "nonceTracker", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "approveTransaction", void 0);
    _defineProperty(this, "droppedBlocksBufferByHash", void 0);
    _defineProperty(this, "getConfirmedTransactions", void 0);
    _defineProperty(this, "getPendingTransactions", void 0);
    _defineProperty(this, "publishTransaction", void 0);
    this.provider = provider;
    this.nonceTracker = nonceTracker;
    this.approveTransaction = approveTransaction;
    this.publishTransaction = publishTransaction;
    this.getPendingTransactions = getPendingTransactions;
    this.getConfirmedTransactions = getConfirmedTransactions;
    this.droppedBlocksBufferByHash = new Map();
  }

  /**
    checks the network for signed txs and releases the nonce global lock if it is
  */
  async updatePendingTxs() {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();
    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));
    } catch (error) {
      log.error("PendingTransactionTracker - Error updating pending transactions");
      log.error(error);
    }
    nonceGlobalLock.releaseLock();
  }
  async resubmitPendingTxs(block) {
    const pending = this.getPendingTransactions();
    // only try resubmitting if their are transactions to resubmit
    if (pending.length === 0) return;
    // Keep this as a for loop because we want to wait for each item to be submitted
    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, block.idempotencyKey);
      } catch (error) {
        var _value;
        /*
        Dont marked as failed if the error is a "known" transaction warning
        "there is already a transaction with the same sender-nonce
        but higher/same gas price"
        Also don't mark as failed if it has ever been broadcast successfully.
        A successful broadcast means it may still be mined.
        */
        const errorMessage = ((_value = error.value) === null || _value === void 0 || (_value = _value.message) === null || _value === void 0 ? void 0 : _value.toLowerCase()) || error.message.toLowerCase();
        const isKnownTx =
        // geth
        errorMessage.includes("replacement transaction underpriced") || errorMessage.includes("known transaction") ||
        // parity
        errorMessage.includes("gas price too low to replace") || errorMessage.includes("transaction with the same hash was already imported") ||
        // other
        errorMessage.includes("gateway timeout") || errorMessage.includes("nonce too low");
        // ignore resubmit warnings, return early
        if (isKnownTx) return;
        // encountered real error - transition to error state
        txMeta.warning = {
          error: errorMessage,
          message: "There was an error when resubmitting this transaction."
        };
        this.emit(TX_EVENTS.TX_WARNING, {
          txMeta,
          error,
          txId: txMeta.id
        });
      }
    }
  }
  async _resubmitTx(txMeta, latestBlockNumber) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit(TX_EVENTS.TX_BLOCK_UPDATE, {
        txMeta,
        latestBlockNumber,
        txId: txMeta.id
      });
    }
    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);
    const retryCount = txMeta.retryCount || 0;

    // Exponential backoff to limit retries at publishing (capped at last 15 mins)
    if (txBlockDistance <= Math.min(50, 2 ** retryCount)) return undefined;

    // Only auto-submit already-signed txs:
    if (!("rawTransaction" in txMeta)) return this.approveTransaction(txMeta.id);
    const {
      rawTransaction
    } = txMeta;
    const txHash = await this.publishTransaction(rawTransaction);

    // Increment successful tries:
    this.emit(TX_EVENTS.TX_RETRY, {
      txMeta,
      txId: txMeta.id
    });
    return txHash;
  }
  async _checkPendingTx(foundTx) {
    const txMeta = foundTx;
    const txHash = txMeta.transactionHash;
    const txId = txMeta.id;

    // Only check submitted txs
    if (txMeta.status !== TransactionStatus.submitted) return;

    // extra check in case there was an uncaught error during the
    // signature and submission process
    if (!txHash) {
      const noTxHashError = new Error("We had an error while submitting this transaction, please try again.");
      noTxHashError.name = "NoTxHashError";
      this.emit(TX_EVENTS.TX_FAILED, {
        txId,
        error: noTxHashError
      });
      return;
    }

    // If another tx with the same nonce is mined, set as failed.
    if (this._checkIfNonceIsTaken(txMeta)) {
      this.emit(TX_EVENTS.TX_DROPPED, {
        txId
      });
      return;
    }
    try {
      const transactionReceipt = await this.provider.request({
        method: METHOD_TYPES.ETH_GET_TRANSACTION_RECEIPT,
        params: [txHash]
      });
      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {
        const {
          baseFeePerGas,
          timestamp
        } = await this.provider.request({
          method: METHOD_TYPES.ETH_GET_BLOCK_BY_HASH,
          params: [transactionReceipt.blockHash, false]
        });
        this.emit(TX_EVENTS.TX_CONFIRMED, {
          txId,
          txReceipt: transactionReceipt,
          baseFeePerGas,
          blockTimestamp: timestamp
        });
        return;
      }
    } catch (error) {
      log.error("error while loading tx", error);
      txMeta.warning = {
        error: error.message,
        message: "There was a problem loading this transaction."
      };
      this.emit(TX_EVENTS.TX_WARNING, {
        txMeta
      });
    }
    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit(TX_EVENTS.TX_DROPPED, {
        txId
      });
    }
  }
  async _checkIfTxWasDropped(txMeta) {
    const {
      transactionHash: txHash,
      transaction: {
        nonce,
        from
      }
    } = txMeta;
    const networkNextNonce = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_TRANSACTION_COUNT,
      params: [from, "latest"]
    });
    if (Number.parseInt(nonce, 16) >= Number.parseInt(networkNextNonce, 16)) {
      return false;
    }
    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }
    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);
    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }
    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }
  _checkIfNonceIsTaken(txMeta) {
    const address = txMeta.transaction.from;
    const completed = this.getConfirmedTransactions(address);
    return completed.some(otherMeta => {
      if (otherMeta.id === txMeta.id) {
        return false;
      }
      return otherMeta.transaction.nonce === txMeta.transaction.nonce;
    });
  }
}

class TransactionGasUtil {
  constructor(provider, blockTracker) {
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    this.provider = provider;
    this.blockTracker = blockTracker;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.blockTracker.getLatestBlock();
    // fallback to block gasLimit
    const blockGasLimitBN = new BN$1(stripHexPrefix(block.gasLimit), 16);
    const saferGasLimitBN = blockGasLimitBN.mul(new BN$1(19)).div(new BN$1(20));
    let estimatedGasHex = addHexPrefix(saferGasLimitBN.toString("hex"));
    let simulationFails;
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      log.warn(error);
      simulationFails = {
        reason: error.message,
        errorKey: error.errorKey,
        debug: {
          blockNumber: block.idempotencyKey,
          blockGasLimit: block.gasLimit
        }
      };
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex,
      simulationFails
    };
  }

  /**
    Adds a gas buffer with out exceeding the block gas limit
  */
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = new BN$1(stripHexPrefix(initialGasLimitHex), 16);
    const blockGasLimitBn = new BN$1(stripHexPrefix(blockGasLimitHex), 16);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return addHexPrefix(initialGasLimitBn.toString("hex"));
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return addHexPrefix(bufferedGasLimitBn.toString("hex"));
    // otherwise use blockGasLimit
    return addHexPrefix(upperGasLimitBn.toString("hex"));
  }

  /**
    Estimates the tx's gas usage
  */
  async estimateTxGas(txMeta) {
    const txParams = cloneDeep(txMeta.transaction);

    // `eth_estimateGas` can fail if the user has insufficient balance for the
    // value being sent, or for the gas cost. We don't want to check their
    // balance here, we just want the gas estimate. The gas price is removed
    // to skip those balance checks. We check balance elsewhere. We also delete
    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    return this.provider.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
  }
}

function sortBy(arr, key) {
  return arr.slice().sort((a, b) => {
    if (a[key] < b[key]) return -1;
    if (a[key] > b[key]) return 1;
    return 0;
  });
}
function keyBy(arr, key) {
  return arr.reduce((acc, item) => {
    const keyValue = item[key];
    if (typeof keyValue === "string" || typeof keyValue === "number") {
      acc[keyValue.toString()] = item;
    }
    return acc;
  }, {});
}
function mapValues(obj, iteratee) {
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, iteratee(value, key)]));
}

/**
  Generates an array of history objects sense the previous state.
  The object has the keys
    op (the operation performed),
    path (the key and if a nested object then each key will be seperated with a `/`)
    value
  with the first entry having the note and a timestamp when the change took place
*/
function generateHistoryEntry(previousState, newState, note) {
  const entry = jsonDiffer.compare(previousState, newState);
  // Add a note to the first op, since it breaks if we append it to the entry
  if (entry[0]) {
    if (note) {
      entry[0].note = note;
    }
    entry[0].timestamp = Date.now();
  }
  return entry;
}

/**
  Recovers previous txMeta state obj
*/
function replayHistory(_shortHistory) {
  const shortHistory = cloneDeep(_shortHistory);
  return shortHistory.reduce((val, entry) => jsonDiffer.applyPatch(val, entry).newDocument);
}
function snapshotFromTxMeta(txMeta) {
  const shallow = _objectSpread({}, txMeta);
  delete shallow.history;
  return cloneDeep(shallow);
}

class TransactionStateManager extends BaseTransactionStateManager {
  constructor({
    config,
    state,
    getCurrentChainId
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
  }
  generateTxMeta(opts = {}) {
    var _opts$transaction;
    const chainId = this.getCurrentChainId();
    if (chainId === "loading") throw new Error("Torus is having trouble connecting to the network");
    let dappSuggestedGasFees = null;

    // If we are dealing with a transaction suggested by a dapp and not
    // an internally created transaction, we need to keep record of
    // the originally submitted gasParams.
    if (opts.transaction && typeof opts.origin === "string" && opts.origin !== "torus") {
      if (typeof opts.transaction.gasPrice !== "undefined") {
        dappSuggestedGasFees = {
          gasPrice: opts.transaction.gasPrice
        };
      } else if (typeof opts.transaction.maxFeePerGas !== "undefined" || typeof opts.transaction.maxPriorityFeePerGas !== "undefined") {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.transaction.maxPriorityFeePerGas,
          maxFeePerGas: opts.transaction.maxFeePerGas
        };
      }
      if (typeof opts.transaction.gas !== "undefined") {
        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {
          gas: opts.transaction.gas
        });
      }
    }
    return _objectSpread({
      id: ((_opts$transaction = opts.transaction) === null || _opts$transaction === void 0 ? void 0 : _opts$transaction.id) || randomId(),
      time: Date.now(),
      status: TransactionStatus.unapproved,
      loadingDefaults: true,
      chainId,
      dappSuggestedGasFees
    }, opts);
  }
  addTransactionToState(txMeta) {
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }
    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    });
    // initialize history
    txMeta.history = [];
    // capture initial snapshot of txMeta for history
    const snapshot = snapshotFromTxMeta(txMeta);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this.config;

    // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.
    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce
      } = tx.transaction;
      const {
        chainId,
        status
      } = tx;
      const key = `${nonce}-${chainId}`;
      if (nonceNetworkSet.has(key)) {
        return false;
      }
      if (nonceNetworkSet.size < txHistoryLimit - 1 || getFinalStates().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }
      return true;
    }).map(tx => tx.id);
    this._deleteTransactions(txsToDelete);
    this._addTransactionsToState([txMeta]);
    return txMeta;
  }

  /**
    Removes transaction from the given address for the current network
    from the txList
  */
  wipeTransactions(address) {
    const {
      transactions
    } = this.state;
    const chainId = this.getCurrentChainId();
    this.update({
      transactions: omitBy(transactions, txMeta => {
        const transactionMatch = transactionMatchesNetwork$1(txMeta, chainId);
        return txMeta.transaction.from === address && transactionMatch;
      })
    });
  }
  getTransactions({
    searchCriteria = {},
    initialList = undefined,
    filterToCurrentNetwork = true,
    limit = undefined
  } = {}) {
    const chainId = this.getCurrentChainId();
    // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.
    const predicateMethods = mapValues(searchCriteria, predicate => typeof predicate === "function" ? predicate : v => v === predicate);

    // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.
    const transactionsToFilter = initialList ? keyBy(initialList, "id") : this.state.transactions;

    // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.
    const filteredTransactions = sortBy(Object.values(pickBy(transactionsToFilter, txMeta => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      const transactionMatches = transactionMatchesNetwork$1(txMeta, chainId);
      if (filterToCurrentNetwork && !transactionMatches) {
        return false;
      }
      // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria
      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in txMeta.transaction) {
          if (predicate(txMeta.transaction[key]) === false) {
            return false;
          }
        } else if (predicate(txMeta[key]) === false) {
          return false;
        }
      }
      return true;
    })), "time");
    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = [];
      // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.
      for (let i = filteredTransactions.length - 1; i > -1; i -= 1) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.transaction;
        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        }
        // Push transaction into the beginning of our array to ensure the
        // original order is preserved.
        txs.unshift(txMeta);
      }
      return txs;
    }
    return filteredTransactions;
  }
  getApprovedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.approved
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getSubmittedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.submitted
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getPendingTransactions(address) {
    const submitted = this.getSubmittedTransactions(address);
    const approved = this.getApprovedTransactions(address);
    return [...submitted, ...approved];
  }
  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: TransactionStatus.confirmed
    };
    if (address) {
      searchCriteria.from = address;
    }
    return this.getTransactions({
      searchCriteria
    });
  }
  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    return pickBy(this.state.transactions, transaction => {
      const transactionMatches = transactionMatchesNetwork$1(transaction, chainId);
      return transaction.status === TransactionStatus.unapproved && transactionMatches;
    });
  }
  updateTransactionInState(txMeta, note) {
    // validate txParams
    if (txMeta.transaction) {
      txMeta.transaction = normalizeAndValidateTxParams(txMeta.transaction, false);
    }

    // create txMeta snapshot for history
    const currentState = snapshotFromTxMeta(txMeta);
    // recover previous tx state obj
    const previousState = replayHistory(txMeta.history);
    // generate history entry and add to history
    const entry = generateHistoryEntry(previousState, currentState, note);
    if (entry.length > 0) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      txMeta.history.push(entry);
    }

    // commit txMeta to state
    this.updateTransaction(txMeta);
  }
  _setTransactionStatus(txId, status, isFinalStep) {
    const txMeta = this.getTransaction(txId);
    if (!txMeta) {
      return;
    }
    txMeta.status = status;
    this.updateTransactionInState(txMeta);
    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {
      txId,
      status
    });
    if (this.isFinalState(status) || isFinalStep) {
      this.emit(`${txMeta.id}:finished`, txMeta);
    } else {
      this.emit(`${txMeta.id}:${status}`, txId);
    }
  }
}

class TransactionController extends TransactionStateManager {
  constructor({
    config,
    state,
    provider,
    blockTracker,
    signEthTx,
    getCurrentChainId,
    getCurrentNetworkEIP1559Compatibility,
    getProviderConfig,
    getCurrentAccountEIP1559Compatibility,
    getSelectedAddress,
    getEIP1559GasFeeEstimates
  }) {
    super({
      config,
      state,
      getCurrentChainId
    });
    _defineProperty(this, "getSelectedAddress", void 0);
    _defineProperty(this, "getEIP1559GasFeeEstimates", void 0);
    _defineProperty(this, "nonceTracker", void 0);
    _defineProperty(this, "pendingTxTracker", void 0);
    _defineProperty(this, "txGasUtil", void 0);
    _defineProperty(this, "_getCurrentNetworkEIP1559Compatibility", void 0);
    _defineProperty(this, "_getCurrentAccountEIP1559Compatibility", void 0);
    _defineProperty(this, "getProviderConfig", void 0);
    _defineProperty(this, "signEthTx", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "blockTracker", void 0);
    _defineProperty(this, "inProcessOfSigning", new Set());
    _defineProperty(this, "getUnapprovedTxCount", () => Object.keys(this.getUnapprovedTxList()).length);
    _defineProperty(this, "getPendingTxCount", account => this.getPendingTransactions(account).length);
    this.blockTracker = blockTracker;
    this.getProviderConfig = getProviderConfig;
    this._getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
    this._getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
    this.getSelectedAddress = getSelectedAddress;
    this.getEIP1559GasFeeEstimates = getEIP1559GasFeeEstimates;
    this.signEthTx = signEthTx;
    this.provider = provider;
    this.txGasUtil = new TransactionGasUtil(this.provider, this.blockTracker);
    this.nonceTracker = new NonceTracker({
      provider,
      blockTracker,
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      getPendingTransactions: this.getSubmittedTransactions.bind(this) // nonce tracker should only care about submitted transactions
    });
    this.pendingTxTracker = new PendingTransactionTracker({
      provider,
      nonceTracker: this.nonceTracker,
      getPendingTransactions: this.getPendingTransactions.bind(this),
      // pending tx tracker should only care about submitted and approved transactions
      getConfirmedTransactions: this.getConfirmedTransactions.bind(this),
      approveTransaction: this.approveTransaction.bind(this),
      publishTransaction: rawTx => this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      })
    });
    this._setupListeners();
  }
  addTransactionUnapproved(txMeta) {
    this.addTransactionToState(txMeta);
    this.emit(`${txMeta.id}:unapproved`, txMeta);
  }
  async addNewUnapprovedTransaction(txParams, req) {
    const txMeta = await this.createTransaction(txParams, req);
    return this.processApproval(txMeta);
  }
  async processApproval(txMeta) {
    return new Promise((resolve, reject) => {
      const handleFinished = msg => {
        if (msg.status === TransactionStatus.rejected) {
          return reject(providerErrors.userRejectedRequest(`Transaction Signature: User denied message signature`));
        }
        if (msg.status === TransactionStatus.failed) {
          return reject(rpcErrors.internal(`Transaction Signature: failed to sign message ${msg.error}`));
        }
        if (msg.status === TransactionStatus.submitted) {
          return resolve(msg.transactionHash);
        }
        return reject(rpcErrors.internal(`Transaction Signature: Unknown problem: ${JSON.stringify(txMeta.transaction)}`));
      };
      this.once(`${txMeta.id}:finished`, handleFinished);
    });
  }
  async approveTransaction(transactionID) {
    const txMeta = this.getTransaction(transactionID);
    if (this.inProcessOfSigning.has(transactionID)) {
      return;
    }
    this.inProcessOfSigning.add(transactionID);
    let nonceLock;
    try {
      this.setTxStatusApproved(transactionID);
      const fromAddress = txMeta.transaction.from;
      const {
        customNonceValue
      } = txMeta.transaction;
      const customNonceValueNumber = Number(customNonceValue);
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress);
      // add nonce to txParams
      // if txMeta has previousGasParams then it is a retry at same nonce with
      // higher gas settings and therefor the nonce should not be recalculated
      const nonce = nonceLock.nextNonce;
      const customOrNonce = customNonceValueNumber === 0 ? customNonceValue : customNonceValue || nonce;
      txMeta.transaction.nonce = addHexPrefix(customOrNonce.toString(16));
      // add nonce debugging information to txMeta
      txMeta.nonceDetails = nonceLock.nonceDetails;
      this.updateTransactionInState(txMeta, "transactions#approveTransaction");
      // sign transaction
      const rawTx = await this.signTransaction(transactionID);
      await this.publishTransaction(transactionID, rawTx);
      nonceLock.releaseLock();
    } catch (err) {
      try {
        this.setTxStatusFailed(transactionID, err);
      } catch (err2) {
        log.error(err2);
      }
      // must set transaction to submitted/failed before releasing lock
      if (nonceLock) {
        nonceLock.releaseLock();
      }
      // continue with error chain
      throw err;
    } finally {
      this.inProcessOfSigning.delete(transactionID);
    }
  }
  async signTransaction(txId) {
    const txMeta = this.getTransaction(txId);
    const chainId = this.getCurrentChainId();
    const type = isEIP1559Transaction(txMeta) ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
    const txParams = _objectSpread(_objectSpread({}, txMeta.transaction), {}, {
      type,
      chainId,
      gasLimit: txMeta.transaction.gas
    });
    const fromAddress = txParams.from;
    const common = await this.getCommonConfiguration(fromAddress);
    const {
      TransactionFactory
    } = await import('@ethereumjs/tx');
    const unsignedEthTx = TransactionFactory.fromTxData(txParams, {
      common
    });
    const signedEthTx = await this.signEthTx(unsignedEthTx, fromAddress);
    txMeta.r = addHexPrefix(signedEthTx.r.toString(16));
    txMeta.s = addHexPrefix(signedEthTx.s.toString(16));
    txMeta.v = addHexPrefix(signedEthTx.v.toString(16));
    this.updateTransactionInState(txMeta, "transactions#signTransaction: add r, s, v values");
    this.setTxStatusSigned(txId);
    const rawTx = addHexPrefix(Buffer.from(signedEthTx.serialize()).toString("hex"));
    return rawTx;
  }
  async publishTransaction(txId, rawTx) {
    const txMeta = this.getTransaction(txId);
    txMeta.rawTransaction = rawTx;
    this.updateTransactionInState(txMeta, "transactions#publishTransaction");
    let txHash;
    try {
      txHash = await this.provider.request({
        method: METHOD_TYPES.ETH_SEND_RAW_TRANSACTION,
        params: [rawTx]
      });
    } catch (error) {
      if (error.message.toLowerCase().includes("known transaction")) {
        txHash = keccak256(addHexPrefix(rawTx));
        txHash = addHexPrefix(txHash);
      } else {
        throw error;
      }
    }
    this.setTxHash(txId, txHash);
    this.setTxStatusSubmitted(txId);
  }
  async confirmTransaction(params) {
    const {
      txId,
      txReceipt
    } = params;
    log.info(params, "confirm params");
    const txMeta = this.getTransaction(txId);
    if (!txMeta) return;
    try {
      txMeta.txReceipt = _objectSpread({}, txReceipt);
      this.setTxStatusConfirmed(txId);
      this.markNonceDuplicatesDropped(txId);
      this.updateTransactionInState(txMeta, "transactions#confirmTransaction - add txReceipt");
    } catch (error) {
      log.error(error);
    }
  }
  cancelTransaction(transactionID) {
    throw new Error(`Method not implemented. ${transactionID}`);
  }
  async getEIP1559Compatibility(fromAddress) {
    const currentNetworkIsCompatible = await this._getCurrentNetworkEIP1559Compatibility();
    const fromAccountIsCompatible = await this._getCurrentAccountEIP1559Compatibility(fromAddress);
    return currentNetworkIsCompatible && fromAccountIsCompatible;
  }
  async addTransactionGasDefaults(txMeta) {
    let updateTxMeta = txMeta;
    try {
      updateTxMeta = await this.addTxGasDefaults(txMeta);
    } catch (error) {
      log.warn(error);
      updateTxMeta = this.getTransaction(txMeta.id);
      updateTxMeta.loadingDefaults = false;
      this.updateTransactionInState(txMeta, "Failed to calculate gas defaults.");
      throw error;
    }
    updateTxMeta.loadingDefaults = false;
    this.updateTransactionInState(updateTxMeta, "Added new unapproved transaction.");
    return updateTxMeta;
  }
  async addTxGasDefaults(txMeta) {
    const eip1559Compatibility = txMeta.transaction.type !== TRANSACTION_ENVELOPE_TYPES.LEGACY && (await this.getEIP1559Compatibility());
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this.getDefaultGasFees(txMeta, eip1559Compatibility);
    const {
      gasLimit: defaultGasLimit,
      simulationFails
    } = await this.getDefaultGasLimit(txMeta);
    txMeta = this.getTransaction(txMeta.id);
    if (simulationFails) {
      txMeta.simulationFails = simulationFails;
    }
    if (eip1559Compatibility) {
      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.
      if (txMeta.transaction.gasPrice && !txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
        txMeta.transaction.maxFeePerGas = txMeta.transaction.gasPrice;
        // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas
        // then we set maxFeePerGas to the suggested gasPrice.

        txMeta.transaction.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof txMeta.transaction.gasPrice === "string" ? stripHexPrefix(txMeta.transaction.gasPrice) : txMeta.transaction.gasPrice) ? defaultMaxPriorityFeePerGas : txMeta.transaction.gasPrice;
      } else {
        if (defaultMaxFeePerGas && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxFeePerGas = defaultMaxFeePerGas;
        }
        if (defaultMaxPriorityFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas
          // with the one returned by the gasFeeController, if that is available.
          txMeta.transaction.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
        }
        if (defaultGasPrice && !txMeta.transaction.maxFeePerGas) {
          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available
          // from the gasFeeController, then we set maxFeePerGas to the defaultGasPrice, assuming it is
          // available.
          txMeta.transaction.maxFeePerGas = defaultGasPrice;
        }
        if (txMeta.transaction.maxFeePerGas && !txMeta.transaction.maxPriorityFeePerGas) {
          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is
          // available from the gasFeeController, then we set maxPriorityFeePerGas to
          // txMeta.transaction.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas
          // set by the dapp, or the maxFeePerGas from the controller.
          txMeta.transaction.maxPriorityFeePerGas = txMeta.transaction.maxFeePerGas;
        }
      }

      // We remove the gasPrice param entirely when on an eip1559 compatible network

      delete txMeta.transaction.gasPrice;
    } else {
      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params
      // when not on a EIP1559 compatible network

      delete txMeta.transaction.maxPriorityFeePerGas;
      delete txMeta.transaction.maxFeePerGas;
    }

    // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are
    // set on transaction, it means that either we are on a non-EIP1559 network and the dapp didn't suggest
    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas
    // were available from either the dapp or the network.
    if (defaultGasPrice && !txMeta.transaction.gasPrice && !txMeta.transaction.maxPriorityFeePerGas && !txMeta.transaction.maxFeePerGas) {
      txMeta.transaction.gasPrice = defaultGasPrice;
    }
    if (defaultGasLimit && !txMeta.transaction.gas) {
      txMeta.transaction.gas = defaultGasLimit;
    }
    return txMeta;
  }
  setTxHash(txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.getTransaction(txId);
    txMeta.transactionHash = txHash;
    this.updateTransactionInState(txMeta, "transactions#setTxHash");
  }
  async getDefaultGasFees(txMeta, eip1559Compatibility) {
    if (!eip1559Compatibility && txMeta.transaction.gasPrice || eip1559Compatibility && txMeta.transaction.maxFeePerGas && txMeta.transaction.maxPriorityFeePerGas) {
      return {};
    }
    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this.getEIP1559GasFeeEstimates();
      if (eip1559Compatibility && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        // this is in dec gwei
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;
        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            // send to controller in hex wei
            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxFeePerGas)).toString(16)),
            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(new BigNumber(suggestedMaxPriorityFeePerGas)).toString(16))
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        const {
          medium
        } = gasFeeEstimates;
        // The LEGACY type includes low, medium and high estimates of
        // gas price values.
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(medium)).toString(16))
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        const {
          gasPrice
        } = gasFeeEstimates;
        // The ETH_GASPRICE type just includes a single gas price property,
        // which we can assume was retrieved from eth_gasPrice
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(new BigNumber(gasPrice)).toString(16))
        };
      }
    } catch (error) {
      log.error(error);
    }
    const gasPrice = await this.provider.request({
      method: METHOD_TYPES.ETH_GET_GAS_PRICE
    });
    return {
      gasPrice: gasPrice && addHexPrefix(gasPrice)
    };
  }
  async getDefaultGasLimit(txMeta) {
    const chainId = this.getCurrentChainId();
    const customNetworkGasBuffer = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
    const chainType = getChainType(chainId);
    if (txMeta.transaction.gas) {
      return {};
    }
    if (txMeta.transaction.to && txMeta.transactionCategory === TRANSACTION_TYPES.SENT_ETHER && chainType !== "custom" && !txMeta.transaction.data) {
      // This is a standard ether simple send, gas requirement is exactly 21k
      return {
        gasLimit: GAS_LIMITS.SIMPLE
      };
    }
    const {
      blockGasLimit,
      estimatedGasHex,
      simulationFails
    } = await this.txGasUtil.analyzeGasUsage(txMeta);

    // add additional gas buffer to our estimation for safety
    const gasLimit = this.txGasUtil.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit, customNetworkGasBuffer);
    return {
      gasLimit,
      simulationFails
    };
  }
  async createTransaction(txParameters, req) {
    const normalizedTxParameters = normalizeTxParameters(txParameters);
    const eip1559Compatibility = await this.getEIP1559Compatibility(txParameters.from);
    validateTxParameters(normalizedTxParameters, eip1559Compatibility);
    let txMeta = this.generateTxMeta({
      transaction: normalizedTxParameters,
      origin: req.origin
    });
    const {
      type,
      category,
      methodParams
    } = await determineTransactionType(txParameters, this.provider);
    txMeta.contractType = type;
    txMeta.transactionCategory = category;
    txMeta.methodParams = methodParams;
    txMeta.transaction.value = txMeta.transaction.value ? addHexPrefix(txMeta.transaction.value) : "0x0";
    this.emit(`${txMeta.id}:unapproved`, txMeta);
    txMeta = this.addTransactionToState(txMeta);
    txMeta = await this.addTransactionGasDefaults(txMeta);
    this.emit(TX_EVENTS.TX_UNAPPROVED, {
      txMeta,
      req
    });
    return txMeta;
  }
  _setupListeners() {
    this.setupBlockTrackerListener();
    this.pendingTxTracker.on(TX_EVENTS.TX_WARNING, data => {
      this.updateTransactionInState(data.txMeta);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_DROPPED, data => this.setTxStatusDropped(data.txId));
    this.pendingTxTracker.on(TX_EVENTS.TX_BLOCK_UPDATE, ({
      txMeta,
      latestBlockNumber
    }) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber;
        this.updateTransactionInState(txMeta);
      }
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_RETRY, txMeta => {
      if (!("retryCount" in txMeta)) {
        txMeta.retryCount = 0;
      }
      txMeta.retryCount += 1;
      this.updateTransactionInState(txMeta);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_FAILED, data => {
      this.setTxStatusFailed(data.txId, data.error);
    });
    this.pendingTxTracker.on(TX_EVENTS.TX_CONFIRMED, data => this.confirmTransaction(data));
  }
  setupBlockTrackerListener() {
    let listenersAreActive = false;
    const latestBlockHandler = this.onLatestBlock.bind(this);
    this.on(TX_EVENTS.TX_STATUS_UPDATE, () => {
      const pendingTxs = this.getPendingTransactions();
      if (!listenersAreActive && pendingTxs.length > 0) {
        this.blockTracker.on("latest", latestBlockHandler);
        listenersAreActive = true;
      } else if (listenersAreActive && !pendingTxs.length) {
        this.blockTracker.removeListener("latest", latestBlockHandler);
        listenersAreActive = false;
      }
    });
  }
  async onLatestBlock(blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs();
    } catch (error) {
      log.error(error);
    }
    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber);
    } catch (error) {
      log.error(error);
    }
  }
  async getCommonConfiguration(fromAddress) {
    const {
      chainId,
      displayName
    } = this.getProviderConfig();
    const supportsEIP1559 = await this.getEIP1559Compatibility(fromAddress);
    const {
      Common,
      Hardfork
    } = await import('@ethereumjs/common');
    const hardfork = supportsEIP1559 ? Hardfork.Paris : Hardfork.Berlin;
    return Common.custom({
      chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
      defaultHardfork: hardfork,
      name: displayName,
      networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16)
    });
  }
  markNonceDuplicatesDropped(txId) {
    const txMeta = this.getTransaction(txId);
    const {
      nonce,
      from
    } = txMeta.transaction;
    const sameNonceTxs = this.getTransactions({
      searchCriteria: {
        from,
        nonce
      }
    });
    if (!sameNonceTxs.length) return;
    sameNonceTxs.forEach(tx => {
      if (tx.id === txId) return;
      this.updateTransactionInState(txMeta, "transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce");
      if (tx.status !== TransactionStatus.failed) this.setTxStatusDropped(tx.id);
    });
  }
}

export { ARBITRUM_MAINNET_CHAIN_ID, ARBITRUM_TESTNET_CHAIN_ID, AVALANCHE_MAINNET_CHAIN_ID, AVALANCHE_TESTNET_CHAIN_ID, AccountTrackerController, AddChainController, BASE_CHAIN_ID, BASE_TESTNET_CHAIN_ID, BNToHex, BSC_MAINNET_CHAIN_ID, BSC_TESTNET_CHAIN_ID, CELO_MAINNET_CHAIN_ID, CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP, COINGECKO_PLATFORMS_CHAIN_CODE_MAP, COINGECKO_SUPPORTED_CURRENCIES, CONTRACT_TYPE_ERC1155, CONTRACT_TYPE_ERC20, CONTRACT_TYPE_ERC721, CONTRACT_TYPE_ETH, CurrencyController, DEFAULT_CURRENCY, DecryptMessageController, ERC1155_INTERFACE_ID, ERC721_ENUMERABLE_INTERFACE_ID, ERC721_INTERFACE_ID, ERC721_METADATA_INTERFACE_ID, ETHERSCAN_SUPPORTED_CHAINS, EncryptionPublicKeyController, GAS_ESTIMATE_TYPES, GAS_LIMITS, GasFeeController, KeyringController, LOCALHOST, MAINNET_CHAIN_ID, MESSAGE_EVENTS, METHOD_TYPES, MessageController, MessageStatus, NetworkController, NftHandler, NftsController, NonceTracker, OLD_ERC721_LIST, OPTIMISM_MAINNET_CHAIN_ID, OPTIMISM_TESTNET_CHAIN_ID, POLYGON_AMOY_CHAIN_ID, POLYGON_CHAIN_ID, PendingTransactionTracker, PersonalMessageController, PollingBlockTracker, PreferencesController, SEPOLIA_CHAIN_ID, SIMPLEHASH_SUPPORTED_CHAINS, SUPPORTED_NETWORKS, SwitchChainController, TEST_CHAINS, TRANSACTION_ENVELOPE_TYPES, TokenHandler, TokenRatesController, TokensController, TransactionController, TransactionGasUtil, TransactionStateManager, TypedMessageController, XDAI_CHAIN_ID, addCurrencies, addEtherscanTransactions, bnLessThan, conversionGTE, conversionGreaterThan, conversionLTE, conversionLessThan, conversionMax, conversionUtil, createChainIdMiddleware, createEthereumMiddleware, createGetAccountsMiddleware, createJsonRpcClient, createPendingNonceMiddleware, createPendingTxMiddleware, createProcessAddEthereumChain, createProcessDecryptMessageMiddleware, createProcessEncryptionPublicKeyMiddleware, createProcessEthSignMessage, createProcessPersonalMessage, createProcessSwitchEthereumChain, createProcessTransactionMiddleware, createProcessTypedMessage, createProcessTypedMessageV3, createProcessTypedMessageV4, createProviderConfigMiddleware, createRequestAccountsMiddleware, decGWEIToHexWEI, determineTransactionType, ensureFieldIsString, ensureMutuallyExclusiveFieldsNotProvided, erc1155Abi, erc20Abi, erc721Abi, formatDate, formatPastTx, formatTime, formatTxMetaForRpcResult, generateHistoryEntry, getBigNumber, getChainType, getEthTxStatus, getEtherScanHashLink, getFinalStates, getIpfsEndpoint, hexToBn, hexWEIToDecGWEI, idleTimeTracker, isAddressByChainId, isEIP1559Transaction, isLegacyTransaction, multiplyCurrencies, normalizeAndValidateTxParams, normalizeMessageData, normalizeTxParameters, parseDecryptMessageData, parseStandardTokenTransactionData, readAddressAsContract, replayHistory, sanitizeNftMetdataUrl, singleBalanceCheckerAbi, snapshotFromTxMeta, subtractCurrencies, toChecksumAddressByChainId, toNegative, transactionMatchesNetwork, validateAddChainData, validateAddress, validateDecryptedMessageData, validateEncryptionPublicKeyMessageData, validateFrom, validateRecipient, validateSignMessageData, validateSwitchChainData, validateTxParameters, validateTypedSignMessageDataV1, validateTypedSignMessageDataV3V4 };
